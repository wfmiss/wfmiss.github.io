(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function t(t){for(var r,a,s=t[0],c=t[1],u=t[2],p=0,d=[];p<s.length;p++)a=s[p],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&d.push(i[a][0]),i[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(l&&l(t);d.length;)d.shift()();return o.push.apply(o,u||[]),e()}function e(){for(var n,t=0;t<o.length;t++){for(var e=o[t],r=!0,s=1;s<e.length;s++){var c=e[s];0!==i[c]&&(r=!1)}r&&(o.splice(t--,1),n=a(a.s=e[0]))}return n}var r={},i={1:0},o=[];function a(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.e=function(n){var t=[],e=i[n];if(0!==e)if(e)t.push(e[2]);else{var r=new Promise((function(t,r){e=i[n]=[t,r]}));t.push(e[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+"assets/js/"+({}[n]||n)+"."+{2:"b7d28b34",3:"c5f9f392",4:"f06af0e8",5:"76fab509",6:"e8823ccd",7:"64b43ff1",8:"a6738900",9:"4baf5fe4",10:"3dcb08b2",11:"0a18f7bd",12:"c81a73a2",13:"c98c26c1",14:"36d42ece",15:"bda77217",16:"80047c9b",17:"548d378f",18:"86a99a23",19:"f47c7d29",20:"7e536bfb",21:"6dac4a9e",22:"c40c5423",23:"e52bc27f",24:"bfa36715",25:"195a37e7",26:"2e9f5321",27:"6e80d82e",28:"2cd04043",29:"47a1754b",30:"7d2dd507",31:"d395de78",32:"99af69ad",33:"1e427cb5",34:"f9dd6bb5",35:"d7896692"}[n]+".js"}(n);var c=new Error;o=function(t){s.onerror=s.onload=null,clearTimeout(u);var e=i[n];if(0!==e){if(e){var r=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",c.name="ChunkLoadError",c.type=r,c.request=o,e[1](c)}i[n]=void 0}};var u=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(t)},a.m=n,a.c=r,a.d=function(n,t,e){a.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,t){if(1&t&&(n=a(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(a.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var r in n)a.d(e,r,function(t){return n[t]}.bind(null,r));return e},a.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(t,"a",t),t},a.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},a.p="/",a.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var u=0;u<s.length;u++)t(s[u]);var l=c;o.push([233,0]),e()}([function(n,t){var e=function(n){return n&&n.Math==Math&&n};n.exports=e("object"==typeof globalThis&&globalThis)||e("object"==typeof window&&window)||e("object"==typeof self&&self)||e("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,t,e){var r=e(60),i=Function.prototype,o=i.bind,a=i.call,s=r&&o.bind(a,a);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return a.apply(n,arguments)}}},function(n,t,e){var r=e(0),i=e(39).f,o=e(23),a=e(14),s=e(108),c=e(114),u=e(100);n.exports=function(n,t){var e,l,p,d,f,h=n.target,m=n.global,v=n.stat;if(e=m?r:v?r[h]||s(h,{}):(r[h]||{}).prototype)for(l in t){if(d=t[l],p=n.noTargetGet?(f=i(e,l))&&f.value:e[l],!u(m?l:h+(v?".":"#")+l,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&o(d,"sham",!0),a(e,l,d,n)}}},function(n,t){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,t){n.exports=function(n){return"function"==typeof n}},function(n,t,e){var r=e(0),i=e(76),o=e(10),a=e(77),s=e(109),c=e(152),u=i("wks"),l=r.Symbol,p=l&&l.for,d=c?l:l&&l.withoutSetter||a;n.exports=function(n){if(!o(u,n)||!s&&"string"!=typeof u[n]){var t="Symbol."+n;s&&o(l,n)?u[n]=l[n]:u[n]=c&&p?p(t):d(t)}return u[n]}},function(n,t,e){var r=e(117),i=e(14),o=e(249);r||i(Object.prototype,"toString",o,{unsafe:!0})},function(n,t,e){var r=e(0),i=e(8),o=r.String,a=r.TypeError;n.exports=function(n){if(i(n))return n;throw a(o(n)+" is not an object")}},function(n,t,e){var r=e(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,t,e){var r=e(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,t,e){var r=e(1),i=e(15),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,t){return o(i(n),t)}},function(n,t,e){var r=e(60),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,t,e){var r=e(0),i=e(73),o=r.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,t,e){var r=e(0),i=e(9),o=e(154),a=e(153),s=e(7),c=e(79),u=r.TypeError,l=Object.defineProperty,p=Object.getOwnPropertyDescriptor;t.f=i?a?function(n,t,e){if(s(n),t=c(t),s(e),"function"==typeof n&&"prototype"===t&&"value"in e&&"writable"in e&&!e.writable){var r=p(n,t);r&&r.writable&&(n[t]=e.value,e={configurable:"configurable"in e?e.configurable:r.configurable,enumerable:"enumerable"in e?e.enumerable:r.enumerable,writable:!1})}return l(n,t,e)}:l:function(n,t,e){if(s(n),t=c(t),s(e),o)try{return l(n,t,e)}catch(n){}if("get"in e||"set"in e)throw u("Accessors not supported");return"value"in e&&(n[t]=e.value),n}},function(n,t,e){var r=e(0),i=e(4),o=e(10),a=e(23),s=e(108),c=e(84),u=e(36),l=e(63).CONFIGURABLE,p=u.get,d=u.enforce,f=String(String).split("String");(n.exports=function(n,t,e,c){var u,p=!!c&&!!c.unsafe,h=!!c&&!!c.enumerable,m=!!c&&!!c.noTargetGet,v=c&&void 0!==c.name?c.name:t;i(e)&&("Symbol("===String(v).slice(0,7)&&(v="["+String(v).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!o(e,"name")||l&&e.name!==v)&&a(e,"name",v),(u=d(e)).source||(u.source=f.join("string"==typeof v?v:""))),n!==r?(p?!m&&n[t]&&(h=!0):delete n[t],h?n[t]=e:a(n,t,e)):h?n[t]=e:s(t,e)})(Function.prototype,"toString",(function(){return i(this)&&p(this).source||c(this)}))},function(n,t,e){var r=e(0),i=e(17),o=r.Object;n.exports=function(n){return o(i(n))}},function(n,t,e){var r=e(0),i=e(4),o=function(n){return i(n)?n:void 0};n.exports=function(n,t){return arguments.length<2?o(r[n]):r[n]&&r[n][t]}},function(n,t,e){var r=e(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,t,e){"use strict";var r=e(2),i=e(90);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,t,e){var r=e(59),i=e(17);n.exports=function(n){return r(i(n))}},function(n,t,e){var r=e(50);n.exports=function(n){return r(n.length)}},function(n,t,e){var r=e(1),i=r({}.toString),o=r("".slice);n.exports=function(n){return o(i(n),8,-1)}},function(n,t){n.exports=!1},function(n,t,e){var r=e(9),i=e(13),o=e(47);n.exports=r?function(n,t,e){return i.f(n,t,o(1,e))}:function(n,t,e){return n[t]=e,n}},function(n,t,e){"use strict";var r=e(171).charAt,i=e(12),o=e(36),a=e(158),s=o.set,c=o.getterFor("String Iterator");a(String,"String",(function(n){s(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,t=c(this),e=t.string,i=t.index;return i>=e.length?{value:void 0,done:!0}:(n=r(e,i),t.index+=n.length,{value:n,done:!1})}))},function(n,t,e){var r=e(14),i=e(265),o=Error.prototype;o.toString!==i&&r(o,"toString",i)},function(n,t){var e=Array.isArray;n.exports=e},function(n,t,e){var r=e(16);n.exports=r("navigator","userAgent")||""},function(n,t,e){var r=e(187),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();n.exports=o},function(n,t,e){"use strict";function r(n,t,e,r,i,o,a,s){var c,u="function"==typeof n?n.options:n;if(t&&(u.render=t,u.staticRenderFns=e,u._compiled=!0),r&&(u.functional=!0),o&&(u._scopeId="data-v-"+o),a?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},u._ssrRegister=c):i&&(c=s?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(u.functional){u._injectStyles=c;var l=u.render;u.render=function(n,t){return c.call(t),l(n,t)}}else{var p=u.beforeCreate;u.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:u}}e.d(t,"a",(function(){return r}))},function(n,t,e){"use strict";var r=e(2),i=e(54).filter;r({target:"Array",proto:!0,forced:!e(88)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){var r=e(0),i=e(172),o=e(173),a=e(139),s=e(23),c=e(5),u=c("iterator"),l=c("toStringTag"),p=a.values,d=function(n,t){if(n){if(n[u]!==p)try{s(n,u,p)}catch(t){n[u]=p}if(n[l]||s(n,l,t),i[t])for(var e in a)if(n[e]!==a[e])try{s(n,e,a[e])}catch(t){n[e]=a[e]}}};for(var f in i)d(r[f]&&r[f].prototype,f);d(o,"DOMTokenList")},function(n,t,e){var r,i=e(7),o=e(140),a=e(112),s=e(61),c=e(157),u=e(78),l=e(83),p=l("IE_PROTO"),d=function(){},f=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(f("")),n.close();var t=n.parentWindow.Object;return n=null,t},m=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,t;m="undefined"!=typeof document?document.domain&&r?h(r):((t=u("iframe")).style.display="none",c.appendChild(t),t.src=String("javascript:"),(n=t.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):h(r);for(var e=a.length;e--;)delete m.prototype[a[e]];return m()};s[p]=!0,n.exports=Object.create||function(n,t){var e;return null!==n?(d.prototype=i(n),e=new d,d.prototype=null,e[p]=n):e=m(),void 0===t?e:o.f(e,t)}},function(n,t,e){var r=e(1);n.exports=r({}.isPrototypeOf)},function(n,t,e){var r=e(60),i=Function.prototype,o=i.apply,a=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?a.bind(o):function(){return a.apply(o,arguments)})},function(n,t,e){var r=e(0),i=e(4),o=e(81),a=r.TypeError;n.exports=function(n){if(i(n))return n;throw a(o(n)+" is not a function")}},function(n,t,e){var r,i,o,a=e(235),s=e(0),c=e(1),u=e(8),l=e(23),p=e(10),d=e(107),f=e(83),h=e(61),m=s.TypeError,v=s.WeakMap;if(a||d.state){var g=d.state||(d.state=new v),b=c(g.get),y=c(g.has),x=c(g.set);r=function(n,t){if(y(g,n))throw new m("Object already initialized");return t.facade=n,x(g,n,t),t},i=function(n){return b(g,n)||{}},o=function(n){return y(g,n)}}else{var A=f("state");h[A]=!0,r=function(n,t){if(p(n,A))throw new m("Object already initialized");return t.facade=n,l(n,A,t),t},i=function(n){return p(n,A)?n[A]:{}},o=function(n){return p(n,A)}}n.exports={set:r,get:i,has:o,enforce:function(n){return o(n)?i(n):r(n,{})},getterFor:function(n){return function(t){var e;if(!u(t)||(e=i(t)).type!==n)throw m("Incompatible receiver, "+n+" required");return e}}}},function(n,t,e){"use strict";var r=e(2),i=e(177);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,t,e){var r=e(0),i=e(172),o=e(173),a=e(177),s=e(23),c=function(n){if(n&&n.forEach!==a)try{s(n,"forEach",a)}catch(t){n.forEach=a}};for(var u in i)i[u]&&c(r[u]&&r[u].prototype);c(o)},function(n,t,e){var r=e(9),i=e(11),o=e(113),a=e(47),s=e(19),c=e(79),u=e(10),l=e(154),p=Object.getOwnPropertyDescriptor;t.f=r?p:function(n,t){if(n=s(n),t=c(t),l)try{return p(n,t)}catch(n){}if(u(n,t))return a(!i(o.f,n,t),n[t])}},function(n,t,e){var r=e(2),i=e(0),o=e(34),a=e(261),s=i.WebAssembly,c=7!==Error("e",{cause:7}).cause,u=function(n,t){var e={};e[n]=a(n,t,c),r({global:!0,forced:c},e)},l=function(n,t){if(s&&s[n]){var e={};e[n]=a("WebAssembly."+n,t,c),r({target:"WebAssembly",stat:!0,forced:c},e)}};u("Error",(function(n){return function(t){return o(n,this,arguments)}})),u("EvalError",(function(n){return function(t){return o(n,this,arguments)}})),u("RangeError",(function(n){return function(t){return o(n,this,arguments)}})),u("ReferenceError",(function(n){return function(t){return o(n,this,arguments)}})),u("SyntaxError",(function(n){return function(t){return o(n,this,arguments)}})),u("TypeError",(function(n){return function(t){return o(n,this,arguments)}})),u("URIError",(function(n){return function(t){return o(n,this,arguments)}})),l("CompileError",(function(n){return function(t){return o(n,this,arguments)}})),l("LinkError",(function(n){return function(t){return o(n,this,arguments)}})),l("RuntimeError",(function(n){return function(t){return o(n,this,arguments)}}))},function(n,t,e){var r=e(285),i=e(288);n.exports=function(n,t){var e=i(n,t);return r(e)?e:void 0}},function(n,t,e){"use strict";e.d(t,"e",(function(){return r})),e.d(t,"b",(function(){return o})),e.d(t,"j",(function(){return a})),e.d(t,"g",(function(){return c})),e.d(t,"h",(function(){return u})),e.d(t,"i",(function(){return l})),e.d(t,"c",(function(){return p})),e.d(t,"f",(function(){return d})),e.d(t,"l",(function(){return f})),e.d(t,"m",(function(){return h})),e.d(t,"d",(function(){return v})),e.d(t,"k",(function(){return g})),e.d(t,"n",(function(){return b})),e.d(t,"a",(function(){return x}));e(18),e(44),e(134),e(72),e(132),e(106),e(43),e(37),e(6),e(38),e(30),e(75),e(98),e(151),e(70),e(207),e(25),e(138);var r=/#.*$/,i=/\.(md|html)$/,o=/\/$/,a=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function c(n){return a.test(n)}function u(n){return/^mailto:/.test(n)}function l(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;var t=n.match(r),e=t?t[0]:"",i=s(n);return o.test(i)?n:i+".html"+e}function d(n,t){var e=n.hash,i=function(n){var t=n.match(r);if(t)return t[0]}(t);return(!i||e===i)&&s(n.path)===s(t)}function f(n,t,e){if(c(t))return{type:"external",path:t};e&&(t=function(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?i.pop():"."!==s&&i.push(s)}""!==i[0]&&i.unshift("");return i.join("/")}(t,e));for(var r=s(t),i=0;i<n.length;i++)if(s(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:p(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(t,'"')),{}}function h(n,t,e,r){var i=e.pages,o=e.themeConfig,a=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||a.sidebar||o.sidebar))return m(n);var s=a.sidebar||o.sidebar;if(s){var c=function(n,t){if(Array.isArray(t))return{base:"/",config:t};for(var e in t)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(e)))return{base:e,config:t[e]};var r;return{}}(t,s),u=c.base,l=c.config;return"auto"===l?m(n):l?l.map((function(n){return function n(t,e,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof t)return f(e,t,r);if(Array.isArray(t))return Object.assign(f(e,t[0],r),{title:t[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var o=t.children||[];return 0===o.length&&t.path?Object.assign(f(e,t.path,r),{title:t.title}):{type:"group",path:t.path,title:t.title,sidebarDepth:t.sidebarDepth,initialOpenGroupIndex:t.initialOpenGroupIndex,children:o.map((function(t){return n(t,e,r,i+1)})),collapsable:!1!==t.collapsable}}(n,i,u)})):[]}return[]}function m(n){var t=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:t.map((function(t){return{type:"auto",title:t.title,basePath:n.path,path:n.path+"#"+t.slug,children:t.children||[]}}))}]}function v(n){var t;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?t=n:t&&(t.children||(t.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var t=n.frontmatter.date||n.lastUpdated||new Date,e=new Date(t);return"Invalid Date"==e&&t&&(e=new Date(t.replace(/-/g,"/"))),e.getTime()}function x(n,t){return y(t)-y(n)}},function(n,t,e){"use strict";var r=e(2),i=e(54).map;r({target:"Array",proto:!0,forced:!e(88)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r=e(34),i=e(11),o=e(1),a=e(104),s=e(3),c=e(7),u=e(4),l=e(52),p=e(50),d=e(12),f=e(17),h=e(121),m=e(46),v=e(266),g=e(105),b=e(5)("replace"),y=Math.max,x=Math.min,A=o([].concat),C=o([].push),S=o("".indexOf),w=o("".slice),I="$0"==="a".replace(/./,"$0"),E=!!/./[b]&&""===/./[b]("a","$0");a("replace",(function(n,t,e){var o=E?"$":"$0";return[function(n,e){var r=f(this),o=null==n?void 0:m(n,b);return o?i(o,n,r,e):i(t,d(r),n,e)},function(n,i){var a=c(this),s=d(n);if("string"==typeof i&&-1===S(i,o)&&-1===S(i,"$<")){var f=e(t,a,s,i);if(f.done)return f.value}var m=u(i);m||(i=d(i));var b=a.global;if(b){var I=a.unicode;a.lastIndex=0}for(var E=[];;){var P=g(a,s);if(null===P)break;if(C(E,P),!b)break;""===d(P[0])&&(a.lastIndex=h(s,p(a.lastIndex),I))}for(var _,O="",D=0,T=0;T<E.length;T++){for(var k=d((P=E[T])[0]),B=y(x(l(P.index),s.length),0),j=[],U=1;U<P.length;U++)C(j,void 0===(_=P[U])?_:String(_));var L=P.groups;if(m){var R=A([k],j,B,s);void 0!==L&&C(R,L);var F=d(r(i,void 0,R))}else F=v(k,s,B,j,L,i);B>=D&&(O+=w(s,D,B)+F,D=B+k.length)}return O+w(s,D)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!I||E)},function(n,t,e){"use strict";var r=e(3);n.exports=function(n,t){var e=[][n];return!!e&&r((function(){e.call(null,t||function(){return 1},1)}))}},function(n,t,e){var r=e(35);n.exports=function(n,t){var e=n[t];return null==e?void 0:r(e)}},function(n,t){n.exports=function(n,t){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:t}}},function(n,t){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,t,e){var r,i,o=e(0),a=e(27),s=o.process,c=o.Deno,u=s&&s.versions||c&&c.version,l=u&&u.v8;l&&(i=(r=l.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&a&&(!(r=a.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=a.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,t,e){var r=e(52),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,t,e){"use strict";var r=e(2),i=e(0),o=e(57),a=e(85),s=e(8),c=e(111),u=e(20),l=e(19),p=e(66),d=e(5),f=e(88),h=e(65),m=f("slice"),v=d("species"),g=i.Array,b=Math.max;r({target:"Array",proto:!0,forced:!m},{slice:function(n,t){var e,r,i,d=l(this),f=u(d),m=c(n,f),y=c(void 0===t?f:t,f);if(o(d)&&(e=d.constructor,(a(e)&&(e===g||o(e.prototype))||s(e)&&null===(e=e[v]))&&(e=void 0),e===g||void 0===e))return h(d,m,y);for(r=new(void 0===e?g:e)(b(y-m,0)),i=0;m<y;m++,i++)m in d&&p(r,i,d[m]);return r.length=i,r}})},function(n,t){var e=Math.ceil,r=Math.floor;n.exports=function(n){var t=+n;return t!=t||0===t?0:(t>0?r:e)(t)}},function(n,t,e){var r=e(1),i=e(35),o=e(60),a=r(r.bind);n.exports=function(n,t){return i(n),void 0===t?n:o?a(n,t):function(){return n.apply(t,arguments)}}},function(n,t,e){var r=e(53),i=e(1),o=e(59),a=e(15),s=e(20),c=e(143),u=i([].push),l=function(n){var t=1==n,e=2==n,i=3==n,l=4==n,p=6==n,d=7==n,f=5==n||p;return function(h,m,v,g){for(var b,y,x=a(h),A=o(x),C=r(m,v),S=s(A),w=0,I=g||c,E=t?I(h,S):e||d?I(h,0):void 0;S>w;w++)if((f||w in A)&&(y=C(b=A[w],w,x),n))if(t)E[w]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return w;case 2:u(E,b)}else switch(n){case 4:return!1;case 7:u(E,b)}return p?-1:i||l?l:E}};n.exports={forEach:l(0),map:l(1),filter:l(2),some:l(3),every:l(4),find:l(5),findIndex:l(6),filterReject:l(7)}},function(n,t,e){var r=e(156),i=e(112).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,t,e){var r=e(13).f,i=e(10),o=e(5)("toStringTag");n.exports=function(n,t,e){n&&!e&&(n=n.prototype),n&&!i(n,o)&&r(n,o,{configurable:!0,value:t})}},function(n,t,e){var r=e(21);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,t,e){var r=e(67),i=e(270),o=e(271),a=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?i(n):o(n)}},function(n,t,e){var r=e(0),i=e(1),o=e(3),a=e(21),s=r.Object,c=i("".split);n.exports=o((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?c(n,""):s(n)}:s},function(n,t,e){var r=e(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,t){n.exports={}},function(n,t){n.exports={}},function(n,t,e){var r=e(9),i=e(10),o=Function.prototype,a=r&&Object.getOwnPropertyDescriptor,s=i(o,"name"),c=s&&"something"===function(){}.name,u=s&&(!r||r&&a(o,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:u}},function(n,t,e){var r=e(1),i=e(7),o=e(236);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,t=!1,e={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(e,[]),t=e instanceof Array}catch(n){}return function(e,r){return i(e),o(r),t?n(e,r):e.__proto__=r,e}}():void 0)},function(n,t,e){var r=e(1);n.exports=r([].slice)},function(n,t,e){"use strict";var r=e(79),i=e(13),o=e(47);n.exports=function(n,t,e){var a=r(t);a in n?i.f(n,a,o(0,e)):n[a]=e}},function(n,t,e){var r=e(28).Symbol;n.exports=r},function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));e(75);var r=e(69);e(74),e(89),e(6),e(120),e(24),e(31),e(182);var i=e(96);e(40),e(25);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,t,e){"use strict";function r(n,t){(null==t||t>n.length)&&(t=n.length);for(var e=0,r=new Array(t);e<t;e++)r[e]=n[e];return r}e.d(t,"a",(function(){return r}))},function(n,t,e){"use strict";var r=e(2),i=e(0),o=e(3),a=e(57),s=e(8),c=e(15),u=e(20),l=e(66),p=e(143),d=e(88),f=e(5),h=e(49),m=f("isConcatSpreadable"),v=i.TypeError,g=h>=51||!o((function(){var n=[];return n[m]=!1,n.concat()[0]!==n})),b=d("concat"),y=function(n){if(!s(n))return!1;var t=n[m];return void 0!==t?!!t:a(n)};r({target:"Array",proto:!0,forced:!g||!b},{concat:function(n){var t,e,r,i,o,a=c(this),s=p(a,0),d=0;for(t=-1,r=arguments.length;t<r;t++)if(y(o=-1===t?a:arguments[t])){if(d+(i=u(o))>9007199254740991)throw v("Maximum allowed index exceeded");for(e=0;e<i;e++,d++)e in o&&l(s,d,o[e])}else{if(d>=9007199254740991)throw v("Maximum allowed index exceeded");l(s,d++,o)}return s.length=d,s}})},function(n,t,e){var r=e(2),i=e(0),o=e(34),a=e(4),s=e(27),c=e(65),u=e(142),l=/MSIE .\./.test(s),p=i.Function,d=function(n){return function(t,e){var r=u(arguments.length,1)>2,i=a(t)?t:p(t),s=r?c(arguments,2):void 0;return n(r?function(){o(i,this,s)}:i,e)}};r({global:!0,bind:!0,forced:l},{setTimeout:d(i.setTimeout),setInterval:d(i.setInterval)})},function(n,t,e){"use strict";e(18);var r,i,o=e(2),a=e(0),s=e(11),c=e(1),u=e(4),l=e(8),p=(r=!1,(i=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&r),d=a.Error,f=c(/./.test);o({target:"RegExp",proto:!0,forced:!p},{test:function(n){var t=this.exec;if(!u(t))return f(this,n);var e=s(t,this,n);if(null!==e&&!l(e))throw new d("RegExp exec method returned something other than an Object or null");return!!e}})},function(n,t,e){var r=e(0),i=e(117),o=e(4),a=e(21),s=e(5)("toStringTag"),c=r.Object,u="Arguments"==a(function(){return arguments}());n.exports=i?a:function(n){var t,e,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(e=function(n,t){try{return n[t]}catch(n){}}(t=c(n),s))?e:u?a(t):"Object"==(r=a(t))&&o(t.callee)?"Arguments":r}},function(n,t,e){"use strict";var r=e(2),i=e(0),o=e(16),a=e(34),s=e(11),c=e(1),u=e(22),l=e(9),p=e(109),d=e(3),f=e(10),h=e(57),m=e(4),v=e(8),g=e(33),b=e(80),y=e(7),x=e(15),A=e(19),C=e(79),S=e(12),w=e(47),I=e(32),E=e(82),P=e(55),_=e(179),O=e(115),D=e(39),T=e(13),k=e(140),B=e(113),j=e(65),U=e(14),L=e(76),R=e(83),F=e(61),M=e(77),z=e(5),N=e(180),X=e(181),H=e(56),$=e(36),W=e(54).forEach,V=R("hidden"),G=z("toPrimitive"),q=$.set,J=$.getterFor("Symbol"),Y=Object.prototype,Z=i.Symbol,K=Z&&Z.prototype,Q=i.TypeError,nn=i.QObject,tn=o("JSON","stringify"),en=D.f,rn=T.f,on=_.f,an=B.f,sn=c([].push),cn=L("symbols"),un=L("op-symbols"),ln=L("string-to-symbol-registry"),pn=L("symbol-to-string-registry"),dn=L("wks"),fn=!nn||!nn.prototype||!nn.prototype.findChild,hn=l&&d((function(){return 7!=I(rn({},"a",{get:function(){return rn(this,"a",{value:7}).a}})).a}))?function(n,t,e){var r=en(Y,t);r&&delete Y[t],rn(n,t,e),r&&n!==Y&&rn(Y,t,r)}:rn,mn=function(n,t){var e=cn[n]=I(K);return q(e,{type:"Symbol",tag:n,description:t}),l||(e.description=t),e},vn=function(n,t,e){n===Y&&vn(un,t,e),y(n);var r=C(t);return y(e),f(cn,r)?(e.enumerable?(f(n,V)&&n[V][r]&&(n[V][r]=!1),e=I(e,{enumerable:w(0,!1)})):(f(n,V)||rn(n,V,w(1,{})),n[V][r]=!0),hn(n,r,e)):rn(n,r,e)},gn=function(n,t){y(n);var e=A(t),r=E(e).concat(An(e));return W(r,(function(t){l&&!s(bn,e,t)||vn(n,t,e[t])})),n},bn=function(n){var t=C(n),e=s(an,this,t);return!(this===Y&&f(cn,t)&&!f(un,t))&&(!(e||!f(this,t)||!f(cn,t)||f(this,V)&&this[V][t])||e)},yn=function(n,t){var e=A(n),r=C(t);if(e!==Y||!f(cn,r)||f(un,r)){var i=en(e,r);return!i||!f(cn,r)||f(e,V)&&e[V][r]||(i.enumerable=!0),i}},xn=function(n){var t=on(A(n)),e=[];return W(t,(function(n){f(cn,n)||f(F,n)||sn(e,n)})),e},An=function(n){var t=n===Y,e=on(t?un:A(n)),r=[];return W(e,(function(n){!f(cn,n)||t&&!f(Y,n)||sn(r,cn[n])})),r};(p||(U(K=(Z=function(){if(g(K,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?S(arguments[0]):void 0,t=M(n),e=function(n){this===Y&&s(e,un,n),f(this,V)&&f(this[V],t)&&(this[V][t]=!1),hn(this,t,w(1,n))};return l&&fn&&hn(Y,t,{configurable:!0,set:e}),mn(t,n)}).prototype,"toString",(function(){return J(this).tag})),U(Z,"withoutSetter",(function(n){return mn(M(n),n)})),B.f=bn,T.f=vn,k.f=gn,D.f=yn,P.f=_.f=xn,O.f=An,N.f=function(n){return mn(z(n),n)},l&&(rn(K,"description",{configurable:!0,get:function(){return J(this).description}}),u||U(Y,"propertyIsEnumerable",bn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!p,sham:!p},{Symbol:Z}),W(E(dn),(function(n){X(n)})),r({target:"Symbol",stat:!0,forced:!p},{for:function(n){var t=S(n);if(f(ln,t))return ln[t];var e=Z(t);return ln[t]=e,pn[e]=t,e},keyFor:function(n){if(!b(n))throw Q(n+" is not a symbol");if(f(pn,n))return pn[n]},useSetter:function(){fn=!0},useSimple:function(){fn=!1}}),r({target:"Object",stat:!0,forced:!p,sham:!l},{create:function(n,t){return void 0===t?I(n):gn(I(n),t)},defineProperty:vn,defineProperties:gn,getOwnPropertyDescriptor:yn}),r({target:"Object",stat:!0,forced:!p},{getOwnPropertyNames:xn,getOwnPropertySymbols:An}),r({target:"Object",stat:!0,forced:d((function(){O.f(1)}))},{getOwnPropertySymbols:function(n){return O.f(x(n))}}),tn)&&r({target:"JSON",stat:!0,forced:!p||d((function(){var n=Z();return"[null]"!=tn([n])||"{}"!=tn({a:n})||"{}"!=tn(Object(n))}))},{stringify:function(n,t,e){var r=j(arguments),i=t;if((v(t)||void 0!==n)&&!b(n))return h(t)||(t=function(n,t){if(m(i)&&(t=s(i,this,n,t)),!b(t))return t}),r[1]=t,a(tn,null,r)}});if(!K[G]){var Cn=K.valueOf;U(K,G,(function(n){return s(Cn,this)}))}H(Z,"Symbol"),F[V]=!0},function(n,t,e){e(2)({target:"Array",stat:!0},{isArray:e(57)})},function(n,t,e){var r=e(22),i=e(107);(n.exports=function(n,t){return i[n]||(i[n]=void 0!==t?t:{})})("versions",[]).push({version:"3.21.1",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,t,e){var r=e(1),i=0,o=Math.random(),a=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++i+o,36)}},function(n,t,e){var r=e(0),i=e(8),o=r.document,a=i(o)&&i(o.createElement);n.exports=function(n){return a?o.createElement(n):{}}},function(n,t,e){var r=e(155),i=e(80);n.exports=function(n){var t=r(n,"string");return i(t)?t:t+""}},function(n,t,e){var r=e(0),i=e(16),o=e(4),a=e(33),s=e(152),c=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var t=i("Symbol");return o(t)&&a(t.prototype,c(n))}},function(n,t,e){var r=e(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,t,e){var r=e(156),i=e(112);n.exports=Object.keys||function(n){return r(n,i)}},function(n,t,e){var r=e(76),i=e(77),o=r("keys");n.exports=function(n){return o[n]||(o[n]=i(n))}},function(n,t,e){var r=e(1),i=e(4),o=e(107),a=r(Function.toString);i(o.inspectSource)||(o.inspectSource=function(n){return a(n)}),n.exports=o.inspectSource},function(n,t,e){var r=e(1),i=e(3),o=e(4),a=e(73),s=e(16),c=e(84),u=function(){},l=[],p=s("Reflect","construct"),d=/^\s*(?:class|function)\b/,f=r(d.exec),h=!d.exec(u),m=function(n){if(!o(n))return!1;try{return p(u,l,n),!0}catch(n){return!1}},v=function(n){if(!o(n))return!1;switch(a(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!f(d,c(n))}catch(n){return!0}};v.sham=!0,n.exports=!p||i((function(){var n;return m(m.call)||!m(Object)||!m((function(){n=!0}))||n}))?v:m},function(n,t,e){var r=e(21),i=e(0);n.exports="process"==r(i.process)},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(6);function r(n,t,e,r,i,o,a){try{var s=n[o](a),c=s.value}catch(n){return void e(n)}s.done?t(c):Promise.resolve(c).then(r,i)}function i(n){return function(){var t=this,e=arguments;return new Promise((function(i,o){var a=n.apply(t,e);function s(n){r(a,i,o,s,c,"next",n)}function c(n){r(a,i,o,s,c,"throw",n)}s(void 0)}))}}},function(n,t,e){var r=e(3),i=e(5),o=e(49),a=i("species");n.exports=function(n){return o>=51||!r((function(){var t=[];return(t.constructor={})[a]=function(){return{foo:1}},1!==t[n](Boolean).foo}))}},function(n,t,e){"use strict";var r=e(2),i=e(9),o=e(0),a=e(1),s=e(10),c=e(4),u=e(33),l=e(12),p=e(13).f,d=e(114),f=o.Symbol,h=f&&f.prototype;if(i&&c(f)&&(!("description"in h)||void 0!==f().description)){var m={},v=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:l(arguments[0]),t=u(h,this)?new f(n):void 0===n?f():f(n);return""===n&&(m[t]=!0),t};d(v,f),v.prototype=h,h.constructor=v;var g="Symbol(test)"==String(f("test")),b=a(h.toString),y=a(h.valueOf),x=/^Symbol\((.*)\)[^)]+$/,A=a("".replace),C=a("".slice);p(h,"description",{configurable:!0,get:function(){var n=y(this),t=b(n);if(s(m,n))return"";var e=g?C(t,7,-1):A(t,x,"$1");return""===e?void 0:e}}),r({global:!0,forced:!0},{Symbol:v})}},function(n,t,e){"use strict";var r,i,o=e(11),a=e(1),s=e(12),c=e(145),u=e(103),l=e(76),p=e(32),d=e(36).get,f=e(220),h=e(226),m=l("native-string-replace",String.prototype.replace),v=RegExp.prototype.exec,g=v,b=a("".charAt),y=a("".indexOf),x=a("".replace),A=a("".slice),C=(i=/b*/g,o(v,r=/a/,"a"),o(v,i,"a"),0!==r.lastIndex||0!==i.lastIndex),S=u.BROKEN_CARET,w=void 0!==/()??/.exec("")[1];(C||w||S||f||h)&&(g=function(n){var t,e,r,i,a,u,l,f=this,h=d(f),I=s(n),E=h.raw;if(E)return E.lastIndex=f.lastIndex,t=o(g,E,I),f.lastIndex=E.lastIndex,t;var P=h.groups,_=S&&f.sticky,O=o(c,f),D=f.source,T=0,k=I;if(_&&(O=x(O,"y",""),-1===y(O,"g")&&(O+="g"),k=A(I,f.lastIndex),f.lastIndex>0&&(!f.multiline||f.multiline&&"\n"!==b(I,f.lastIndex-1))&&(D="(?: "+D+")",k=" "+k,T++),e=new RegExp("^(?:"+D+")",O)),w&&(e=new RegExp("^"+D+"$(?!\\s)",O)),C&&(r=f.lastIndex),i=o(v,_?e:f,k),_?i?(i.input=A(i.input,T),i[0]=A(i[0],T),i.index=f.lastIndex,f.lastIndex+=i[0].length):f.lastIndex=0:C&&i&&(f.lastIndex=f.global?i.index+i[0].length:r),w&&i&&i.length>1&&o(m,i[0],e,(function(){for(a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(i[a]=void 0)})),i&&P)for(i.groups=u=p(null),a=0;a<P.length;a++)u[(l=P[a])[0]]=i[l[1]];return i}),n.exports=g},function(n,t,e){var r=e(275),i=e(276),o=e(277),a=e(278),s=e(279);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(189);n.exports=function(n,t){for(var e=n.length;e--;)if(r(n[e][0],t))return e;return-1}},function(n,t,e){var r=e(41)(Object,"create");n.exports=r},function(n,t,e){var r=e(297);n.exports=function(n,t){var e=n.__data__;return r(t)?e["string"==typeof t?"string":"hash"]:e.map}},function(n,t,e){var r=e(129);n.exports=function(n){if("string"==typeof n||r(n))return n;var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(51),e(6),e(102),e(182),e(24),e(18),e(72);var r=e(69);function i(n,t){if(n){if("string"==typeof n)return Object(r.a)(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(n):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?Object(r.a)(n,t):void 0}}},function(n,t,e){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,t,e={version:"0.2.0"},r=e.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,t,e){return n<t?t:n>e?e:n}function o(n){return 100*(-1+n)}e.configure=function(n){var t,e;for(t in n)void 0!==(e=n[t])&&n.hasOwnProperty(t)&&(r[t]=e);return this},e.status=null,e.set=function(n){var t=e.isStarted();n=i(n,r.minimum,1),e.status=1===n?null:n;var c=e.render(!t),u=c.querySelector(r.barSelector),l=r.speed,p=r.easing;return c.offsetWidth,a((function(t){""===r.positionUsing&&(r.positionUsing=e.getPositioningCSS()),s(u,function(n,t,e){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+t+"ms "+e,i}(n,l,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+l+"ms linear",opacity:0}),setTimeout((function(){e.remove(),t()}),l)}),l)):setTimeout(t,l)})),this},e.isStarted=function(){return"number"==typeof e.status},e.start=function(){e.status||e.set(0);var n=function(){setTimeout((function(){e.status&&(e.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},e.done=function(n){return n||e.status?e.inc(.3+.5*Math.random()).set(1):this},e.inc=function(n){var t=e.status;return t?("number"!=typeof n&&(n=(1-t)*i(Math.random()*t,.1,.95)),t=i(t+n,0,.994),e.set(t)):e.start()},e.trickle=function(){return e.inc(Math.random()*r.trickleRate)},n=0,t=0,e.promise=function(r){return r&&"resolved"!==r.state()?(0===t&&e.start(),n++,t++,r.always((function(){0==--t?(n=0,e.done()):e.set((n-t)/n)})),this):this},e.render=function(n){if(e.isRendered())return document.getElementById("nprogress");u(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=r.template;var i,a=t.querySelector(r.barSelector),c=n?"-100":o(e.status||0),l=document.querySelector(r.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(i=t.querySelector(r.spinnerSelector))&&d(i),l!=document.body&&u(l,"nprogress-custom-parent"),l.appendChild(t),t},e.remove=function(){l(document.documentElement,"nprogress-busy"),l(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},e.isRendered=function(){return!!document.getElementById("nprogress")},e.getPositioningCSS=function(){var n=document.body.style,t="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return t+"Perspective"in n?"translate3d":t+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function t(){var e=n.shift();e&&e(t)}return function(e){n.push(e),1==n.length&&t()}}(),s=function(){var n=["Webkit","O","Moz","ms"],t={};function e(e){return e=e.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,t){return t.toUpperCase()})),t[e]||(t[e]=function(t){var e=document.body.style;if(t in e)return t;for(var r,i=n.length,o=t.charAt(0).toUpperCase()+t.slice(1);i--;)if((r=n[i]+o)in e)return r;return t}(e))}function r(n,t,r){t=e(t),n.style[t]=r}return function(n,t){var e,i,o=arguments;if(2==o.length)for(e in t)void 0!==(i=t[e])&&t.hasOwnProperty(e)&&r(n,e,i);else r(n,o[1],o[2])}}();function c(n,t){return("string"==typeof n?n:p(n)).indexOf(" "+t+" ")>=0}function u(n,t){var e=p(n),r=e+t;c(e,t)||(n.className=r.substring(1))}function l(n,t){var e,r=p(n);c(n,t)&&(e=r.replace(" "+t+" "," "),n.className=e.substring(1,e.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return e})?r.call(t,e,t,n):r)||(n.exports=i)},function(n,t,e){"use strict";var r=e(2),i=e(1),o=e(110).indexOf,a=e(45),s=i([].indexOf),c=!!s&&1/s([1],1,-0)<0,u=a("indexOf");r({target:"Array",proto:!0,forced:c||!u},{indexOf:function(n){var t=arguments.length>1?arguments[1]:void 0;return c?s(this,n,t)||0:o(this,n,t)}})},function(n,t,e){var r=e(2),i=e(15),o=e(82);r({target:"Object",stat:!0,forced:e(3)((function(){o(1)}))},{keys:function(n){return o(i(n))}})},function(n,t,e){var r=e(3),i=e(4),o=/#|\.prototype\./,a=function(n,t){var e=c[s(n)];return e==l||e!=u&&(i(t)?r(t):!!t)},s=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},c=a.data={},u=a.NATIVE="N",l=a.POLYFILL="P";n.exports=a},function(n,t,e){var r=e(73),i=e(46),o=e(62),a=e(5)("iterator");n.exports=function(n){if(null!=n)return i(n,a)||i(n,"@@iterator")||o[r(n)]}},function(n,t,e){var r=e(9),i=e(63).EXISTS,o=e(1),a=e(13).f,s=Function.prototype,c=o(s.toString),u=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,l=o(u.exec);r&&!i&&a(s,"name",{configurable:!0,get:function(){try{return l(u,c(this))[1]}catch(n){return""}}})},function(n,t,e){var r=e(3),i=e(0).RegExp,o=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),a=o||r((function(){return!i("a","y").sticky})),s=o||r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:a,UNSUPPORTED_Y:o}},function(n,t,e){"use strict";e(18);var r=e(1),i=e(14),o=e(90),a=e(3),s=e(5),c=e(23),u=s("species"),l=RegExp.prototype;n.exports=function(n,t,e,p){var d=s(n),f=!a((function(){var t={};return t[d]=function(){return 7},7!=""[n](t)})),h=f&&!a((function(){var t=!1,e=/a/;return"split"===n&&((e={}).constructor={},e.constructor[u]=function(){return e},e.flags="",e[d]=/./[d]),e.exec=function(){return t=!0,null},e[d](""),!t}));if(!f||!h||e){var m=r(/./[d]),v=t(d,""[n],(function(n,t,e,i,a){var s=r(n),c=t.exec;return c===o||c===l.exec?f&&!a?{done:!0,value:m(t,e,i)}:{done:!0,value:s(e,t,i)}:{done:!1}}));i(String.prototype,n,v[0]),i(l,d,v[1])}p&&c(l[d],"sham",!0)}},function(n,t,e){var r=e(0),i=e(11),o=e(7),a=e(4),s=e(21),c=e(90),u=r.TypeError;n.exports=function(n,t){var e=n.exec;if(a(e)){var r=i(e,n,t);return null!==r&&o(r),r}if("RegExp"===s(n))return i(c,n,t);throw u("RegExp#exec called on incompatible receiver")}},function(n,t,e){"use strict";var r=e(2),i=e(1),o=e(59),a=e(19),s=e(45),c=i([].join),u=o!=Object,l=s("join",",");r({target:"Array",proto:!0,forced:u||!l},{join:function(n){return c(a(this),void 0===n?",":n)}})},function(n,t,e){var r=e(0),i=e(108),o=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=o},function(n,t,e){var r=e(0),i=Object.defineProperty;n.exports=function(n,t){try{i(r,n,{value:t,configurable:!0,writable:!0})}catch(e){r[n]=t}return t}},function(n,t,e){var r=e(49),i=e(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,t,e){var r=e(19),i=e(111),o=e(20),a=function(n){return function(t,e,a){var s,c=r(t),u=o(c),l=i(a,u);if(n&&e!=e){for(;u>l;)if((s=c[l++])!=s)return!0}else for(;u>l;l++)if((n||l in c)&&c[l]===e)return n||l||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,t,e){var r=e(52),i=Math.max,o=Math.min;n.exports=function(n,t){var e=r(n);return e<0?i(e+t,0):o(e,t)}},function(n,t){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,t,e){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!r.call({1:2},1);t.f=o?function(n){var t=i(this,n);return!!t&&t.enumerable}:r},function(n,t,e){var r=e(10),i=e(159),o=e(39),a=e(13);n.exports=function(n,t,e){for(var s=i(t),c=a.f,u=o.f,l=0;l<s.length;l++){var p=s[l];r(n,p)||e&&r(e,p)||c(n,p,u(t,p))}}},function(n,t){t.f=Object.getOwnPropertySymbols},function(n,t,e){var r=e(0),i=e(10),o=e(4),a=e(15),s=e(83),c=e(161),u=s("IE_PROTO"),l=r.Object,p=l.prototype;n.exports=c?l.getPrototypeOf:function(n){var t=a(n);if(i(t,u))return t[u];var e=t.constructor;return o(e)&&t instanceof e?e.prototype:t instanceof l?p:null}},function(n,t,e){var r={};r[e(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,t,e){var r=e(7),i=e(166),o=e(5)("species");n.exports=function(n,t){var e,a=r(n).constructor;return void 0===a||null==(e=r(a)[o])?t:i(e)}},function(n,t,e){var r=e(0),i=e(111),o=e(20),a=e(66),s=r.Array,c=Math.max;n.exports=function(n,t,e){for(var r=o(n),u=i(t,r),l=i(void 0===e?r:e,r),p=s(c(l-u,0)),d=0;u<l;u++,d++)a(p,d,n[u]);return p.length=d,p}},function(n,t,e){e(181)("iterator")},function(n,t,e){"use strict";var r=e(171).charAt;n.exports=function(n,t,e){return t+(e?r(n,t).length:1)}},function(n,t,e){var r=e(269),i=e(48),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return i(n)&&a.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,t,e){var r=e(41)(e(28),"Map");n.exports=r},function(n,t){n.exports=function(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}},function(n,t,e){var r=e(289),i=e(296),o=e(298),a=e(299),s=e(300);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n){e[++t]=n})),e}},function(n,t){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,t,e){var r=e(26),i=e(129),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,t){if(r(n))return!1;var e=typeof n;return!("number"!=e&&"symbol"!=e&&"boolean"!=e&&null!=n&&!i(n))||(a.test(n)||!o.test(n)||null!=t&&n in Object(t))}},function(n,t,e){var r=e(58),i=e(48);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,t){n.exports=function(n){return n}},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(75);e(74),e(89),e(6),e(120),e(24),e(31);var r=e(96);e(40),e(25);function i(n,t){return function(n){if(Array.isArray(n))return n}(n)||function(n,t){var e=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=e){var r,i,o=[],a=!0,s=!1;try{for(e=e.call(n);!(a=(r=e.next()).done)&&(o.push(r.value),!t||o.length!==t);a=!0);}catch(n){s=!0,i=n}finally{try{a||null==e.return||e.return()}finally{if(s)throw i}}return o}}(n,t)||Object(r.a)(n,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,t,e){"use strict";var r=e(34),i=e(11),o=e(1),a=e(104),s=e(144),c=e(7),u=e(17),l=e(118),p=e(121),d=e(50),f=e(12),h=e(46),m=e(119),v=e(105),g=e(90),b=e(103),y=e(3),x=b.UNSUPPORTED_Y,A=Math.min,C=[].push,S=o(/./.exec),w=o(C),I=o("".slice);a("split",(function(n,t,e){var o;return o="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,e){var o=f(u(this)),a=void 0===e?4294967295:e>>>0;if(0===a)return[];if(void 0===n)return[o];if(!s(n))return i(t,o,n,a);for(var c,l,p,d=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),v=0,b=new RegExp(n.source,h+"g");(c=i(g,b,o))&&!((l=b.lastIndex)>v&&(w(d,I(o,v,c.index)),c.length>1&&c.index<o.length&&r(C,d,m(c,1)),p=c[0].length,v=l,d.length>=a));)b.lastIndex===c.index&&b.lastIndex++;return v===o.length?!p&&S(b,"")||w(d,""):w(d,I(o,v)),d.length>a?m(d,0,a):d}:"0".split(void 0,0).length?function(n,e){return void 0===n&&0===e?[]:i(t,this,n,e)}:t,[function(t,e){var r=u(this),a=null==t?void 0:h(t,n);return a?i(a,t,r,e):i(o,f(r),t,e)},function(n,r){var i=c(this),a=f(n),s=e(o,i,a,r,o!==t);if(s.done)return s.value;var u=l(i,RegExp),h=i.unicode,m=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),g=new u(x?"^(?:"+i.source+")":i,m),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===a.length)return null===v(g,a)?[a]:[];for(var y=0,C=0,S=[];C<a.length;){g.lastIndex=x?0:C;var E,P=v(g,x?I(a,C):a);if(null===P||(E=A(d(g.lastIndex+(x?C:0)),a.length))===y)C=p(a,C,h);else{if(w(S,I(a,y,C)),S.length===b)return S;for(var _=1;_<=P.length-1;_++)if(w(S,P[_]),S.length===b)return S;C=y=E}}return w(S,I(a,y)),S}]}),!!y((function(){var n=/(?:)/,t=n.exec;n.exec=function(){return t.apply(this,arguments)};var e="ab".split(n);return 2!==e.length||"a"!==e[0]||"b"!==e[1]})),x)},function(n,t,e){"use strict";var r=e(2),i=e(54).some;r({target:"Array",proto:!0,forced:!e(45)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r=e(11),i=e(104),o=e(7),a=e(50),s=e(12),c=e(17),u=e(46),l=e(121),p=e(105);i("match",(function(n,t,e){return[function(t){var e=c(this),i=null==t?void 0:u(t,n);return i?r(i,t,e):new RegExp(t)[n](s(e))},function(n){var r=o(this),i=s(n),c=e(t,r,i);if(c.done)return c.value;if(!r.global)return p(r,i);var u=r.unicode;r.lastIndex=0;for(var d,f=[],h=0;null!==(d=p(r,i));){var m=s(d[0]);f[h]=m,""===m&&(r.lastIndex=l(i,a(r.lastIndex),u)),h++}return 0===h?null:f}]}))},function(n,t,e){var r=e(5),i=e(32),o=e(13),a=r("unscopables"),s=Array.prototype;null==s[a]&&o.f(s,a,{configurable:!0,value:i(null)}),n.exports=function(n){s[a][n]=!0}},function(n,t,e){var r=function(n){"use strict";var t=Object.prototype,e=t.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",a=r.toStringTag||"@@toStringTag";function s(n,t,e){return Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}),n[t]}try{s({},"")}catch(n){s=function(n,t,e){return n[t]=e}}function c(n,t,e,r){var i=t&&t.prototype instanceof p?t:p,o=Object.create(i.prototype),a=new S(r||[]);return o._invoke=function(n,t,e){var r="suspendedStart";return function(i,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw o;return I()}for(e.method=i,e.arg=o;;){var a=e.delegate;if(a){var s=x(a,e);if(s){if(s===l)continue;return s}}if("next"===e.method)e.sent=e._sent=e.arg;else if("throw"===e.method){if("suspendedStart"===r)throw r="completed",e.arg;e.dispatchException(e.arg)}else"return"===e.method&&e.abrupt("return",e.arg);r="executing";var c=u(n,t,e);if("normal"===c.type){if(r=e.done?"completed":"suspendedYield",c.arg===l)continue;return{value:c.arg,done:e.done}}"throw"===c.type&&(r="completed",e.method="throw",e.arg=c.arg)}}}(n,e,a),o}function u(n,t,e){try{return{type:"normal",arg:n.call(t,e)}}catch(n){return{type:"throw",arg:n}}}n.wrap=c;var l={};function p(){}function d(){}function f(){}var h={};s(h,i,(function(){return this}));var m=Object.getPrototypeOf,v=m&&m(m(w([])));v&&v!==t&&e.call(v,i)&&(h=v);var g=f.prototype=p.prototype=Object.create(h);function b(n){["next","throw","return"].forEach((function(t){s(n,t,(function(n){return this._invoke(t,n)}))}))}function y(n,t){var r;this._invoke=function(i,o){function a(){return new t((function(r,a){!function r(i,o,a,s){var c=u(n[i],n,o);if("throw"!==c.type){var l=c.arg,p=l.value;return p&&"object"==typeof p&&e.call(p,"__await")?t.resolve(p.__await).then((function(n){r("next",n,a,s)}),(function(n){r("throw",n,a,s)})):t.resolve(p).then((function(n){l.value=n,a(l)}),(function(n){return r("throw",n,a,s)}))}s(c.arg)}(i,o,r,a)}))}return r=r?r.then(a,a):a()}}function x(n,t){var e=n.iterator[t.method];if(void 0===e){if(t.delegate=null,"throw"===t.method){if(n.iterator.return&&(t.method="return",t.arg=void 0,x(n,t),"throw"===t.method))return l;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return l}var r=u(e,n.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,l;var i=r.arg;return i?i.done?(t[n.resultName]=i.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,l):i:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,l)}function A(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function C(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function S(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(A,this),this.reset(!0)}function w(n){if(n){var t=n[i];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function t(){for(;++r<n.length;)if(e.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return o.next=o}}return{next:I}}function I(){return{value:void 0,done:!0}}return d.prototype=f,s(g,"constructor",f),s(f,"constructor",d),d.displayName=s(f,a,"GeneratorFunction"),n.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===d||"GeneratorFunction"===(t.displayName||t.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,f):(n.__proto__=f,s(n,a,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},b(y.prototype),s(y.prototype,o,(function(){return this})),n.AsyncIterator=y,n.async=function(t,e,r,i,o){void 0===o&&(o=Promise);var a=new y(c(t,e,r,i),o);return n.isGeneratorFunction(e)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},b(g),s(g,a,"Generator"),s(g,i,(function(){return this})),s(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var t=[];for(var e in n)t.push(e);return t.reverse(),function e(){for(;t.length;){var r=t.pop();if(r in n)return e.value=r,e.done=!1,e}return e.done=!0,e}},n.values=w,S.prototype={constructor:S,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(C),!n)for(var t in this)"t"===t.charAt(0)&&e.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function r(e,r){return a.type="throw",a.arg=n,t.next=e,r&&(t.method="next",t.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],a=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var s=e.call(o,"catchLoc"),c=e.call(o,"finallyLoc");if(s&&c){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(n,t){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&e.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=n,a.arg=t,o?(this.method="next",this.next=o.finallyLoc,l):this.complete(a)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),l},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.finallyLoc===n)return this.complete(e.completion,e.afterLoc),C(e),l}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.tryLoc===n){var r=e.completion;if("throw"===r.type){var i=r.arg;C(e)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,e){return this.delegate={iterator:w(n),resultName:t,nextLoc:e},"next"===this.method&&(this.arg=void 0),l}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,t,e){var r=e(2),i=e(9),o=e(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==o,sham:!i},{defineProperty:o})},function(n,t,e){"use strict";var r=e(1),i=e(63).PROPER,o=e(14),a=e(7),s=e(33),c=e(12),u=e(3),l=e(145),p=RegExp.prototype,d=p.toString,f=r(l),h=u((function(){return"/a/b"!=d.call({source:"a",flags:"b"})})),m=i&&"toString"!=d.name;(h||m)&&o(RegExp.prototype,"toString",(function(){var n=a(this),t=c(n.source),e=n.flags;return"/"+t+"/"+c(void 0===e&&s(p,n)&&!("flags"in p)?f(n):e)}),{unsafe:!0})},function(n,t,e){"use strict";var r=e(19),i=e(135),o=e(62),a=e(36),s=e(13).f,c=e(158),u=e(22),l=e(9),p=a.set,d=a.getterFor("Array Iterator");n.exports=c(Array,"Array",(function(n,t){p(this,{type:"Array Iterator",target:r(n),index:0,kind:t})}),(function(){var n=d(this),t=n.target,e=n.kind,r=n.index++;return!t||r>=t.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==e?{value:r,done:!1}:"values"==e?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");var f=o.Arguments=o.Array;if(i("keys"),i("values"),i("entries"),!u&&l&&"values"!==f.name)try{s(f,"name",{value:"values"})}catch(n){}},function(n,t,e){var r=e(9),i=e(153),o=e(13),a=e(7),s=e(19),c=e(82);t.f=r&&!i?Object.defineProperties:function(n,t){a(n);for(var e,r=s(t),i=c(t),u=i.length,l=0;u>l;)o.f(n,e=i[l++],r[e]);return n}},function(n,t,e){var r=e(0),i=e(11),o=e(35),a=e(7),s=e(81),c=e(101),u=r.TypeError;n.exports=function(n,t){var e=arguments.length<2?c(n):t;if(o(e))return a(i(e,n));throw u(s(n)+" is not iterable")}},function(n,t,e){var r=e(0).TypeError;n.exports=function(n,t){if(n<t)throw r("Not enough arguments");return n}},function(n,t,e){var r=e(250);n.exports=function(n,t){return new(r(n))(0===t?0:t)}},function(n,t,e){var r=e(8),i=e(21),o=e(5)("match");n.exports=function(n){var t;return r(n)&&(void 0!==(t=n[o])?!!t:"RegExp"==i(n))}},function(n,t,e){"use strict";var r=e(7);n.exports=function(){var n=r(this),t="";return n.global&&(t+="g"),n.ignoreCase&&(t+="i"),n.multiline&&(t+="m"),n.dotAll&&(t+="s"),n.unicode&&(t+="u"),n.sticky&&(t+="y"),t}},function(n,t,e){var r=e(4),i=e(8),o=e(64);n.exports=function(n,t,e){var a,s;return o&&r(a=t.constructor)&&a!==e&&i(s=a.prototype)&&s!==e.prototype&&o(n,s),n}},function(n,t){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,t){var e=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,u=s||c||Function("return this")(),l=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return u.Date.now()};function h(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==l.call(n)}(n))return NaN;if(h(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=h(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(e,"");var s=i.test(n);return s||o.test(n)?a(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,t,e){var r,i,o,a,s,c,u=0,l=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(t){var e=r,o=i;return r=i=void 0,u=t,a=n.apply(o,e)}function y(n){return u=n,s=setTimeout(A,t),l?b(n):a}function x(n){var e=n-c;return void 0===c||e>=t||e<0||v&&n-u>=o}function A(){var n=f();if(x(n))return C(n);s=setTimeout(A,function(n){var e=t-(n-c);return v?d(e,o-(n-u)):e}(n))}function C(n){return s=void 0,g&&r?b(n):(r=i=void 0,a)}function S(){var n=f(),e=x(n);if(r=arguments,i=this,c=n,e){if(void 0===s)return y(c);if(v)return s=setTimeout(A,t),b(c)}return void 0===s&&(s=setTimeout(A,t)),a}return t=m(t)||0,h(e)&&(l=!!e.leading,o=(v="maxWait"in e)?p(m(e.maxWait)||0,t):o,g="trailing"in e?!!e.trailing:g),S.cancel=function(){void 0!==s&&clearTimeout(s),u=0,r=c=i=s=void 0},S.flush=function(){return void 0===s?a:C(f())},S}},function(n,t,e){var r=e(1),i=e(17),o=e(12),a=e(150),s=r("".replace),c="["+a+"]",u=RegExp("^"+c+c+"*"),l=RegExp(c+c+"*$"),p=function(n){return function(t){var e=o(i(t));return 1&n&&(e=s(e,u,"")),2&n&&(e=s(e,l,"")),e}};n.exports={start:p(1),end:p(2),trim:p(3)}},function(n,t){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,t,e){var r=e(1),i=e(14),o=Date.prototype,a=r(o.toString),s=r(o.getTime);"Invalid Date"!=String(new Date(NaN))&&i(o,"toString",(function(){var n=s(this);return n==n?a(this):"Invalid Date"}))},function(n,t,e){var r=e(109);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,t,e){var r=e(9),i=e(3);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,t,e){var r=e(9),i=e(3),o=e(78);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,t,e){var r=e(0),i=e(11),o=e(8),a=e(80),s=e(46),c=e(234),u=e(5),l=r.TypeError,p=u("toPrimitive");n.exports=function(n,t){if(!o(n)||a(n))return n;var e,r=s(n,p);if(r){if(void 0===t&&(t="default"),e=i(r,n,t),!o(e)||a(e))return e;throw l("Can't convert object to primitive value")}return void 0===t&&(t="number"),c(n,t)}},function(n,t,e){var r=e(1),i=e(10),o=e(19),a=e(110).indexOf,s=e(61),c=r([].push);n.exports=function(n,t){var e,r=o(n),u=0,l=[];for(e in r)!i(s,e)&&i(r,e)&&c(l,e);for(;t.length>u;)i(r,e=t[u++])&&(~a(l,e)||c(l,e));return l}},function(n,t,e){var r=e(16);n.exports=r("document","documentElement")},function(n,t,e){"use strict";var r=e(2),i=e(11),o=e(22),a=e(63),s=e(4),c=e(221),u=e(116),l=e(64),p=e(56),d=e(23),f=e(14),h=e(5),m=e(62),v=e(160),g=a.PROPER,b=a.CONFIGURABLE,y=v.IteratorPrototype,x=v.BUGGY_SAFARI_ITERATORS,A=h("iterator"),C=function(){return this};n.exports=function(n,t,e,a,h,v,S){c(e,t,a);var w,I,E,P=function(n){if(n===h&&k)return k;if(!x&&n in D)return D[n];switch(n){case"keys":case"values":case"entries":return function(){return new e(this,n)}}return function(){return new e(this)}},_=t+" Iterator",O=!1,D=n.prototype,T=D[A]||D["@@iterator"]||h&&D[h],k=!x&&T||P(h),B="Array"==t&&D.entries||T;if(B&&(w=u(B.call(new n)))!==Object.prototype&&w.next&&(o||u(w)===y||(l?l(w,y):s(w[A])||f(w,A,C)),p(w,_,!0,!0),o&&(m[_]=C)),g&&"values"==h&&T&&"values"!==T.name&&(!o&&b?d(D,"name","values"):(O=!0,k=function(){return i(T,this)})),h)if(I={values:P("values"),keys:v?k:P("keys"),entries:P("entries")},S)for(E in I)(x||O||!(E in D))&&f(D,E,I[E]);else r({target:t,proto:!0,forced:x||O},I);return o&&!S||D[A]===k||f(D,A,k,{name:h}),m[t]=k,I}},function(n,t,e){var r=e(16),i=e(1),o=e(55),a=e(115),s=e(7),c=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var t=o.f(s(n)),e=a.f;return e?c(t,e(n)):t}},function(n,t,e){"use strict";var r,i,o,a=e(3),s=e(4),c=e(32),u=e(116),l=e(14),p=e(5),d=e(22),f=p("iterator"),h=!1;[].keys&&("next"in(o=[].keys())?(i=u(u(o)))!==Object.prototype&&(r=i):h=!0),null==r||a((function(){var n={};return r[f].call(n)!==n}))?r={}:d&&(r=c(r)),s(r[f])||l(r,f,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,t,e){var r=e(3);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,t,e){var r=e(0);n.exports=r.Promise},function(n,t,e){var r=e(5),i=e(62),o=r("iterator"),a=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||a[o]===n)}},function(n,t,e){var r=e(11),i=e(7),o=e(46);n.exports=function(n,t,e){var a,s;i(n);try{if(!(a=o(n,"return"))){if("throw"===t)throw e;return e}a=r(a,n)}catch(n){s=!0,a=n}if("throw"===t)throw e;if(s)throw a;return i(a),e}},function(n,t,e){var r=e(5)("iterator"),i=!1;try{var o=0,a={next:function(){return{done:!!o++}},return:function(){i=!0}};a[r]=function(){return this},Array.from(a,(function(){throw 2}))}catch(n){}n.exports=function(n,t){if(!t&&!i)return!1;var e=!1;try{var o={};o[r]=function(){return{next:function(){return{done:e=!0}}}},n(o)}catch(n){}return e}},function(n,t,e){var r=e(0),i=e(85),o=e(81),a=r.TypeError;n.exports=function(n){if(i(n))return n;throw a(o(n)+" is not a constructor")}},function(n,t,e){var r,i,o,a,s=e(0),c=e(34),u=e(53),l=e(4),p=e(10),d=e(3),f=e(157),h=e(65),m=e(78),v=e(142),g=e(168),b=e(86),y=s.setImmediate,x=s.clearImmediate,A=s.process,C=s.Dispatch,S=s.Function,w=s.MessageChannel,I=s.String,E=0,P={};try{r=s.location}catch(n){}var _=function(n){if(p(P,n)){var t=P[n];delete P[n],t()}},O=function(n){return function(){_(n)}},D=function(n){_(n.data)},T=function(n){s.postMessage(I(n),r.protocol+"//"+r.host)};y&&x||(y=function(n){v(arguments.length,1);var t=l(n)?n:S(n),e=h(arguments,1);return P[++E]=function(){c(t,void 0,e)},i(E),E},x=function(n){delete P[n]},b?i=function(n){A.nextTick(O(n))}:C&&C.now?i=function(n){C.now(O(n))}:w&&!g?(a=(o=new w).port2,o.port1.onmessage=D,i=u(a.postMessage,a)):s.addEventListener&&l(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!d(T)?(i=T,s.addEventListener("message",D,!1)):i="onreadystatechange"in m("script")?function(n){f.appendChild(m("script")).onreadystatechange=function(){f.removeChild(this),_(n)}}:function(n){setTimeout(O(n),0)}),n.exports={set:y,clear:x}},function(n,t,e){var r=e(27);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,t,e){var r=e(7),i=e(8),o=e(170);n.exports=function(n,t){if(r(n),i(t)&&t.constructor===n)return t;var e=o.f(n);return(0,e.resolve)(t),e.promise}},function(n,t,e){"use strict";var r=e(35),i=function(n){var t,e;this.promise=new n((function(n,r){if(void 0!==t||void 0!==e)throw TypeError("Bad Promise constructor");t=n,e=r})),this.resolve=r(t),this.reject=r(e)};n.exports.f=function(n){return new i(n)}},function(n,t,e){var r=e(1),i=e(52),o=e(12),a=e(17),s=r("".charAt),c=r("".charCodeAt),u=r("".slice),l=function(n){return function(t,e){var r,l,p=o(a(t)),d=i(e),f=p.length;return d<0||d>=f?n?"":void 0:(r=c(p,d))<55296||r>56319||d+1===f||(l=c(p,d+1))<56320||l>57343?n?s(p,d):r:n?u(p,d,d+2):l-56320+(r-55296<<10)+65536}};n.exports={codeAt:l(!1),charAt:l(!0)}},function(n,t){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,t,e){var r=e(78)("span").classList,i=r&&r.constructor&&r.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,t,e){var r=e(2),i=e(3),o=e(15),a=e(116),s=e(161);r({target:"Object",stat:!0,forced:i((function(){a(1)})),sham:!s},{getPrototypeOf:function(n){return a(o(n))}})},function(n,t,e){var r=e(0),i=e(144),o=r.TypeError;n.exports=function(n){if(i(n))throw o("The method doesn't accept regular expressions");return n}},function(n,t,e){var r=e(5)("match");n.exports=function(n){var t=/./;try{"/./"[n](t)}catch(e){try{return t[r]=!1,"/./"[n](t)}catch(n){}}return!1}},function(n,t,e){"use strict";var r=e(54).forEach,i=e(45)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,t,e){var r=e(3);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,t,e){var r=e(21),i=e(19),o=e(55).f,a=e(119),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return o(n)}catch(n){return a(s)}}(n):o(i(n))}},function(n,t,e){var r=e(5);t.f=r},function(n,t,e){var r=e(258),i=e(10),o=e(180),a=e(13).f;n.exports=function(n){var t=r.Symbol||(r.Symbol={});i(t,n)||a(t,n,{value:o.f(n)})}},function(n,t,e){var r=e(2),i=e(259);r({target:"Array",stat:!0,forced:!e(165)((function(n){Array.from(n)}))},{from:i})},function(n,t,e){var r=e(12);n.exports=function(n,t){return void 0===n?arguments.length<2?"":t:r(n)}},function(n,t,e){e(2)({target:"Object",stat:!0,sham:!e(9)},{create:e(32)})},function(n,t,e){var r=e(2),i=e(0),o=e(16),a=e(34),s=e(1),c=e(3),u=i.Array,l=o("JSON","stringify"),p=s(/./.exec),d=s("".charAt),f=s("".charCodeAt),h=s("".replace),m=s(1..toString),v=/[\uD800-\uDFFF]/g,g=/^[\uD800-\uDBFF]$/,b=/^[\uDC00-\uDFFF]$/,y=function(n,t,e){var r=d(e,t-1),i=d(e,t+1);return p(g,n)&&!p(b,i)||p(b,n)&&!p(g,r)?"\\u"+m(f(n,0),16):n},x=c((function(){return'"\\udf06\\ud834"'!==l("\udf06\ud834")||'"\\udead"'!==l("\udead")}));l&&r({target:"JSON",stat:!0,forced:x},{stringify:function(n,t,e){for(var r=0,i=arguments.length,o=u(i);r<i;r++)o[r]=arguments[r];var s=a(l,null,o);return"string"==typeof s?h(s,v,y):s}})},function(n,t){n.exports=function(n,t){for(var e=-1,r=t.length,i=n.length;++e<r;)n[i+e]=t[e];return n}},function(n,t){var e="object"==typeof global&&global&&global.Object===Object&&global;n.exports=e},function(n,t,e){var r=e(91),i=e(280),o=e(281),a=e(282),s=e(283),c=e(284);function u(n){var t=this.__data__=new r(n);this.size=t.size}u.prototype.clear=i,u.prototype.delete=o,u.prototype.get=a,u.prototype.has=s,u.prototype.set=c,n.exports=u},function(n,t){n.exports=function(n,t){return n===t||n!=n&&t!=t}},function(n,t,e){var r=e(58),i=e(124);n.exports=function(n){if(!i(n))return!1;var t=r(n);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}},function(n,t){var e=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return e.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,t,e){var r=e(301),i=e(48);n.exports=function n(t,e,o,a,s){return t===e||(null==t||null==e||!i(t)&&!i(e)?t!=t&&e!=e:r(t,e,o,a,n,s))}},function(n,t,e){var r=e(194),i=e(304),o=e(195);n.exports=function(n,t,e,a,s,c){var u=1&e,l=n.length,p=t.length;if(l!=p&&!(u&&p>l))return!1;var d=c.get(n),f=c.get(t);if(d&&f)return d==t&&f==n;var h=-1,m=!0,v=2&e?new r:void 0;for(c.set(n,t),c.set(t,n);++h<l;){var g=n[h],b=t[h];if(a)var y=u?a(b,g,h,t,n,c):a(g,b,h,n,t,c);if(void 0!==y){if(y)continue;m=!1;break}if(v){if(!i(t,(function(n,t){if(!o(v,t)&&(g===n||s(g,n,e,a,c)))return v.push(t)}))){m=!1;break}}else if(g!==b&&!s(g,b,e,a,c)){m=!1;break}}return c.delete(n),c.delete(t),m}},function(n,t,e){var r=e(125),i=e(302),o=e(303);function a(n){var t=-1,e=null==n?0:n.length;for(this.__data__=new r;++t<e;)this.add(n[t])}a.prototype.add=a.prototype.push=i,a.prototype.has=o,n.exports=a},function(n,t){n.exports=function(n,t){return n.has(t)}},function(n,t,e){var r=e(314),i=e(320),o=e(200);n.exports=function(n){return o(n)?r(n):i(n)}},function(n,t,e){(function(n){var r=e(28),i=e(316),o=t&&!t.nodeType&&t,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;n.exports=c}).call(this,e(147)(n))},function(n,t){var e=/^(?:0|[1-9]\d*)$/;n.exports=function(n,t){var r=typeof n;return!!(t=null==t?9007199254740991:t)&&("number"==r||"symbol"!=r&&e.test(n))&&n>-1&&n%1==0&&n<t}},function(n,t,e){var r=e(317),i=e(318),o=e(319),a=o&&o.isTypedArray,s=a?i(a):r;n.exports=s},function(n,t,e){var r=e(190),i=e(127);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,t,e){var r=e(41)(e(28),"Set");n.exports=r},function(n,t,e){var r=e(124);n.exports=function(n){return n==n&&!r(n)}},function(n,t){n.exports=function(n,t){return function(e){return null!=e&&(e[n]===t&&(void 0!==t||n in Object(e)))}}},function(n,t,e){var r=e(205),i=e(95);n.exports=function(n,t){for(var e=0,o=(t=r(t,n)).length;null!=n&&e<o;)n=n[i(t[e++])];return e&&e==o?n:void 0}},function(n,t,e){var r=e(26),i=e(128),o=e(331),a=e(334);n.exports=function(n,t){return r(n)?n:i(n,t)?[n]:o(a(n))}},function(n,t,e){"use strict";var r=e(0),i=e(1),o=e(35),a=e(8),s=e(10),c=e(65),u=e(60),l=r.Function,p=i([].concat),d=i([].join),f={},h=function(n,t,e){if(!s(f,t)){for(var r=[],i=0;i<t;i++)r[i]="a["+i+"]";f[t]=l("C,a","return new C("+d(r,",")+")")}return f[t](n,e)};n.exports=u?l.bind:function(n){var t=o(this),e=t.prototype,r=c(arguments,1),i=function(){var e=p(r,c(arguments));return this instanceof i?h(t,e.length,e):t.apply(n,e)};return a(e)&&(i.prototype=e),i}},function(n,t,e){"use strict";var r=e(2),i=e(366).start;r({target:"String",proto:!0,forced:e(368)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){},function(n,t,e){},function(n,t,e){e(2)({target:"Object",stat:!0},{setPrototypeOf:e(64)})},function(n,t,e){var r=e(2),i=e(16),o=e(34),a=e(206),s=e(166),c=e(7),u=e(8),l=e(32),p=e(3),d=i("Reflect","construct"),f=Object.prototype,h=[].push,m=p((function(){function n(){}return!(d((function(){}),[],n)instanceof n)})),v=!p((function(){d((function(){}))})),g=m||v;r({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,t){s(n),c(t);var e=arguments.length<3?n:s(arguments[2]);if(v&&!m)return d(n,t,e);if(n==e){switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3])}var r=[null];return o(h,r,t),new(o(a,n,r))}var i=e.prototype,p=l(u(i)?i:f),g=o(n,p,t);return u(g)?g:p}})},function(n,t,e){var r=e(2),i=e(0),o=e(56);r({global:!0},{Reflect:{}}),o(i.Reflect,"Reflect",!0)},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(267),i=e(272),o=e(343),a=e(351),s=e(360),c=e(229),u=o((function(n){var t=c(n);return s(t)&&(t=void 0),a(r(n,1,s,!0),i(t,2))}));n.exports=u},function(n,t,e){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var t,e=""+n,i=r.exec(e);if(!i)return e;var o="",a=0,s=0;for(a=i.index;a<e.length;a++){switch(e.charCodeAt(a)){case 34:t="&quot;";break;case 38:t="&amp;";break;case 39:t="&#39;";break;case 60:t="&lt;";break;case 62:t="&gt;";break;default:continue}s!==a&&(o+=e.substring(s,a)),s=a+1,o+=t}return s!==a?o+e.substring(s,a):o}},function(n,t,e){"use strict";e.r(t);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(e(369),e(29)),o=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);t.default=o.exports},function(n,t,e){"use strict";e.r(t);e(37),e(6),e(38),e(43),e(30);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(t,e){return""===t.componentOptions.propsData.active&&(n.activeCodeTabIndex=e),{title:t.componentOptions.propsData.title,elm:t.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(e(370),e(29)),o=Object(i.a)(r,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(t){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);t.default=o.exports},function(n,t,e){"use strict";var r=e(9),i=e(0),o=e(1),a=e(100),s=e(14),c=e(10),u=e(146),l=e(33),p=e(80),d=e(155),f=e(3),h=e(55).f,m=e(39).f,v=e(13).f,g=e(365),b=e(149).trim,y=i.Number,x=y.prototype,A=i.TypeError,C=o("".slice),S=o("".charCodeAt),w=function(n){var t=d(n,"number");return"bigint"==typeof t?t:I(t)},I=function(n){var t,e,r,i,o,a,s,c,u=d(n,"number");if(p(u))throw A("Cannot convert a Symbol value to a number");if("string"==typeof u&&u.length>2)if(u=b(u),43===(t=S(u,0))||45===t){if(88===(e=S(u,2))||120===e)return NaN}else if(48===t){switch(S(u,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+u}for(a=(o=C(u,2)).length,s=0;s<a;s++)if((c=S(o,s))<48||c>i)return NaN;return parseInt(o,r)}return+u};if(a("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var E,P=function(n){var t=arguments.length<1?0:y(w(n)),e=this;return l(x,e)&&f((function(){g(e)}))?u(Object(t),e,P):t},_=r?h(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),O=0;_.length>O;O++)c(y,E=_[O])&&!c(P,E)&&v(P,E,m(y,E));P.prototype=x,x.constructor=P,s(i,"Number",P)}},function(n,t,e){var r=e(3),i=e(0).RegExp;n.exports=r((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,t,e){"use strict";var r=e(160).IteratorPrototype,i=e(32),o=e(47),a=e(56),s=e(62),c=function(){return this};n.exports=function(n,t,e,u){var l=t+" Iterator";return n.prototype=i(r,{next:o(+!u,e)}),a(n,l,!1,!0),s[l]=c,n}},function(n,t,e){var r=e(14);n.exports=function(n,t,e){for(var i in t)r(n,i,t[i],e);return n}},function(n,t,e){"use strict";var r=e(16),i=e(13),o=e(5),a=e(9),s=o("species");n.exports=function(n){var t=r(n),e=i.f;a&&t&&!t[s]&&e(t,s,{configurable:!0,get:function(){return this}})}},function(n,t,e){var r=e(0),i=e(33),o=r.TypeError;n.exports=function(n,t){if(i(t,n))return n;throw o("Incorrect invocation")}},function(n,t,e){var r=e(2),i=e(9),o=e(159),a=e(19),s=e(39),c=e(66);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var t,e,r=a(n),i=s.f,u=o(r),l={},p=0;u.length>p;)void 0!==(e=i(r,t=u[p++]))&&c(l,t,e);return l}})},function(n,t,e){var r=e(3),i=e(0).RegExp;n.exports=r((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,t,e){"use strict";var r=e(2),i=e(110).includes,o=e(135);r({target:"Array",proto:!0},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,t,e){"use strict";var r=e(2),i=e(1),o=e(175),a=e(17),s=e(12),c=e(176),u=i("".indexOf);r({target:"String",proto:!0,forced:!c("includes")},{includes:function(n){return!!~u(s(a(this)),s(o(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,t){n.exports=function(n){var t=null==n?0:n.length;return t?n[t-1]:void 0}},function(n,t,e){"use strict";var r=e(2),i=e(149).trim;r({target:"String",proto:!0,forced:e(363)("trim")},{trim:function(){return i(this)}})},function(n,t,e){var r=e(119),i=Math.floor,o=function(n,t){var e=n.length,c=i(e/2);return e<8?a(n,t):s(n,o(r(n,0,c),t),o(r(n,c),t),t)},a=function(n,t){for(var e,r,i=n.length,o=1;o<i;){for(r=o,e=n[o];r&&t(n[r-1],e)>0;)n[r]=n[--r];r!==o++&&(n[r]=e)}return n},s=function(n,t,e,r){for(var i=t.length,o=e.length,a=0,s=0;a<i||s<o;)n[a+s]=a<i&&s<o?r(t[a],e[s])<=0?t[a++]:e[s++]:a<i?t[a++]:e[s++];return n};n.exports=o},function(n,t,e){var r=e(0),i=e(9),o=e(103).MISSED_STICKY,a=e(21),s=e(13).f,c=e(36).get,u=RegExp.prototype,l=r.TypeError;i&&o&&s(u,"sticky",{configurable:!0,get:function(){if(this!==u){if("RegExp"===a(this))return!!c(this).sticky;throw l("Incompatible receiver, RegExp required")}}})},function(n,t,e){n.exports=e(379)},function(n,t,e){var r=e(0),i=e(11),o=e(4),a=e(8),s=r.TypeError;n.exports=function(n,t){var e,r;if("string"===t&&o(e=n.toString)&&!a(r=i(e,n)))return r;if(o(e=n.valueOf)&&!a(r=i(e,n)))return r;if("string"!==t&&o(e=n.toString)&&!a(r=i(e,n)))return r;throw s("Can't convert object to primitive value")}},function(n,t,e){var r=e(0),i=e(4),o=e(84),a=r.WeakMap;n.exports=i(a)&&/native code/.test(o(a))},function(n,t,e){var r=e(0),i=e(4),o=r.String,a=r.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw a("Can't set "+o(n)+" as a prototype")}},function(n,t,e){"use strict";var r,i,o,a,s=e(2),c=e(22),u=e(0),l=e(16),p=e(11),d=e(162),f=e(14),h=e(222),m=e(64),v=e(56),g=e(223),b=e(35),y=e(4),x=e(8),A=e(224),C=e(84),S=e(238),w=e(165),I=e(118),E=e(167).set,P=e(239),_=e(169),O=e(242),D=e(170),T=e(243),k=e(244),B=e(36),j=e(100),U=e(5),L=e(245),R=e(86),F=e(49),M=U("species"),z="Promise",N=B.getterFor(z),X=B.set,H=B.getterFor(z),$=d&&d.prototype,W=d,V=$,G=u.TypeError,q=u.document,J=u.process,Y=D.f,Z=Y,K=!!(q&&q.createEvent&&u.dispatchEvent),Q=y(u.PromiseRejectionEvent),nn=!1,tn=j(z,(function(){var n=C(W),t=n!==String(W);if(!t&&66===F)return!0;if(c&&!V.finally)return!0;if(F>=51&&/native code/.test(n))return!1;var e=new W((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(e.constructor={})[M]=r,!(nn=e.then((function(){}))instanceof r)||!t&&L&&!Q})),en=tn||!w((function(n){W.all(n).catch((function(){}))})),rn=function(n){var t;return!(!x(n)||!y(t=n.then))&&t},on=function(n,t){var e,r,i,o=t.value,a=1==t.state,s=a?n.ok:n.fail,c=n.resolve,u=n.reject,l=n.domain;try{s?(a||(2===t.rejection&&ln(t),t.rejection=1),!0===s?e=o:(l&&l.enter(),e=s(o),l&&(l.exit(),i=!0)),e===n.promise?u(G("Promise-chain cycle")):(r=rn(e))?p(r,e,c,u):c(e)):u(o)}catch(n){l&&!i&&l.exit(),u(n)}},an=function(n,t){n.notified||(n.notified=!0,P((function(){for(var e,r=n.reactions;e=r.get();)on(e,n);n.notified=!1,t&&!n.rejection&&cn(n)})))},sn=function(n,t,e){var r,i;K?((r=q.createEvent("Event")).promise=t,r.reason=e,r.initEvent(n,!1,!0),u.dispatchEvent(r)):r={promise:t,reason:e},!Q&&(i=u["on"+n])?i(r):"unhandledrejection"===n&&O("Unhandled promise rejection",e)},cn=function(n){p(E,u,(function(){var t,e=n.facade,r=n.value;if(un(n)&&(t=T((function(){R?J.emit("unhandledRejection",r,e):sn("unhandledrejection",e,r)})),n.rejection=R||un(n)?2:1,t.error))throw t.value}))},un=function(n){return 1!==n.rejection&&!n.parent},ln=function(n){p(E,u,(function(){var t=n.facade;R?J.emit("rejectionHandled",t):sn("rejectionhandled",t,n.value)}))},pn=function(n,t,e){return function(r){n(t,r,e)}},dn=function(n,t,e){n.done||(n.done=!0,e&&(n=e),n.value=t,n.state=2,an(n,!0))},fn=function(n,t,e){if(!n.done){n.done=!0,e&&(n=e);try{if(n.facade===t)throw G("Promise can't be resolved itself");var r=rn(t);r?P((function(){var e={done:!1};try{p(r,t,pn(fn,e,n),pn(dn,e,n))}catch(t){dn(e,t,n)}})):(n.value=t,n.state=1,an(n,!1))}catch(t){dn({done:!1},t,n)}}};if(tn&&(V=(W=function(n){A(this,V),b(n),p(r,this);var t=N(this);try{n(pn(fn,t),pn(dn,t))}catch(n){dn(t,n)}}).prototype,(r=function(n){X(this,{type:z,done:!1,notified:!1,parent:!1,reactions:new k,rejection:!1,state:0,value:void 0})}).prototype=h(V,{then:function(n,t){var e=H(this),r=Y(I(this,W));return e.parent=!0,r.ok=!y(n)||n,r.fail=y(t)&&t,r.domain=R?J.domain:void 0,0==e.state?e.reactions.add(r):P((function(){on(r,e)})),r.promise},catch:function(n){return this.then(void 0,n)}}),i=function(){var n=new r,t=N(n);this.promise=n,this.resolve=pn(fn,t),this.reject=pn(dn,t)},D.f=Y=function(n){return n===W||n===o?new i(n):Z(n)},!c&&y(d)&&$!==Object.prototype)){a=$.then,nn||(f($,"then",(function(n,t){var e=this;return new W((function(n,t){p(a,e,n,t)})).then(n,t)}),{unsafe:!0}),f($,"catch",V.catch,{unsafe:!0}));try{delete $.constructor}catch(n){}m&&m($,V)}s({global:!0,wrap:!0,forced:tn},{Promise:W}),v(W,z,!1,!0),g(z),o=l(z),s({target:z,stat:!0,forced:tn},{reject:function(n){var t=Y(this);return p(t.reject,void 0,n),t.promise}}),s({target:z,stat:!0,forced:c||tn},{resolve:function(n){return _(c&&this===o?W:this,n)}}),s({target:z,stat:!0,forced:en},{all:function(n){var t=this,e=Y(t),r=e.resolve,i=e.reject,o=T((function(){var e=b(t.resolve),o=[],a=0,s=1;S(n,(function(n){var c=a++,u=!1;s++,p(e,t,n).then((function(n){u||(u=!0,o[c]=n,--s||r(o))}),i)})),--s||r(o)}));return o.error&&i(o.value),e.promise},race:function(n){var t=this,e=Y(t),r=e.reject,i=T((function(){var i=b(t.resolve);S(n,(function(n){p(i,t,n).then(e.resolve,r)}))}));return i.error&&r(i.value),e.promise}})},function(n,t,e){var r=e(0),i=e(53),o=e(11),a=e(7),s=e(81),c=e(163),u=e(20),l=e(33),p=e(141),d=e(101),f=e(164),h=r.TypeError,m=function(n,t){this.stopped=n,this.result=t},v=m.prototype;n.exports=function(n,t,e){var r,g,b,y,x,A,C,S=e&&e.that,w=!(!e||!e.AS_ENTRIES),I=!(!e||!e.IS_ITERATOR),E=!(!e||!e.INTERRUPTED),P=i(t,S),_=function(n){return r&&f(r,"normal",n),new m(!0,n)},O=function(n){return w?(a(n),E?P(n[0],n[1],_):P(n[0],n[1])):E?P(n,_):P(n)};if(I)r=n;else{if(!(g=d(n)))throw h(s(n)+" is not iterable");if(c(g)){for(b=0,y=u(n);y>b;b++)if((x=O(n[b]))&&l(v,x))return x;return new m(!1)}r=p(n,g)}for(A=r.next;!(C=o(A,r)).done;){try{x=O(C.value)}catch(n){f(r,"throw",n)}if("object"==typeof x&&x&&l(v,x))return x}return new m(!1)}},function(n,t,e){var r,i,o,a,s,c,u,l,p=e(0),d=e(53),f=e(39).f,h=e(167).set,m=e(168),v=e(240),g=e(241),b=e(86),y=p.MutationObserver||p.WebKitMutationObserver,x=p.document,A=p.process,C=p.Promise,S=f(p,"queueMicrotask"),w=S&&S.value;w||(r=function(){var n,t;for(b&&(n=A.domain)&&n.exit();i;){t=i.fn,i=i.next;try{t()}catch(n){throw i?a():o=void 0,n}}o=void 0,n&&n.enter()},m||b||g||!y||!x?!v&&C&&C.resolve?((u=C.resolve(void 0)).constructor=C,l=d(u.then,u),a=function(){l(r)}):b?a=function(){A.nextTick(r)}:(h=d(h,p),a=function(){h(r)}):(s=!0,c=x.createTextNode(""),new y(r).observe(c,{characterData:!0}),a=function(){c.data=s=!s})),n.exports=w||function(n){var t={fn:n,next:void 0};o&&(o.next=t),i||(i=t,a()),o=t}},function(n,t,e){var r=e(27),i=e(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==i.Pebble},function(n,t,e){var r=e(27);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,t,e){var r=e(0);n.exports=function(n,t){var e=r.console;e&&e.error&&(1==arguments.length?e.error(n):e.error(n,t))}},function(n,t){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,t){var e=function(){this.head=null,this.tail=null};e.prototype={add:function(n){var t={item:n,next:null};this.head?this.tail.next=t:this.head=t,this.tail=t},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=e},function(n,t){n.exports="object"==typeof window},function(n,t,e){var r=e(2),i=e(247);r({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(n,t,e){"use strict";var r=e(9),i=e(1),o=e(11),a=e(3),s=e(82),c=e(115),u=e(113),l=e(15),p=e(59),d=Object.assign,f=Object.defineProperty,h=i([].concat);n.exports=!d||a((function(){if(r&&1!==d({b:1},d(f({},"a",{enumerable:!0,get:function(){f(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},t={},e=Symbol();return n[e]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){t[n]=n})),7!=d({},n)[e]||"abcdefghijklmnopqrst"!=s(d({},t)).join("")}))?function(n,t){for(var e=l(n),i=arguments.length,a=1,d=c.f,f=u.f;i>a;)for(var m,v=p(arguments[a++]),g=d?h(s(v),d(v)):s(v),b=g.length,y=0;b>y;)m=g[y++],r&&!o(f,v,m)||(e[m]=v[m]);return e}:d},function(n,t,e){"use strict";var r=e(2),i=e(22),o=e(162),a=e(3),s=e(16),c=e(4),u=e(118),l=e(169),p=e(14);if(r({target:"Promise",proto:!0,real:!0,forced:!!o&&a((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var t=u(this,s("Promise")),e=c(n);return this.then(e?function(e){return l(t,n()).then((function(){return e}))}:n,e?function(e){return l(t,n()).then((function(){throw e}))}:n)}}),!i&&c(o)){var d=s("Promise").prototype.finally;o.prototype.finally!==d&&p(o.prototype,"finally",d,{unsafe:!0})}},function(n,t,e){"use strict";var r=e(117),i=e(73);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,t,e){var r=e(0),i=e(57),o=e(85),a=e(8),s=e(5)("species"),c=r.Array;n.exports=function(n){var t;return i(n)&&(t=n.constructor,(o(t)&&(t===c||i(t.prototype))||a(t)&&null===(t=t[s]))&&(t=void 0)),void 0===t?c:t}},function(n,t,e){"use strict";var r=e(2),i=e(252).left,o=e(45),a=e(49),s=e(86);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&a>79&&a<83},{reduce:function(n){var t=arguments.length;return i(this,n,t,t>1?arguments[1]:void 0)}})},function(n,t,e){var r=e(0),i=e(35),o=e(15),a=e(59),s=e(20),c=r.TypeError,u=function(n){return function(t,e,r,u){i(e);var l=o(t),p=a(l),d=s(l),f=n?d-1:0,h=n?-1:1;if(r<2)for(;;){if(f in p){u=p[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw c("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in p&&(u=e(u,p[f],f,l));return u}};n.exports={left:u(!1),right:u(!0)}},function(n,t,e){"use strict";var r,i=e(2),o=e(1),a=e(39).f,s=e(50),c=e(12),u=e(175),l=e(17),p=e(176),d=e(22),f=o("".startsWith),h=o("".slice),m=Math.min,v=p("startsWith");i({target:"String",proto:!0,forced:!!(d||v||(r=a(String.prototype,"startsWith"),!r||r.writable))&&!v},{startsWith:function(n){var t=c(l(this));u(n);var e=s(m(arguments.length>1?arguments[1]:void 0,t.length)),r=c(n);return f?f(t,r,e):h(t,e,e+r.length)===r}})},function(n,t,e){var r=e(2),i=e(178),o=e(3),a=e(8),s=e(255).onFreeze,c=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){c(1)})),sham:!i},{freeze:function(n){return c&&a(n)?c(s(n)):n}})},function(n,t,e){var r=e(2),i=e(1),o=e(61),a=e(8),s=e(10),c=e(13).f,u=e(55),l=e(179),p=e(256),d=e(77),f=e(178),h=!1,m=d("meta"),v=0,g=function(n){c(n,m,{value:{objectID:"O"+v++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=u.f,t=i([].splice),e={};e[m]=1,n(e).length&&(u.f=function(e){for(var r=n(e),i=0,o=r.length;i<o;i++)if(r[i]===m){t(r,i,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:l.f}))},fastKey:function(n,t){if(!a(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,m)){if(!p(n))return"F";if(!t)return"E";g(n)}return n[m].objectID},getWeakData:function(n,t){if(!s(n,m)){if(!p(n))return!0;if(!t)return!1;g(n)}return n[m].weakData},onFreeze:function(n){return f&&h&&p(n)&&!s(n,m)&&g(n),n}};o[m]=!0},function(n,t,e){var r=e(3),i=e(8),o=e(21),a=e(257),s=Object.isExtensible,c=r((function(){s(1)}));n.exports=c||a?function(n){return!!i(n)&&((!a||"ArrayBuffer"!=o(n))&&(!s||s(n)))}:s},function(n,t,e){var r=e(3);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,t,e){var r=e(0);n.exports=r},function(n,t,e){"use strict";var r=e(0),i=e(53),o=e(11),a=e(15),s=e(260),c=e(163),u=e(85),l=e(20),p=e(66),d=e(141),f=e(101),h=r.Array;n.exports=function(n){var t=a(n),e=u(this),r=arguments.length,m=r>1?arguments[1]:void 0,v=void 0!==m;v&&(m=i(m,r>2?arguments[2]:void 0));var g,b,y,x,A,C,S=f(t),w=0;if(!S||this==h&&c(S))for(g=l(t),b=e?new this(g):h(g);g>w;w++)C=v?m(t[w],w):t[w],p(b,w,C);else for(A=(x=d(t,S)).next,b=e?new this:[];!(y=o(A,x)).done;w++)C=v?s(x,m,[y.value,w],!0):y.value,p(b,w,C);return b.length=w,b}},function(n,t,e){var r=e(7),i=e(164);n.exports=function(n,t,e,o){try{return o?t(r(e)[0],e[1]):t(e)}catch(t){i(n,"throw",t)}}},function(n,t,e){"use strict";var r=e(16),i=e(10),o=e(23),a=e(33),s=e(64),c=e(114),u=e(146),l=e(183),p=e(262),d=e(263),f=e(264),h=e(22);n.exports=function(n,t,e,m){var v=m?2:1,g=n.split("."),b=g[g.length-1],y=r.apply(null,g);if(y){var x=y.prototype;if(!h&&i(x,"cause")&&delete x.cause,!e)return y;var A=r("Error"),C=t((function(n,t){var e=l(m?t:n,void 0),r=m?new y(n):new y;return void 0!==e&&o(r,"message",e),f&&o(r,"stack",d(r.stack,2)),this&&a(x,this)&&u(r,this,C),arguments.length>v&&p(r,arguments[v]),r}));if(C.prototype=x,"Error"!==b&&(s?s(C,A):c(C,A,{name:!0})),c(C,y),!h)try{x.name!==b&&o(x,"name",b),x.constructor=C}catch(n){}return C}}},function(n,t,e){var r=e(8),i=e(23);n.exports=function(n,t){r(t)&&"cause"in t&&i(n,"cause",t.cause)}},function(n,t,e){var r=e(1)("".replace),i=String(Error("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,a=o.test(i);n.exports=function(n,t){if(a&&"string"==typeof n)for(;t--;)n=r(n,o,"");return n}},function(n,t,e){var r=e(3),i=e(47);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,t,e){"use strict";var r=e(9),i=e(3),o=e(7),a=e(32),s=e(183),c=Error.prototype.toString,u=i((function(){if(r){var n=a(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==c.call(n))return!0}return"2: 1"!==c.call({message:1,name:2})||"Error"!==c.call({})}));n.exports=u?function(){var n=o(this),t=s(n.name,"Error"),e=s(n.message);return t?e?t+": "+e:t:e}:c},function(n,t,e){var r=e(1),i=e(15),o=Math.floor,a=r("".charAt),s=r("".replace),c=r("".slice),u=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,l=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,t,e,r,p,d){var f=e+n.length,h=r.length,m=l;return void 0!==p&&(p=i(p),m=u),s(d,m,(function(i,s){var u;switch(a(s,0)){case"$":return"$";case"&":return n;case"`":return c(t,0,e);case"'":return c(t,f);case"<":u=p[c(s,1,-1)];break;default:var l=+s;if(0===l)return i;if(l>h){var d=o(l/10);return 0===d?i:d<=h?void 0===r[d-1]?a(s,1):r[d-1]+a(s,1):i}u=r[l-1]}return void 0===u?"":u}))}},function(n,t,e){var r=e(186),i=e(268);n.exports=function n(t,e,o,a,s){var c=-1,u=t.length;for(o||(o=i),s||(s=[]);++c<u;){var l=t[c];e>0&&o(l)?e>1?n(l,e-1,o,a,s):r(s,l):a||(s[s.length]=l)}return s}},function(n,t,e){var r=e(67),i=e(122),o=e(26),a=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||i(n)||!!(a&&n&&n[a])}},function(n,t,e){var r=e(58),i=e(48);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,t,e){var r=e(67),i=Object.prototype,o=i.hasOwnProperty,a=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var t=o.call(n,s),e=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=a.call(n);return r&&(t?n[s]=e:delete n[s]),i}},function(n,t){var e=Object.prototype.toString;n.exports=function(n){return e.call(n)}},function(n,t,e){var r=e(273),i=e(329),o=e(130),a=e(26),s=e(340);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?a(n)?i(n[0],n[1]):r(n):s(n)}},function(n,t,e){var r=e(274),i=e(328),o=e(203);n.exports=function(n){var t=i(n);return 1==t.length&&t[0][2]?o(t[0][0],t[0][1]):function(e){return e===n||r(e,n,t)}}},function(n,t,e){var r=e(188),i=e(192);n.exports=function(n,t,e,o){var a=e.length,s=a,c=!o;if(null==n)return!s;for(n=Object(n);a--;){var u=e[a];if(c&&u[2]?u[1]!==n[u[0]]:!(u[0]in n))return!1}for(;++a<s;){var l=(u=e[a])[0],p=n[l],d=u[1];if(c&&u[2]){if(void 0===p&&!(l in n))return!1}else{var f=new r;if(o)var h=o(p,d,l,n,t,f);if(!(void 0===h?i(d,p,3,o,f):h))return!1}}return!0}},function(n,t){n.exports=function(){this.__data__=[],this.size=0}},function(n,t,e){var r=e(92),i=Array.prototype.splice;n.exports=function(n){var t=this.__data__,e=r(t,n);return!(e<0)&&(e==t.length-1?t.pop():i.call(t,e,1),--this.size,!0)}},function(n,t,e){var r=e(92);n.exports=function(n){var t=this.__data__,e=r(t,n);return e<0?void 0:t[e][1]}},function(n,t,e){var r=e(92);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,t,e){var r=e(92);n.exports=function(n,t){var e=this.__data__,i=r(e,n);return i<0?(++this.size,e.push([n,t])):e[i][1]=t,this}},function(n,t,e){var r=e(91);n.exports=function(){this.__data__=new r,this.size=0}},function(n,t){n.exports=function(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e}},function(n,t){n.exports=function(n){return this.__data__.get(n)}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t,e){var r=e(91),i=e(123),o=e(125);n.exports=function(n,t){var e=this.__data__;if(e instanceof r){var a=e.__data__;if(!i||a.length<199)return a.push([n,t]),this.size=++e.size,this;e=this.__data__=new o(a)}return e.set(n,t),this.size=e.size,this}},function(n,t,e){var r=e(190),i=e(286),o=e(124),a=e(191),s=/^\[object .+?Constructor\]$/,c=Function.prototype,u=Object.prototype,l=c.toString,p=u.hasOwnProperty,d=RegExp("^"+l.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||i(n))&&(r(n)?d:s).test(a(n))}},function(n,t,e){var r,i=e(287),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,t,e){var r=e(28)["__core-js_shared__"];n.exports=r},function(n,t){n.exports=function(n,t){return null==n?void 0:n[t]}},function(n,t,e){var r=e(290),i=e(91),o=e(123);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(n,t,e){var r=e(291),i=e(292),o=e(293),a=e(294),s=e(295);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(93);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,t){n.exports=function(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}},function(n,t,e){var r=e(93),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;if(r){var e=t[n];return"__lodash_hash_undefined__"===e?void 0:e}return i.call(t,n)?t[n]:void 0}},function(n,t,e){var r=e(93),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;return r?void 0!==t[n]:i.call(t,n)}},function(n,t,e){var r=e(93);n.exports=function(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=r&&void 0===t?"__lodash_hash_undefined__":t,this}},function(n,t,e){var r=e(94);n.exports=function(n){var t=r(this,n).delete(n);return this.size-=t?1:0,t}},function(n,t){n.exports=function(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}},function(n,t,e){var r=e(94);n.exports=function(n){return r(this,n).get(n)}},function(n,t,e){var r=e(94);n.exports=function(n){return r(this,n).has(n)}},function(n,t,e){var r=e(94);n.exports=function(n,t){var e=r(this,n),i=e.size;return e.set(n,t),this.size+=e.size==i?0:1,this}},function(n,t,e){var r=e(188),i=e(193),o=e(305),a=e(308),s=e(324),c=e(26),u=e(197),l=e(199),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,f,h,m){var v=c(n),g=c(t),b=v?"[object Array]":s(n),y=g?"[object Array]":s(t),x=(b="[object Arguments]"==b?p:b)==p,A=(y="[object Arguments]"==y?p:y)==p,C=b==y;if(C&&u(n)){if(!u(t))return!1;v=!0,x=!1}if(C&&!x)return m||(m=new r),v||l(n)?i(n,t,e,f,h,m):o(n,t,b,e,f,h,m);if(!(1&e)){var S=x&&d.call(n,"__wrapped__"),w=A&&d.call(t,"__wrapped__");if(S||w){var I=S?n.value():n,E=w?t.value():t;return m||(m=new r),h(I,E,e,f,m)}}return!!C&&(m||(m=new r),a(n,t,e,f,h,m))}},function(n,t){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length;++e<r;)if(t(n[e],e,n))return!0;return!1}},function(n,t,e){var r=e(67),i=e(306),o=e(189),a=e(193),s=e(307),c=e(126),u=r?r.prototype:void 0,l=u?u.valueOf:void 0;n.exports=function(n,t,e,r,u,p,d){switch(e){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=t.byteLength||!p(new i(n),new i(t)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=c),n.size!=t.size&&!h)return!1;var m=d.get(n);if(m)return m==t;r|=2,d.set(n,t);var v=a(f(n),f(t),r,u,p,d);return d.delete(n),v;case"[object Symbol]":if(l)return l.call(n)==l.call(t)}return!1}},function(n,t,e){var r=e(28).Uint8Array;n.exports=r},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n,r){e[++t]=[r,n]})),e}},function(n,t,e){var r=e(309),i=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,o,a,s){var c=1&e,u=r(n),l=u.length;if(l!=r(t).length&&!c)return!1;for(var p=l;p--;){var d=u[p];if(!(c?d in t:i.call(t,d)))return!1}var f=s.get(n),h=s.get(t);if(f&&h)return f==t&&h==n;var m=!0;s.set(n,t),s.set(t,n);for(var v=c;++p<l;){var g=n[d=u[p]],b=t[d];if(o)var y=c?o(b,g,d,t,n,s):o(g,b,d,n,t,s);if(!(void 0===y?g===b||a(g,b,e,o,s):y)){m=!1;break}v||(v="constructor"==d)}if(m&&!v){var x=n.constructor,A=t.constructor;x==A||!("constructor"in n)||!("constructor"in t)||"function"==typeof x&&x instanceof x&&"function"==typeof A&&A instanceof A||(m=!1)}return s.delete(n),s.delete(t),m}},function(n,t,e){var r=e(310),i=e(311),o=e(196);n.exports=function(n){return r(n,o,i)}},function(n,t,e){var r=e(186),i=e(26);n.exports=function(n,t,e){var o=t(n);return i(n)?o:r(o,e(n))}},function(n,t,e){var r=e(312),i=e(313),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(n){return null==n?[]:(n=Object(n),r(a(n),(function(t){return o.call(n,t)})))}:i;n.exports=s},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=0,o=[];++e<r;){var a=n[e];t(a,e,n)&&(o[i++]=a)}return o}},function(n,t){n.exports=function(){return[]}},function(n,t,e){var r=e(315),i=e(122),o=e(26),a=e(197),s=e(198),c=e(199),u=Object.prototype.hasOwnProperty;n.exports=function(n,t){var e=o(n),l=!e&&i(n),p=!e&&!l&&a(n),d=!e&&!l&&!p&&c(n),f=e||l||p||d,h=f?r(n.length,String):[],m=h.length;for(var v in n)!t&&!u.call(n,v)||f&&("length"==v||p&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,t){n.exports=function(n,t){for(var e=-1,r=Array(n);++e<n;)r[e]=t(e);return r}},function(n,t){n.exports=function(){return!1}},function(n,t,e){var r=e(58),i=e(127),o=e(48),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&i(n.length)&&!!a[r(n)]}},function(n,t){n.exports=function(n){return function(t){return n(t)}}},function(n,t,e){(function(n){var r=e(187),i=t&&!t.nodeType&&t,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,a=o&&o.exports===i&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=s}).call(this,e(147)(n))},function(n,t,e){var r=e(321),i=e(322),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var t=[];for(var e in Object(n))o.call(n,e)&&"constructor"!=e&&t.push(e);return t}},function(n,t){var e=Object.prototype;n.exports=function(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||e)}},function(n,t,e){var r=e(323)(Object.keys,Object);n.exports=r},function(n,t){n.exports=function(n,t){return function(e){return n(t(e))}}},function(n,t,e){var r=e(325),i=e(123),o=e(326),a=e(201),s=e(327),c=e(58),u=e(191),l=u(r),p=u(i),d=u(o),f=u(a),h=u(s),m=c;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||o&&"[object Promise]"!=m(o.resolve())||a&&"[object Set]"!=m(new a)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var t=c(n),e="[object Object]"==t?n.constructor:void 0,r=e?u(e):"";if(r)switch(r){case l:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return t}),n.exports=m},function(n,t,e){var r=e(41)(e(28),"DataView");n.exports=r},function(n,t,e){var r=e(41)(e(28),"Promise");n.exports=r},function(n,t,e){var r=e(41)(e(28),"WeakMap");n.exports=r},function(n,t,e){var r=e(202),i=e(196);n.exports=function(n){for(var t=i(n),e=t.length;e--;){var o=t[e],a=n[o];t[e]=[o,a,r(a)]}return t}},function(n,t,e){var r=e(192),i=e(330),o=e(337),a=e(128),s=e(202),c=e(203),u=e(95);n.exports=function(n,t){return a(n)&&s(t)?c(u(n),t):function(e){var a=i(e,n);return void 0===a&&a===t?o(e,n):r(t,a,3)}}},function(n,t,e){var r=e(204);n.exports=function(n,t,e){var i=null==n?void 0:r(n,t);return void 0===i?e:i}},function(n,t,e){var r=e(332),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=r((function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(i,(function(n,e,r,i){t.push(r?i.replace(o,"$1"):e||n)})),t}));n.exports=a},function(n,t,e){var r=e(333);n.exports=function(n){var t=r(n,(function(n){return 500===e.size&&e.clear(),n})),e=t.cache;return t}},function(n,t,e){var r=e(125);function i(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new TypeError("Expected a function");var e=function(){var r=arguments,i=t?t.apply(this,r):r[0],o=e.cache;if(o.has(i))return o.get(i);var a=n.apply(this,r);return e.cache=o.set(i,a)||o,a};return e.cache=new(i.Cache||r),e}i.Cache=r,n.exports=i},function(n,t,e){var r=e(335);n.exports=function(n){return null==n?"":r(n)}},function(n,t,e){var r=e(67),i=e(336),o=e(26),a=e(129),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(t){if("string"==typeof t)return t;if(o(t))return i(t,n)+"";if(a(t))return c?c.call(t):"";var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=Array(r);++e<r;)i[e]=t(n[e],e,n);return i}},function(n,t,e){var r=e(338),i=e(339);n.exports=function(n,t){return null!=n&&i(n,t,r)}},function(n,t){n.exports=function(n,t){return null!=n&&t in Object(n)}},function(n,t,e){var r=e(205),i=e(122),o=e(26),a=e(198),s=e(127),c=e(95);n.exports=function(n,t,e){for(var u=-1,l=(t=r(t,n)).length,p=!1;++u<l;){var d=c(t[u]);if(!(p=null!=n&&e(n,d)))break;n=n[d]}return p||++u!=l?p:!!(l=null==n?0:n.length)&&s(l)&&a(d,l)&&(o(n)||i(n))}},function(n,t,e){var r=e(341),i=e(342),o=e(128),a=e(95);n.exports=function(n){return o(n)?r(a(n)):i(n)}},function(n,t){n.exports=function(n){return function(t){return null==t?void 0:t[n]}}},function(n,t,e){var r=e(204);n.exports=function(n){return function(t){return r(t,n)}}},function(n,t,e){var r=e(130),i=e(344),o=e(346);n.exports=function(n,t){return o(i(n,t,r),n+"")}},function(n,t,e){var r=e(345),i=Math.max;n.exports=function(n,t,e){return t=i(void 0===t?n.length-1:t,0),function(){for(var o=arguments,a=-1,s=i(o.length-t,0),c=Array(s);++a<s;)c[a]=o[t+a];a=-1;for(var u=Array(t+1);++a<t;)u[a]=o[a];return u[t]=e(c),r(n,this,u)}}},function(n,t){n.exports=function(n,t,e){switch(e.length){case 0:return n.call(t);case 1:return n.call(t,e[0]);case 2:return n.call(t,e[0],e[1]);case 3:return n.call(t,e[0],e[1],e[2])}return n.apply(t,e)}},function(n,t,e){var r=e(347),i=e(350)(r);n.exports=i},function(n,t,e){var r=e(348),i=e(349),o=e(130),a=i?function(n,t){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(t),writable:!0})}:o;n.exports=a},function(n,t){n.exports=function(n){return function(){return n}}},function(n,t,e){var r=e(41),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,t){var e=Date.now;n.exports=function(n){var t=0,r=0;return function(){var i=e(),o=16-(i-r);if(r=i,o>0){if(++t>=800)return arguments[0]}else t=0;return n.apply(void 0,arguments)}}},function(n,t,e){var r=e(194),i=e(352),o=e(357),a=e(195),s=e(358),c=e(126);n.exports=function(n,t,e){var u=-1,l=i,p=n.length,d=!0,f=[],h=f;if(e)d=!1,l=o;else if(p>=200){var m=t?null:s(n);if(m)return c(m);d=!1,l=a,h=new r}else h=t?[]:f;n:for(;++u<p;){var v=n[u],g=t?t(v):v;if(v=e||0!==v?v:0,d&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;t&&h.push(g),f.push(v)}else l(h,g,e)||(h!==f&&h.push(g),f.push(v))}return f}},function(n,t,e){var r=e(353);n.exports=function(n,t){return!!(null==n?0:n.length)&&r(n,t,0)>-1}},function(n,t,e){var r=e(354),i=e(355),o=e(356);n.exports=function(n,t,e){return t==t?o(n,t,e):r(n,i,e)}},function(n,t){n.exports=function(n,t,e,r){for(var i=n.length,o=e+(r?1:-1);r?o--:++o<i;)if(t(n[o],o,n))return o;return-1}},function(n,t){n.exports=function(n){return n!=n}},function(n,t){n.exports=function(n,t,e){for(var r=e-1,i=n.length;++r<i;)if(n[r]===t)return r;return-1}},function(n,t){n.exports=function(n,t,e){for(var r=-1,i=null==n?0:n.length;++r<i;)if(e(t,n[r]))return!0;return!1}},function(n,t,e){var r=e(201),i=e(359),o=e(126),a=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=a},function(n,t){n.exports=function(){}},function(n,t,e){var r=e(200),i=e(48);n.exports=function(n){return i(n)&&r(n)}},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(63).PROPER,i=e(3),o=e(150);n.exports=function(n){return i((function(){return!!o[n]()||"​᠎"!=="​᠎"[n]()||r&&o[n].name!==n}))}},function(n,t,e){var r=e(2),i=e(206);r({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},function(n,t,e){var r=e(1);n.exports=r(1..valueOf)},function(n,t,e){var r=e(1),i=e(50),o=e(12),a=e(367),s=e(17),c=r(a),u=r("".slice),l=Math.ceil,p=function(n){return function(t,e,r){var a,p,d=o(s(t)),f=i(e),h=d.length,m=void 0===r?" ":o(r);return f<=h||""==m?d:((p=c(m,l((a=f-h)/m.length))).length>a&&(p=u(p,0,a)),n?d+p:p+d)}};n.exports={start:p(!1),end:p(!0)}},function(n,t,e){"use strict";var r=e(0),i=e(52),o=e(12),a=e(17),s=r.RangeError;n.exports=function(n){var t=o(a(this)),e="",r=i(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(t+=t))1&r&&(e+=t);return e}},function(n,t,e){var r=e(27);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,t,e){"use strict";e(208)},function(n,t,e){"use strict";e(209)},function(n,t,e){"use strict";var r=e(2),i=e(1),o=e(35),a=e(15),s=e(20),c=e(12),u=e(3),l=e(231),p=e(45),d=e(372),f=e(373),h=e(49),m=e(374),v=[],g=i(v.sort),b=i(v.push),y=u((function(){v.sort(void 0)})),x=u((function(){v.sort(null)})),A=p("sort"),C=!u((function(){if(h)return h<70;if(!(d&&d>3)){if(f)return!0;if(m)return m<603;var n,t,e,r,i="";for(n=65;n<76;n++){switch(t=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:e=3;break;case 68:case 71:e=4;break;default:e=2}for(r=0;r<47;r++)v.push({k:t+r,v:e})}for(v.sort((function(n,t){return t.v-n.v})),r=0;r<v.length;r++)t=v[r].k.charAt(0),i.charAt(i.length-1)!==t&&(i+=t);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:y||!x||!A||!C},{sort:function(n){void 0!==n&&o(n);var t=a(this);if(C)return void 0===n?g(t):g(t,n);var e,r,i=[],u=s(t);for(r=0;r<u;r++)r in t&&b(i,t[r]);for(l(i,function(n){return function(t,e){return void 0===e?-1:void 0===t?1:void 0!==n?+n(t,e)||0:c(t)>c(e)?1:-1}}(n)),e=i.length,r=0;r<e;)t[r]=i[r++];for(;r<u;)delete t[r++];return t}})},function(n,t,e){var r=e(27).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,t,e){var r=e(27);n.exports=/MSIE|Trident/.test(r)},function(n,t,e){var r=e(27).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,t,e){},function(n,t,e){},function(n,t,e){"use strict";e(213)},function(n,t,e){"use strict";e(214)},function(n,t,e){"use strict";e.r(t);e(139),e(237),e(246),e(248);var r=e(87),i=(e(136),e(51),e(6),e(24),e(31),e(43),e(30),Object.freeze({}));function o(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function u(n){return null!==n&&"object"==typeof n}var l=Object.prototype.toString;function p(n){return"[object Object]"===l.call(n)}function d(n){return"[object RegExp]"===l.call(n)}function f(n){var t=parseFloat(String(n));return t>=0&&Math.floor(t)===t&&isFinite(n)}function h(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function m(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===l?JSON.stringify(n,null,2):String(n)}function v(n){var t=parseFloat(n);return isNaN(t)?n:t}function g(n,t){for(var e=Object.create(null),r=n.split(","),i=0;i<r.length;i++)e[r[i]]=!0;return t?function(n){return e[n.toLowerCase()]}:function(n){return e[n]}}g("slot,component",!0);var b=g("key,ref,slot,slot-scope,is");function y(n,t){if(n.length){var e=n.indexOf(t);if(e>-1)return n.splice(e,1)}}var x=Object.prototype.hasOwnProperty;function A(n,t){return x.call(n,t)}function C(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var S=/-(\w)/g,w=C((function(n){return n.replace(S,(function(n,t){return t?t.toUpperCase():""}))})),I=C((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,P=C((function(n){return n.replace(E,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,t){return n.bind(t)}:function(n,t){function e(e){var r=arguments.length;return r?r>1?n.apply(t,arguments):n.call(t,e):n.call(t)}return e._length=n.length,e};function O(n,t){t=t||0;for(var e=n.length-t,r=new Array(e);e--;)r[e]=n[e+t];return r}function D(n,t){for(var e in t)n[e]=t[e];return n}function T(n){for(var t={},e=0;e<n.length;e++)n[e]&&D(t,n[e]);return t}function k(n,t,e){}var B=function(n,t,e){return!1},j=function(n){return n};function U(n,t){if(n===t)return!0;var e=u(n),r=u(t);if(!e||!r)return!e&&!r&&String(n)===String(t);try{var i=Array.isArray(n),o=Array.isArray(t);if(i&&o)return n.length===t.length&&n.every((function(n,e){return U(n,t[e])}));if(n instanceof Date&&t instanceof Date)return n.getTime()===t.getTime();if(i||o)return!1;var a=Object.keys(n),s=Object.keys(t);return a.length===s.length&&a.every((function(e){return U(n[e],t[e])}))}catch(n){return!1}}function L(n,t){for(var e=0;e<n.length;e++)if(U(n[e],t))return e;return-1}function R(n){var t=!1;return function(){t||(t=!0,n.apply(this,arguments))}}var F=["component","directive","filter"],M=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],z={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:k,parsePlatformTagName:j,mustUseProp:B,async:!0,_lifecycleHooks:M},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function X(n,t,e,r){Object.defineProperty(n,t,{value:e,enumerable:!!r,writable:!0,configurable:!0})}var H=new RegExp("[^"+N.source+".$_\\d]");var $,W="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,q=G&&WXEnvironment.platform.toLowerCase(),J=V&&window.navigator.userAgent.toLowerCase(),Y=J&&/msie|trident/.test(J),Z=J&&J.indexOf("msie 9.0")>0,K=J&&J.indexOf("edge/")>0,Q=(J&&J.indexOf("android"),J&&/iphone|ipad|ipod|ios/.test(J)||"ios"===q),nn=(J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\/(\d+)/)),tn={}.watch,en=!1;if(V)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===$&&($=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),$},an=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);cn="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var ln=k,pn=0,dn=function(){this.id=pn++,this.subs=[]};dn.prototype.addSub=function(n){this.subs.push(n)},dn.prototype.removeSub=function(n){y(this.subs,n)},dn.prototype.depend=function(){dn.target&&dn.target.addDep(this)},dn.prototype.notify=function(){var n=this.subs.slice();for(var t=0,e=n.length;t<e;t++)n[t].update()},dn.target=null;var fn=[];function hn(n){fn.push(n),dn.target=n}function mn(){fn.pop(),dn.target=fn[fn.length-1]}var vn=function(n,t,e,r,i,o,a,s){this.tag=n,this.data=t,this.children=e,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,gn);var bn=function(n){void 0===n&&(n="");var t=new vn;return t.text=n,t.isComment=!0,t};function yn(n){return new vn(void 0,void 0,void 0,String(n))}function xn(n){var t=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return t.ns=n.ns,t.isStatic=n.isStatic,t.key=n.key,t.isComment=n.isComment,t.fnContext=n.fnContext,t.fnOptions=n.fnOptions,t.fnScopeId=n.fnScopeId,t.asyncMeta=n.asyncMeta,t.isCloned=!0,t}var An=Array.prototype,Cn=Object.create(An);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var t=An[n];X(Cn,n,(function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];var i,o=t.apply(this,e),a=this.__ob__;switch(n){case"push":case"unshift":i=e;break;case"splice":i=e.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o}))}));var Sn=Object.getOwnPropertyNames(Cn),wn=!0;function In(n){wn=n}var En=function(n){this.value=n,this.dep=new dn,this.vmCount=0,X(n,"__ob__",this),Array.isArray(n)?(W?function(n,t){n.__proto__=t}(n,Cn):function(n,t,e){for(var r=0,i=e.length;r<i;r++){var o=e[r];X(n,o,t[o])}}(n,Cn,Sn),this.observeArray(n)):this.walk(n)};function Pn(n,t){var e;if(u(n)&&!(n instanceof vn))return A(n,"__ob__")&&n.__ob__ instanceof En?e=n.__ob__:wn&&!on()&&(Array.isArray(n)||p(n))&&Object.isExtensible(n)&&!n._isVue&&(e=new En(n)),t&&e&&e.vmCount++,e}function _n(n,t,e,r,i){var o=new dn,a=Object.getOwnPropertyDescriptor(n,t);if(!a||!1!==a.configurable){var s=a&&a.get,c=a&&a.set;s&&!c||2!==arguments.length||(e=n[t]);var u=!i&&Pn(e);Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var t=s?s.call(n):e;return dn.target&&(o.depend(),u&&(u.dep.depend(),Array.isArray(t)&&Tn(t))),t},set:function(t){var r=s?s.call(n):e;t===r||t!=t&&r!=r||s&&!c||(c?c.call(n,t):e=t,u=!i&&Pn(t),o.notify())}})}}function On(n,t,e){if(Array.isArray(n)&&f(t))return n.length=Math.max(n.length,t),n.splice(t,1,e),e;if(t in n&&!(t in Object.prototype))return n[t]=e,e;var r=n.__ob__;return n._isVue||r&&r.vmCount?e:r?(_n(r.value,t,e),r.dep.notify(),e):(n[t]=e,e)}function Dn(n,t){if(Array.isArray(n)&&f(t))n.splice(t,1);else{var e=n.__ob__;n._isVue||e&&e.vmCount||A(n,t)&&(delete n[t],e&&e.dep.notify())}}function Tn(n){for(var t=void 0,e=0,r=n.length;e<r;e++)(t=n[e])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Tn(t)}En.prototype.walk=function(n){for(var t=Object.keys(n),e=0;e<t.length;e++)_n(n,t[e])},En.prototype.observeArray=function(n){for(var t=0,e=n.length;t<e;t++)Pn(n[t])};var kn=z.optionMergeStrategies;function Bn(n,t){if(!t)return n;for(var e,r,i,o=un?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++)"__ob__"!==(e=o[a])&&(r=n[e],i=t[e],A(n,e)?r!==i&&p(r)&&p(i)&&Bn(r,i):On(n,e,i));return n}function jn(n,t,e){return e?function(){var r="function"==typeof t?t.call(e,e):t,i="function"==typeof n?n.call(e,e):n;return r?Bn(r,i):i}:t?n?function(){return Bn("function"==typeof t?t.call(this,this):t,"function"==typeof n?n.call(this,this):n)}:t:n}function Un(n,t){var e=t?n?n.concat(t):Array.isArray(t)?t:[t]:n;return e?function(n){for(var t=[],e=0;e<n.length;e++)-1===t.indexOf(n[e])&&t.push(n[e]);return t}(e):e}function Ln(n,t,e,r){var i=Object.create(n||null);return t?D(i,t):i}kn.data=function(n,t,e){return e?jn(n,t,e):t&&"function"!=typeof t?n:jn(n,t)},M.forEach((function(n){kn[n]=Un})),F.forEach((function(n){kn[n+"s"]=Ln})),kn.watch=function(n,t,e,r){if(n===tn&&(n=void 0),t===tn&&(t=void 0),!t)return Object.create(n||null);if(!n)return t;var i={};for(var o in D(i,n),t){var a=i[o],s=t[o];a&&!Array.isArray(a)&&(a=[a]),i[o]=a?a.concat(s):Array.isArray(s)?s:[s]}return i},kn.props=kn.methods=kn.inject=kn.computed=function(n,t,e,r){if(!n)return t;var i=Object.create(null);return D(i,n),t&&D(i,t),i},kn.provide=jn;var Rn=function(n,t){return void 0===t?n:t};function Fn(n,t,e){if("function"==typeof t&&(t=t.options),function(n,t){var e=n.props;if(e){var r,i,o={};if(Array.isArray(e))for(r=e.length;r--;)"string"==typeof(i=e[r])&&(o[w(i)]={type:null});else if(p(e))for(var a in e)i=e[a],o[w(a)]=p(i)?i:{type:i};else 0;n.props=o}}(t),function(n,t){var e=n.inject;if(e){var r=n.inject={};if(Array.isArray(e))for(var i=0;i<e.length;i++)r[e[i]]={from:e[i]};else if(p(e))for(var o in e){var a=e[o];r[o]=p(a)?D({from:o},a):{from:a}}else 0}}(t),function(n){var t=n.directives;if(t)for(var e in t){var r=t[e];"function"==typeof r&&(t[e]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(n=Fn(n,t.extends,e)),t.mixins))for(var r=0,i=t.mixins.length;r<i;r++)n=Fn(n,t.mixins[r],e);var o,a={};for(o in n)s(o);for(o in t)A(n,o)||s(o);function s(r){var i=kn[r]||Rn;a[r]=i(n[r],t[r],e,r)}return a}function Mn(n,t,e,r){if("string"==typeof e){var i=n[t];if(A(i,e))return i[e];var o=w(e);if(A(i,o))return i[o];var a=I(o);return A(i,a)?i[a]:i[e]||i[o]||i[a]}}function zn(n,t,e,r){var i=t[n],o=!A(e,n),a=e[n],s=$n(Boolean,i.type);if(s>-1)if(o&&!A(i,"default"))a=!1;else if(""===a||a===P(n)){var c=$n(String,i.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(n,t,e){if(!A(t,"default"))return;var r=t.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[e]&&void 0!==n._props[e])return n._props[e];return"function"==typeof r&&"Function"!==Xn(t.type)?r.call(n):r}(r,i,n);var u=wn;In(!0),Pn(a),In(u)}return a}var Nn=/^\s*function (\w+)/;function Xn(n){var t=n&&n.toString().match(Nn);return t?t[1]:""}function Hn(n,t){return Xn(n)===Xn(t)}function $n(n,t){if(!Array.isArray(t))return Hn(t,n)?0:-1;for(var e=0,r=t.length;e<r;e++)if(Hn(t[e],n))return e;return-1}function Wn(n,t,e){hn();try{if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,n,t,e))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,t,e)}finally{mn()}}function Vn(n,t,e,r,i){var o;try{(o=e?n.apply(t,e):n.call(t))&&!o._isVue&&h(o)&&!o._handled&&(o.catch((function(n){return Wn(n,r,i+" (Promise/async)")})),o._handled=!0)}catch(n){Wn(n,r,i)}return o}function Gn(n,t,e){if(z.errorHandler)try{return z.errorHandler.call(null,n,t,e)}catch(t){t!==n&&qn(t,null,"config.errorHandler")}qn(n,t,e)}function qn(n,t,e){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Jn,Yn=!1,Zn=[],Kn=!1;function Qn(){Kn=!1;var n=Zn.slice(0);Zn.length=0;for(var t=0;t<n.length;t++)n[t]()}if("undefined"!=typeof Promise&&sn(Promise)){var nt=Promise.resolve();Jn=function(){nt.then(Qn),Q&&setTimeout(k)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Jn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var tt=1,et=new MutationObserver(Qn),rt=document.createTextNode(String(tt));et.observe(rt,{characterData:!0}),Jn=function(){tt=(tt+1)%2,rt.data=String(tt)},Yn=!0}function it(n,t){var e;if(Zn.push((function(){if(n)try{n.call(t)}catch(n){Wn(n,t,"nextTick")}else e&&e(t)})),Kn||(Kn=!0,Jn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){e=n}))}var ot=new cn;function at(n){!function n(t,e){var r,i,o=Array.isArray(t);if(!o&&!u(t)||Object.isFrozen(t)||t instanceof vn)return;if(t.__ob__){var a=t.__ob__.dep.id;if(e.has(a))return;e.add(a)}if(o)for(r=t.length;r--;)n(t[r],e);else for(i=Object.keys(t),r=i.length;r--;)n(t[i[r]],e)}(n,ot),ot.clear()}var st=C((function(n){var t="&"===n.charAt(0),e="~"===(n=t?n.slice(1):n).charAt(0),r="!"===(n=e?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:e,capture:r,passive:t}}));function ct(n,t){function e(){var n=arguments,r=e.fns;if(!Array.isArray(r))return Vn(r,null,arguments,t,"v-on handler");for(var i=r.slice(),o=0;o<i.length;o++)Vn(i[o],null,n,t,"v-on handler")}return e.fns=n,e}function ut(n,t,e,r,i,a){var c,u,l,p;for(c in n)u=n[c],l=t[c],p=st(c),o(u)||(o(l)?(o(u.fns)&&(u=n[c]=ct(u,a)),s(p.once)&&(u=n[c]=i(p.name,u,p.capture)),e(p.name,u,p.capture,p.passive,p.params)):u!==l&&(l.fns=u,n[c]=l));for(c in t)o(n[c])&&r((p=st(c)).name,t[c],p.capture)}function lt(n,t,e){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[t];function c(){e.apply(this,arguments),y(r.fns,c)}o(i)?r=ct([c]):a(i.fns)&&s(i.merged)?(r=i).fns.push(c):r=ct([i,c]),r.merged=!0,n[t]=r}function pt(n,t,e,r,i){if(a(t)){if(A(t,e))return n[e]=t[e],i||delete t[e],!0;if(A(t,r))return n[e]=t[r],i||delete t[r],!0}return!1}function dt(n){return c(n)?[yn(n)]:Array.isArray(n)?function n(t,e){var r,i,u,l,p=[];for(r=0;r<t.length;r++)o(i=t[r])||"boolean"==typeof i||(u=p.length-1,l=p[u],Array.isArray(i)?i.length>0&&(ft((i=n(i,(e||"")+"_"+r))[0])&&ft(l)&&(p[u]=yn(l.text+i[0].text),i.shift()),p.push.apply(p,i)):c(i)?ft(l)?p[u]=yn(l.text+i):""!==i&&p.push(yn(i)):ft(i)&&ft(l)?p[u]=yn(l.text+i.text):(s(t._isVList)&&a(i.tag)&&o(i.key)&&a(e)&&(i.key="__vlist"+e+"_"+r+"__"),p.push(i)));return p}(n):void 0}function ft(n){return a(n)&&a(n.text)&&!1===n.isComment}function ht(n,t){if(n){for(var e=Object.create(null),r=un?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){for(var a=n[o].from,s=t;s;){if(s._provided&&A(s._provided,a)){e[o]=s._provided[a];break}s=s.$parent}if(!s)if("default"in n[o]){var c=n[o].default;e[o]="function"==typeof c?c.call(t):c}else 0}}return e}}function mt(n,t){if(!n||!n.length)return{};for(var e={},r=0,i=n.length;r<i;r++){var o=n[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==t&&o.fnContext!==t||!a||null==a.slot)(e.default||(e.default=[])).push(o);else{var s=a.slot,c=e[s]||(e[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var u in e)e[u].every(vt)&&delete e[u];return e}function vt(n){return n.isComment&&!n.asyncFactory||" "===n.text}function gt(n){return n.isComment&&n.asyncFactory}function bt(n,t,e){var r,o=Object.keys(t).length>0,a=n?!!n.$stable:!o,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(a&&e&&e!==i&&s===e.$key&&!o&&!e.$hasNormal)return e;for(var c in r={},n)n[c]&&"$"!==c[0]&&(r[c]=yt(t,c,n[c]))}else r={};for(var u in t)u in r||(r[u]=xt(t,u));return n&&Object.isExtensible(n)&&(n._normalized=r),X(r,"$stable",a),X(r,"$key",s),X(r,"$hasNormal",o),r}function yt(n,t,e){var r=function(){var n=arguments.length?e.apply(null,arguments):e({}),t=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:dt(n))&&n[0];return n&&(!t||1===n.length&&t.isComment&&!gt(t))?void 0:n};return e.proxy&&Object.defineProperty(n,t,{get:r,enumerable:!0,configurable:!0}),r}function xt(n,t){return function(){return n[t]}}function At(n,t){var e,r,i,o,s;if(Array.isArray(n)||"string"==typeof n)for(e=new Array(n.length),r=0,i=n.length;r<i;r++)e[r]=t(n[r],r);else if("number"==typeof n)for(e=new Array(n),r=0;r<n;r++)e[r]=t(r+1,r);else if(u(n))if(un&&n[Symbol.iterator]){e=[];for(var c=n[Symbol.iterator](),l=c.next();!l.done;)e.push(t(l.value,e.length)),l=c.next()}else for(o=Object.keys(n),e=new Array(o.length),r=0,i=o.length;r<i;r++)s=o[r],e[r]=t(n[s],s,r);return a(e)||(e=[]),e._isVList=!0,e}function Ct(n,t,e,r){var i,o=this.$scopedSlots[n];o?(e=e||{},r&&(e=D(D({},r),e)),i=o(e)||("function"==typeof t?t():t)):i=this.$slots[n]||("function"==typeof t?t():t);var a=e&&e.slot;return a?this.$createElement("template",{slot:a},i):i}function St(n){return Mn(this.$options,"filters",n)||j}function wt(n,t){return Array.isArray(n)?-1===n.indexOf(t):n!==t}function It(n,t,e,r,i){var o=z.keyCodes[t]||e;return i&&r&&!z.keyCodes[t]?wt(i,r):o?wt(o,n):r?P(r)!==t:void 0===n}function Et(n,t,e,r,i){if(e)if(u(e)){var o;Array.isArray(e)&&(e=T(e));var a=function(a){if("class"===a||"style"===a||b(a))o=n;else{var s=n.attrs&&n.attrs.type;o=r||z.mustUseProp(t,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=w(a),u=P(a);c in o||u in o||(o[a]=e[a],i&&((n.on||(n.on={}))["update:"+a]=function(n){e[a]=n}))};for(var s in e)a(s)}else;return n}function Pt(n,t){var e=this._staticTrees||(this._staticTrees=[]),r=e[n];return r&&!t||Ot(r=e[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function _t(n,t,e){return Ot(n,"__once__"+t+(e?"_"+e:""),!0),n}function Ot(n,t,e){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Dt(n[r],t+"_"+r,e);else Dt(n,t,e)}function Dt(n,t,e){n.isStatic=!0,n.key=t,n.isOnce=e}function Tt(n,t){if(t)if(p(t)){var e=n.on=n.on?D({},n.on):{};for(var r in t){var i=e[r],o=t[r];e[r]=i?[].concat(i,o):o}}else;return n}function kt(n,t,e,r){t=t||{$stable:!e};for(var i=0;i<n.length;i++){var o=n[i];Array.isArray(o)?kt(o,t,e):o&&(o.proxy&&(o.fn.proxy=!0),t[o.key]=o.fn)}return r&&(t.$key=r),t}function Bt(n,t){for(var e=0;e<t.length;e+=2){var r=t[e];"string"==typeof r&&r&&(n[t[e]]=t[e+1])}return n}function jt(n,t){return"string"==typeof n?t+n:n}function Ut(n){n._o=_t,n._n=v,n._s=m,n._l=At,n._t=Ct,n._q=U,n._i=L,n._m=Pt,n._f=St,n._k=It,n._b=Et,n._v=yn,n._e=bn,n._u=kt,n._g=Tt,n._d=Bt,n._p=jt}function Lt(n,t,e,r,o){var a,c=this,u=o.options;A(r,"_uid")?(a=Object.create(r))._original=r:(a=r,r=r._original);var l=s(u._compiled),p=!l;this.data=n,this.props=t,this.children=e,this.parent=r,this.listeners=n.on||i,this.injections=ht(u.inject,r),this.slots=function(){return c.$slots||bt(n.scopedSlots,c.$slots=mt(e,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return bt(n.scopedSlots,this.slots())}}),l&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=bt(n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,t,e,i){var o=Ht(a,n,t,e,i,p);return o&&!Array.isArray(o)&&(o.fnScopeId=u._scopeId,o.fnContext=r),o}:this._c=function(n,t,e,r){return Ht(a,n,t,e,r,p)}}function Rt(n,t,e,r,i){var o=xn(n);return o.fnContext=e,o.fnOptions=r,t.slot&&((o.data||(o.data={})).slot=t.slot),o}function Ft(n,t){for(var e in t)n[w(e)]=t[e]}Ut(Lt.prototype);var Mt={init:function(n,t){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var e=n;Mt.prepatch(e,e)}else{(n.componentInstance=function(n,t){var e={_isComponent:!0,_parentVnode:n,parent:t},r=n.data.inlineTemplate;a(r)&&(e.render=r.render,e.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(e)}(n,Kt)).$mount(t?n.elm:void 0,t)}},prepatch:function(n,t){var e=t.componentOptions;!function(n,t,e,r,o){0;var a=r.data.scopedSlots,s=n.$scopedSlots,c=!!(a&&!a.$stable||s!==i&&!s.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),u=!!(o||n.$options._renderChildren||c);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=o,n.$attrs=r.data.attrs||i,n.$listeners=e||i,t&&n.$options.props){In(!1);for(var l=n._props,p=n.$options._propKeys||[],d=0;d<p.length;d++){var f=p[d],h=n.$options.props;l[f]=zn(f,h,t,n)}In(!0),n.$options.propsData=t}e=e||i;var m=n.$options._parentListeners;n.$options._parentListeners=e,Zt(n,e,m),u&&(n.$slots=mt(o,r.context),n.$forceUpdate());0}(t.componentInstance=n.componentInstance,e.propsData,e.listeners,t,e.children)},insert:function(n){var t,e=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,ee(r,"mounted")),n.data.keepAlive&&(e._isMounted?((t=r)._inactive=!1,ie.push(t)):te(r,!0))},destroy:function(n){var t=n.componentInstance;t._isDestroyed||(n.data.keepAlive?function n(t,e){if(e&&(t._directInactive=!0,ne(t)))return;if(!t._inactive){t._inactive=!0;for(var r=0;r<t.$children.length;r++)n(t.$children[r]);ee(t,"deactivated")}}(t,!0):t.$destroy())}},zt=Object.keys(Mt);function Nt(n,t,e,r,c){if(!o(n)){var l=e.$options._base;if(u(n)&&(n=l.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,t){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var e=Wt;e&&a(n.owners)&&-1===n.owners.indexOf(e)&&n.owners.push(e);if(s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(e&&!a(n.owners)){var r=n.owners=[e],i=!0,c=null,l=null;e.$on("hook:destroyed",(function(){return y(r,e)}));var p=function(n){for(var t=0,e=r.length;t<e;t++)r[t].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},d=R((function(e){n.resolved=Vt(e,t),i?r.length=0:p(!0)})),f=R((function(t){a(n.errorComp)&&(n.error=!0,p(!0))})),m=n(d,f);return u(m)&&(h(m)?o(n.resolved)&&m.then(d,f):h(m.component)&&(m.component.then(d,f),a(m.error)&&(n.errorComp=Vt(m.error,t)),a(m.loading)&&(n.loadingComp=Vt(m.loading,t),0===m.delay?n.loading=!0:c=setTimeout((function(){c=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),a(m.timeout)&&(l=setTimeout((function(){l=null,o(n.resolved)&&f(null)}),m.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,l)))return function(n,t,e,r,i){var o=bn();return o.asyncFactory=n,o.asyncMeta={data:t,context:e,children:r,tag:i},o}(p,t,e,r,c);t=t||{},we(n),a(t.model)&&function(n,t){var e=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(t.attrs||(t.attrs={}))[e]=t.model.value;var i=t.on||(t.on={}),o=i[r],s=t.model.callback;a(o)?(Array.isArray(o)?-1===o.indexOf(s):o!==s)&&(i[r]=[s].concat(o)):i[r]=s}(n.options,t);var d=function(n,t,e){var r=t.options.props;if(!o(r)){var i={},s=n.attrs,c=n.props;if(a(s)||a(c))for(var u in r){var l=P(u);pt(i,c,u,l,!0)||pt(i,s,u,l,!1)}return i}}(t,n);if(s(n.options.functional))return function(n,t,e,r,o){var s=n.options,c={},u=s.props;if(a(u))for(var l in u)c[l]=zn(l,u,t||i);else a(e.attrs)&&Ft(c,e.attrs),a(e.props)&&Ft(c,e.props);var p=new Lt(e,c,o,r,n),d=s.render.call(null,p._c,p);if(d instanceof vn)return Rt(d,e,p.parent,s,p);if(Array.isArray(d)){for(var f=dt(d)||[],h=new Array(f.length),m=0;m<f.length;m++)h[m]=Rt(f[m],e,p.parent,s,p);return h}}(n,d,t,e,r);var f=t.on;if(t.on=t.nativeOn,s(n.options.abstract)){var m=t.slot;t={},m&&(t.slot=m)}!function(n){for(var t=n.hook||(n.hook={}),e=0;e<zt.length;e++){var r=zt[e],i=t[r],o=Mt[r];i===o||i&&i._merged||(t[r]=i?Xt(o,i):o)}}(t);var v=n.options.name||c;return new vn("vue-component-"+n.cid+(v?"-"+v:""),t,void 0,void 0,void 0,e,{Ctor:n,propsData:d,listeners:f,tag:c,children:r},p)}}}function Xt(n,t){var e=function(e,r){n(e,r),t(e,r)};return e._merged=!0,e}function Ht(n,t,e,r,i,l){return(Array.isArray(e)||c(e))&&(i=r,r=e,e=void 0),s(l)&&(i=2),function(n,t,e,r,i){if(a(e)&&a(e.__ob__))return bn();a(e)&&a(e.is)&&(t=e.is);if(!t)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((e=e||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=dt(r):1===i&&(r=function(n){for(var t=0;t<n.length;t++)if(Array.isArray(n[t]))return Array.prototype.concat.apply([],n);return n}(r));var c,l;if("string"==typeof t){var p;l=n.$vnode&&n.$vnode.ns||z.getTagNamespace(t),c=z.isReservedTag(t)?new vn(z.parsePlatformTagName(t),e,r,void 0,void 0,n):e&&e.pre||!a(p=Mn(n.$options,"components",t))?new vn(t,e,r,void 0,void 0,n):Nt(p,e,n,r,t)}else c=Nt(t,e,n,r);return Array.isArray(c)?c:a(c)?(a(l)&&function n(t,e,r){t.ns=e,"foreignObject"===t.tag&&(e=void 0,r=!0);if(a(t.children))for(var i=0,c=t.children.length;i<c;i++){var u=t.children[i];a(u.tag)&&(o(u.ns)||s(r)&&"svg"!==u.tag)&&n(u,e,r)}}(c,l),a(e)&&function(n){u(n.style)&&at(n.style);u(n.class)&&at(n.class)}(e),c):bn()}(n,t,e,r,i)}var $t,Wt=null;function Vt(n,t){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?t.extend(n):n}function Gt(n){if(Array.isArray(n))for(var t=0;t<n.length;t++){var e=n[t];if(a(e)&&(a(e.componentOptions)||gt(e)))return e}}function qt(n,t){$t.$on(n,t)}function Jt(n,t){$t.$off(n,t)}function Yt(n,t){var e=$t;return function r(){var i=t.apply(null,arguments);null!==i&&e.$off(n,r)}}function Zt(n,t,e){$t=n,ut(t,e||{},qt,Jt,Yt,n),$t=void 0}var Kt=null;function Qt(n){var t=Kt;return Kt=n,function(){Kt=t}}function ne(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function te(n,t){if(t){if(n._directInactive=!1,ne(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var e=0;e<n.$children.length;e++)te(n.$children[e]);ee(n,"activated")}}function ee(n,t){hn();var e=n.$options[t],r=t+" hook";if(e)for(var i=0,o=e.length;i<o;i++)Vn(e[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+t),mn()}var re=[],ie=[],oe={},ae=!1,se=!1,ce=0;var ue=0,le=Date.now;if(V&&!Y){var pe=window.performance;pe&&"function"==typeof pe.now&&le()>document.createEvent("Event").timeStamp&&(le=function(){return pe.now()})}function de(){var n,t;for(ue=le(),se=!0,re.sort((function(n,t){return n.id-t.id})),ce=0;ce<re.length;ce++)(n=re[ce]).before&&n.before(),t=n.id,oe[t]=null,n.run();var e=ie.slice(),r=re.slice();ce=re.length=ie.length=0,oe={},ae=se=!1,function(n){for(var t=0;t<n.length;t++)n[t]._inactive=!0,te(n[t],!0)}(e),function(n){var t=n.length;for(;t--;){var e=n[t],r=e.vm;r._watcher===e&&r._isMounted&&!r._isDestroyed&&ee(r,"updated")}}(r),an&&z.devtools&&an.emit("flush")}var fe=0,he=function(n,t,e,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=e,this.id=++fe,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(n){if(!H.test(n)){var t=n.split(".");return function(n){for(var e=0;e<t.length;e++){if(!n)return;n=n[t[e]]}return n}}}(t),this.getter||(this.getter=k)),this.value=this.lazy?void 0:this.get()};he.prototype.get=function(){var n;hn(this);var t=this.vm;try{n=this.getter.call(t,t)}catch(n){if(!this.user)throw n;Wn(n,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&at(n),mn(),this.cleanupDeps()}return n},he.prototype.addDep=function(n){var t=n.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(n),this.depIds.has(t)||n.addSub(this))},he.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var t=this.deps[n];this.newDepIds.has(t.id)||t.removeSub(this)}var e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0},he.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var t=n.id;if(null==oe[t]){if(oe[t]=!0,se){for(var e=re.length-1;e>ce&&re[e].id>n.id;)e--;re.splice(e+1,0,n)}else re.push(n);ae||(ae=!0,it(de))}}(this)},he.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var t=this.value;if(this.value=n,this.user){var e='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,t],this.vm,e)}else this.cb.call(this.vm,n,t)}}},he.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},he.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},he.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var me={enumerable:!0,configurable:!0,get:k,set:k};function ve(n,t,e){me.get=function(){return this[t][e]},me.set=function(n){this[t][e]=n},Object.defineProperty(n,e,me)}function ge(n){n._watchers=[];var t=n.$options;t.props&&function(n,t){var e=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&In(!1);var o=function(o){i.push(o);var a=zn(o,t,e,n);_n(r,o,a),o in n||ve(n,"_props",o)};for(var a in t)o(a);In(!0)}(n,t.props),t.methods&&function(n,t){n.$options.props;for(var e in t)n[e]="function"!=typeof t[e]?k:_(t[e],n)}(n,t.methods),t.data?function(n){var t=n.$options.data;p(t=n._data="function"==typeof t?function(n,t){hn();try{return n.call(t,t)}catch(n){return Wn(n,t,"data()"),{}}finally{mn()}}(t,n):t||{})||(t={});var e=Object.keys(t),r=n.$options.props,i=(n.$options.methods,e.length);for(;i--;){var o=e[i];0,r&&A(r,o)||(a=void 0,36!==(a=(o+"").charCodeAt(0))&&95!==a&&ve(n,"_data",o))}var a;Pn(t,!0)}(n):Pn(n._data={},!0),t.computed&&function(n,t){var e=n._computedWatchers=Object.create(null),r=on();for(var i in t){var o=t[i],a="function"==typeof o?o:o.get;0,r||(e[i]=new he(n,a||k,k,be)),i in n||ye(n,i,o)}}(n,t.computed),t.watch&&t.watch!==tn&&function(n,t){for(var e in t){var r=t[e];if(Array.isArray(r))for(var i=0;i<r.length;i++)Ce(n,e,r[i]);else Ce(n,e,r)}}(n,t.watch)}var be={lazy:!0};function ye(n,t,e){var r=!on();"function"==typeof e?(me.get=r?xe(t):Ae(e),me.set=k):(me.get=e.get?r&&!1!==e.cache?xe(t):Ae(e.get):k,me.set=e.set||k),Object.defineProperty(n,t,me)}function xe(n){return function(){var t=this._computedWatchers&&this._computedWatchers[n];if(t)return t.dirty&&t.evaluate(),dn.target&&t.depend(),t.value}}function Ae(n){return function(){return n.call(this,this)}}function Ce(n,t,e,r){return p(e)&&(r=e,e=e.handler),"string"==typeof e&&(e=n[e]),n.$watch(t,e,r)}var Se=0;function we(n){var t=n.options;if(n.super){var e=we(n.super);if(e!==n.superOptions){n.superOptions=e;var r=function(n){var t,e=n.options,r=n.sealedOptions;for(var i in e)e[i]!==r[i]&&(t||(t={}),t[i]=e[i]);return t}(n);r&&D(n.extendOptions,r),(t=n.options=Fn(e,n.extendOptions)).name&&(t.components[t.name]=n)}}return t}function Ie(n){this._init(n)}function Ee(n){n.cid=0;var t=1;n.extend=function(n){n=n||{};var e=this,r=e.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var o=n.name||e.options.name;var a=function(n){this._init(n)};return(a.prototype=Object.create(e.prototype)).constructor=a,a.cid=t++,a.options=Fn(e.options,n),a.super=e,a.options.props&&function(n){var t=n.options.props;for(var e in t)ve(n.prototype,"_props",e)}(a),a.options.computed&&function(n){var t=n.options.computed;for(var e in t)ye(n.prototype,e,t[e])}(a),a.extend=e.extend,a.mixin=e.mixin,a.use=e.use,F.forEach((function(n){a[n]=e[n]})),o&&(a.options.components[o]=a),a.superOptions=e.options,a.extendOptions=n,a.sealedOptions=D({},a.options),i[r]=a,a}}function Pe(n){return n&&(n.Ctor.options.name||n.tag)}function _e(n,t){return Array.isArray(n)?n.indexOf(t)>-1:"string"==typeof n?n.split(",").indexOf(t)>-1:!!d(n)&&n.test(t)}function Oe(n,t){var e=n.cache,r=n.keys,i=n._vnode;for(var o in e){var a=e[o];if(a){var s=a.name;s&&!t(s)&&De(e,o,r,i)}}}function De(n,t,e,r){var i=n[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[t]=null,y(e,t)}!function(n){n.prototype._init=function(n){var t=this;t._uid=Se++,t._isVue=!0,n&&n._isComponent?function(n,t){var e=n.$options=Object.create(n.constructor.options),r=t._parentVnode;e.parent=t.parent,e._parentVnode=r;var i=r.componentOptions;e.propsData=i.propsData,e._parentListeners=i.listeners,e._renderChildren=i.children,e._componentTag=i.tag,t.render&&(e.render=t.render,e.staticRenderFns=t.staticRenderFns)}(t,n):t.$options=Fn(we(t.constructor),n||{},t),t._renderProxy=t,t._self=t,function(n){var t=n.$options,e=t.parent;if(e&&!t.abstract){for(;e.$options.abstract&&e.$parent;)e=e.$parent;e.$children.push(n)}n.$parent=e,n.$root=e?e.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(t),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var t=n.$options._parentListeners;t&&Zt(n,t)}(t),function(n){n._vnode=null,n._staticTrees=null;var t=n.$options,e=n.$vnode=t._parentVnode,r=e&&e.context;n.$slots=mt(t._renderChildren,r),n.$scopedSlots=i,n._c=function(t,e,r,i){return Ht(n,t,e,r,i,!1)},n.$createElement=function(t,e,r,i){return Ht(n,t,e,r,i,!0)};var o=e&&e.data;_n(n,"$attrs",o&&o.attrs||i,null,!0),_n(n,"$listeners",t._parentListeners||i,null,!0)}(t),ee(t,"beforeCreate"),function(n){var t=ht(n.$options.inject,n);t&&(In(!1),Object.keys(t).forEach((function(e){_n(n,e,t[e])})),In(!0))}(t),ge(t),function(n){var t=n.$options.provide;t&&(n._provided="function"==typeof t?t.call(n):t)}(t),ee(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(Ie),function(n){var t={get:function(){return this._data}},e={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",t),Object.defineProperty(n.prototype,"$props",e),n.prototype.$set=On,n.prototype.$delete=Dn,n.prototype.$watch=function(n,t,e){if(p(t))return Ce(this,n,t,e);(e=e||{}).user=!0;var r=new he(this,n,t,e);if(e.immediate){var i='callback for immediate watcher "'+r.expression+'"';hn(),Vn(t,this,[r.value],this,i),mn()}return function(){r.teardown()}}}(Ie),function(n){var t=/^hook:/;n.prototype.$on=function(n,e){var r=this;if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],e);else(r._events[n]||(r._events[n]=[])).push(e),t.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,t){var e=this;function r(){e.$off(n,r),t.apply(e,arguments)}return r.fn=t,e.$on(n,r),e},n.prototype.$off=function(n,t){var e=this;if(!arguments.length)return e._events=Object.create(null),e;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)e.$off(n[r],t);return e}var o,a=e._events[n];if(!a)return e;if(!t)return e._events[n]=null,e;for(var s=a.length;s--;)if((o=a[s])===t||o.fn===t){a.splice(s,1);break}return e},n.prototype.$emit=function(n){var t=this,e=t._events[n];if(e){e=e.length>1?O(e):e;for(var r=O(arguments,1),i='event handler for "'+n+'"',o=0,a=e.length;o<a;o++)Vn(e[o],t,r,t,i)}return t}}(Ie),function(n){n.prototype._update=function(n,t){var e=this,r=e.$el,i=e._vnode,o=Qt(e);e._vnode=n,e.$el=i?e.__patch__(i,n):e.__patch__(e.$el,n,t,!1),o(),r&&(r.__vue__=null),e.$el&&(e.$el.__vue__=e),e.$vnode&&e.$parent&&e.$vnode===e.$parent._vnode&&(e.$parent.$el=e.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){ee(n,"beforeDestroy"),n._isBeingDestroyed=!0;var t=n.$parent;!t||t._isBeingDestroyed||n.$options.abstract||y(t.$children,n),n._watcher&&n._watcher.teardown();for(var e=n._watchers.length;e--;)n._watchers[e].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),ee(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ie),function(n){Ut(n.prototype),n.prototype.$nextTick=function(n){return it(n,this)},n.prototype._render=function(){var n,t=this,e=t.$options,r=e.render,i=e._parentVnode;i&&(t.$scopedSlots=bt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Wt=t,n=r.call(t._renderProxy,t.$createElement)}catch(e){Wn(e,t,"render"),n=t._vnode}finally{Wt=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=bn()),n.parent=i,n}}(Ie);var Te=[String,RegExp,Array],ke={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Te,exclude:Te,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,t=this.keys,e=this.vnodeToCache,r=this.keyToCache;if(e){var i=e.tag,o=e.componentInstance,a=e.componentOptions;n[r]={name:Pe(a),tag:i,componentInstance:o},t.push(r),this.max&&t.length>parseInt(this.max)&&De(n,t[0],t,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)De(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(t){Oe(n,(function(n){return _e(t,n)}))})),this.$watch("exclude",(function(t){Oe(n,(function(n){return!_e(t,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,t=Gt(n),e=t&&t.componentOptions;if(e){var r=Pe(e),i=this.include,o=this.exclude;if(i&&(!r||!_e(i,r))||o&&r&&_e(o,r))return t;var a=this.cache,s=this.keys,c=null==t.key?e.Ctor.cid+(e.tag?"::"+e.tag:""):t.key;a[c]?(t.componentInstance=a[c].componentInstance,y(s,c),s.push(c)):(this.vnodeToCache=t,this.keyToCache=c),t.data.keepAlive=!0}return t||n&&n[0]}}};!function(n){var t={get:function(){return z}};Object.defineProperty(n,"config",t),n.util={warn:ln,extend:D,mergeOptions:Fn,defineReactive:_n},n.set=On,n.delete=Dn,n.nextTick=it,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),F.forEach((function(t){n.options[t+"s"]=Object.create(null)})),n.options._base=n,D(n.options.components,ke),function(n){n.use=function(n){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(n)>-1)return this;var e=O(arguments,1);return e.unshift(this),"function"==typeof n.install?n.install.apply(n,e):"function"==typeof n&&n.apply(null,e),t.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Fn(this.options,n),this}}(n),Ee(n),function(n){F.forEach((function(t){n[t]=function(n,e){return e?("component"===t&&p(e)&&(e.name=e.name||n,e=this.options._base.extend(e)),"directive"===t&&"function"==typeof e&&(e={bind:e,update:e}),this.options[t+"s"][n]=e,e):this.options[t+"s"][n]}}))}(n)}(Ie),Object.defineProperty(Ie.prototype,"$isServer",{get:on}),Object.defineProperty(Ie.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ie,"FunctionalRenderContext",{value:Lt}),Ie.version="2.6.14";var Be=g("style,class"),je=g("input,textarea,option,select,progress"),Ue=g("contenteditable,draggable,spellcheck"),Le=g("events,caret,typing,plaintext-only"),Re=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Fe="http://www.w3.org/1999/xlink",Me=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ze=function(n){return Me(n)?n.slice(6,n.length):""},Ne=function(n){return null==n||!1===n};function Xe(n){for(var t=n.data,e=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(t=He(r.data,t));for(;a(e=e.parent);)e&&e.data&&(t=He(t,e.data));return function(n,t){if(a(n)||a(t))return $e(n,We(t));return""}(t.staticClass,t.class)}function He(n,t){return{staticClass:$e(n.staticClass,t.staticClass),class:a(n.class)?[n.class,t.class]:t.class}}function $e(n,t){return n?t?n+" "+t:n:t||""}function We(n){return Array.isArray(n)?function(n){for(var t,e="",r=0,i=n.length;r<i;r++)a(t=We(n[r]))&&""!==t&&(e&&(e+=" "),e+=t);return e}(n):u(n)?function(n){var t="";for(var e in n)n[e]&&(t&&(t+=" "),t+=e);return t}(n):"string"==typeof n?n:""}var Ve={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Ge=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),qe=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Je=function(n){return Ge(n)||qe(n)};var Ye=Object.create(null);var Ze=g("text,number,password,search,email,tel,url");var Ke=Object.freeze({createElement:function(n,t){var e=document.createElement(n);return"select"!==n||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&e.setAttribute("multiple","multiple"),e},createElementNS:function(n,t){return document.createElementNS(Ve[n],t)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,t,e){n.insertBefore(t,e)},removeChild:function(n,t){n.removeChild(t)},appendChild:function(n,t){n.appendChild(t)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,t){n.textContent=t},setStyleScope:function(n,t){n.setAttribute(t,"")}}),Qe={create:function(n,t){nr(t)},update:function(n,t){n.data.ref!==t.data.ref&&(nr(n,!0),nr(t))},destroy:function(n){nr(n,!0)}};function nr(n,t){var e=n.data.ref;if(a(e)){var r=n.context,i=n.componentInstance||n.elm,o=r.$refs;t?Array.isArray(o[e])?y(o[e],i):o[e]===i&&(o[e]=void 0):n.data.refInFor?Array.isArray(o[e])?o[e].indexOf(i)<0&&o[e].push(i):o[e]=[i]:o[e]=i}}var tr=new vn("",{},[]),er=["create","activate","update","remove","destroy"];function rr(n,t){return n.key===t.key&&n.asyncFactory===t.asyncFactory&&(n.tag===t.tag&&n.isComment===t.isComment&&a(n.data)===a(t.data)&&function(n,t){if("input"!==n.tag)return!0;var e,r=a(e=n.data)&&a(e=e.attrs)&&e.type,i=a(e=t.data)&&a(e=e.attrs)&&e.type;return r===i||Ze(r)&&Ze(i)}(n,t)||s(n.isAsyncPlaceholder)&&o(t.asyncFactory.error))}function ir(n,t,e){var r,i,o={};for(r=t;r<=e;++r)a(i=n[r].key)&&(o[i]=r);return o}var or={create:ar,update:ar,destroy:function(n){ar(n,tr)}};function ar(n,t){(n.data.directives||t.data.directives)&&function(n,t){var e,r,i,o=n===tr,a=t===tr,s=cr(n.data.directives,n.context),c=cr(t.data.directives,t.context),u=[],l=[];for(e in c)r=s[e],i=c[e],r?(i.oldValue=r.value,i.oldArg=r.arg,lr(i,"update",t,n),i.def&&i.def.componentUpdated&&l.push(i)):(lr(i,"bind",t,n),i.def&&i.def.inserted&&u.push(i));if(u.length){var p=function(){for(var e=0;e<u.length;e++)lr(u[e],"inserted",t,n)};o?lt(t,"insert",p):p()}l.length&&lt(t,"postpatch",(function(){for(var e=0;e<l.length;e++)lr(l[e],"componentUpdated",t,n)}));if(!o)for(e in s)c[e]||lr(s[e],"unbind",n,n,a)}(n,t)}var sr=Object.create(null);function cr(n,t){var e,r,i=Object.create(null);if(!n)return i;for(e=0;e<n.length;e++)(r=n[e]).modifiers||(r.modifiers=sr),i[ur(r)]=r,r.def=Mn(t.$options,"directives",r.name);return i}function ur(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function lr(n,t,e,r,i){var o=n.def&&n.def[t];if(o)try{o(e.elm,n,e,r,i)}catch(r){Wn(r,e.context,"directive "+n.name+" "+t+" hook")}}var pr=[Qe,or];function dr(n,t){var e=t.componentOptions;if(!(a(e)&&!1===e.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(t.data.attrs))){var r,i,s=t.elm,c=n.data.attrs||{},u=t.data.attrs||{};for(r in a(u.__ob__)&&(u=t.data.attrs=D({},u)),u)i=u[r],c[r]!==i&&fr(s,r,i,t.data.pre);for(r in(Y||K)&&u.value!==c.value&&fr(s,"value",u.value),c)o(u[r])&&(Me(r)?s.removeAttributeNS(Fe,ze(r)):Ue(r)||s.removeAttribute(r))}}function fr(n,t,e,r){r||n.tagName.indexOf("-")>-1?hr(n,t,e):Re(t)?Ne(e)?n.removeAttribute(t):(e="allowfullscreen"===t&&"EMBED"===n.tagName?"true":t,n.setAttribute(t,e)):Ue(t)?n.setAttribute(t,function(n,t){return Ne(t)||"false"===t?"false":"contenteditable"===n&&Le(t)?t:"true"}(t,e)):Me(t)?Ne(e)?n.removeAttributeNS(Fe,ze(t)):n.setAttributeNS(Fe,t,e):hr(n,t,e)}function hr(n,t,e){if(Ne(e))n.removeAttribute(t);else{if(Y&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===t&&""!==e&&!n.__ieph){var r=function(t){t.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(t,e)}}var mr={create:dr,update:dr};function vr(n,t){var e=t.elm,r=t.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var s=Xe(t),c=e._transitionClasses;a(c)&&(s=$e(s,We(c))),s!==e._prevClass&&(e.setAttribute("class",s),e._prevClass=s)}}var gr,br={create:vr,update:vr};function yr(n,t,e){var r=gr;return function i(){var o=t.apply(null,arguments);null!==o&&Cr(n,i,e,r)}}var xr=Yn&&!(nn&&Number(nn[1])<=53);function Ar(n,t,e,r){if(xr){var i=ue,o=t;t=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}gr.addEventListener(n,t,en?{capture:e,passive:r}:e)}function Cr(n,t,e,r){(r||gr).removeEventListener(n,t._wrapper||t,e)}function Sr(n,t){if(!o(n.data.on)||!o(t.data.on)){var e=t.data.on||{},r=n.data.on||{};gr=t.elm,function(n){if(a(n.__r)){var t=Y?"change":"input";n[t]=[].concat(n.__r,n[t]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(e),ut(e,r,Ar,Cr,yr,t.context),gr=void 0}}var wr,Ir={create:Sr,update:Sr};function Er(n,t){if(!o(n.data.domProps)||!o(t.data.domProps)){var e,r,i=t.elm,s=n.data.domProps||{},c=t.data.domProps||{};for(e in a(c.__ob__)&&(c=t.data.domProps=D({},c)),s)e in c||(i[e]="");for(e in c){if(r=c[e],"textContent"===e||"innerHTML"===e){if(t.children&&(t.children.length=0),r===s[e])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===e&&"PROGRESS"!==i.tagName){i._value=r;var u=o(r)?"":String(r);Pr(i,u)&&(i.value=u)}else if("innerHTML"===e&&qe(i.tagName)&&o(i.innerHTML)){(wr=wr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var l=wr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;l.firstChild;)i.appendChild(l.firstChild)}else if(r!==s[e])try{i[e]=r}catch(n){}}}}function Pr(n,t){return!n.composing&&("OPTION"===n.tagName||function(n,t){var e=!0;try{e=document.activeElement!==n}catch(n){}return e&&n.value!==t}(n,t)||function(n,t){var e=n.value,r=n._vModifiers;if(a(r)){if(r.number)return v(e)!==v(t);if(r.trim)return e.trim()!==t.trim()}return e!==t}(n,t))}var _r={create:Er,update:Er},Or=C((function(n){var t={},e=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(e);r.length>1&&(t[r[0].trim()]=r[1].trim())}})),t}));function Dr(n){var t=Tr(n.style);return n.staticStyle?D(n.staticStyle,t):t}function Tr(n){return Array.isArray(n)?T(n):"string"==typeof n?Or(n):n}var kr,Br=/^--/,jr=/\s*!important$/,Ur=function(n,t,e){if(Br.test(t))n.style.setProperty(t,e);else if(jr.test(e))n.style.setProperty(P(t),e.replace(jr,""),"important");else{var r=Rr(t);if(Array.isArray(e))for(var i=0,o=e.length;i<o;i++)n.style[r]=e[i];else n.style[r]=e}},Lr=["Webkit","Moz","ms"],Rr=C((function(n){if(kr=kr||document.createElement("div").style,"filter"!==(n=w(n))&&n in kr)return n;for(var t=n.charAt(0).toUpperCase()+n.slice(1),e=0;e<Lr.length;e++){var r=Lr[e]+t;if(r in kr)return r}}));function Fr(n,t){var e=t.data,r=n.data;if(!(o(e.staticStyle)&&o(e.style)&&o(r.staticStyle)&&o(r.style))){var i,s,c=t.elm,u=r.staticStyle,l=r.normalizedStyle||r.style||{},p=u||l,d=Tr(t.data.style)||{};t.data.normalizedStyle=a(d.__ob__)?D({},d):d;var f=function(n,t){var e,r={};if(t)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(e=Dr(i.data))&&D(r,e);(e=Dr(n.data))&&D(r,e);for(var o=n;o=o.parent;)o.data&&(e=Dr(o.data))&&D(r,e);return r}(t,!0);for(s in p)o(f[s])&&Ur(c,s,"");for(s in f)(i=f[s])!==p[s]&&Ur(c,s,null==i?"":i)}}var Mr={create:Fr,update:Fr},zr=/\s+/;function Nr(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(zr).forEach((function(t){return n.classList.add(t)})):n.classList.add(t);else{var e=" "+(n.getAttribute("class")||"")+" ";e.indexOf(" "+t+" ")<0&&n.setAttribute("class",(e+t).trim())}}function Xr(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(zr).forEach((function(t){return n.classList.remove(t)})):n.classList.remove(t),n.classList.length||n.removeAttribute("class");else{for(var e=" "+(n.getAttribute("class")||"")+" ",r=" "+t+" ";e.indexOf(r)>=0;)e=e.replace(r," ");(e=e.trim())?n.setAttribute("class",e):n.removeAttribute("class")}}function Hr(n){if(n){if("object"==typeof n){var t={};return!1!==n.css&&D(t,$r(n.name||"v")),D(t,n),t}return"string"==typeof n?$r(n):void 0}}var $r=C((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Wr=V&&!Z,Vr="transition",Gr="transitionend",qr="animation",Jr="animationend";Wr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(qr="WebkitAnimation",Jr="webkitAnimationEnd"));var Yr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Zr(n){Yr((function(){Yr(n)}))}function Kr(n,t){var e=n._transitionClasses||(n._transitionClasses=[]);e.indexOf(t)<0&&(e.push(t),Nr(n,t))}function Qr(n,t){n._transitionClasses&&y(n._transitionClasses,t),Xr(n,t)}function ni(n,t,e){var r=ei(n,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return e();var s="transition"===i?Gr:Jr,c=0,u=function(){n.removeEventListener(s,l),e()},l=function(t){t.target===n&&++c>=a&&u()};setTimeout((function(){c<a&&u()}),o+1),n.addEventListener(s,l)}var ti=/\b(transform|all)(,|$)/;function ei(n,t){var e,r=window.getComputedStyle(n),i=(r[Vr+"Delay"]||"").split(", "),o=(r[Vr+"Duration"]||"").split(", "),a=ri(i,o),s=(r[qr+"Delay"]||"").split(", "),c=(r[qr+"Duration"]||"").split(", "),u=ri(s,c),l=0,p=0;return"transition"===t?a>0&&(e="transition",l=a,p=o.length):"animation"===t?u>0&&(e="animation",l=u,p=c.length):p=(e=(l=Math.max(a,u))>0?a>u?"transition":"animation":null)?"transition"===e?o.length:c.length:0,{type:e,timeout:l,propCount:p,hasTransform:"transition"===e&&ti.test(r[Vr+"Property"])}}function ri(n,t){for(;n.length<t.length;)n=n.concat(n);return Math.max.apply(null,t.map((function(t,e){return ii(t)+ii(n[e])})))}function ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oi(n,t){var e=n.elm;a(e._leaveCb)&&(e._leaveCb.cancelled=!0,e._leaveCb());var r=Hr(n.data.transition);if(!o(r)&&!a(e._enterCb)&&1===e.nodeType){for(var i=r.css,s=r.type,c=r.enterClass,l=r.enterToClass,p=r.enterActiveClass,d=r.appearClass,f=r.appearToClass,h=r.appearActiveClass,m=r.beforeEnter,g=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,A=r.appear,C=r.afterAppear,S=r.appearCancelled,w=r.duration,I=Kt,E=Kt.$vnode;E&&E.parent;)I=E.context,E=E.parent;var P=!I._isMounted||!n.isRootInsert;if(!P||A||""===A){var _=P&&d?d:c,O=P&&h?h:p,D=P&&f?f:l,T=P&&x||m,k=P&&"function"==typeof A?A:g,B=P&&C||b,j=P&&S||y,U=v(u(w)?w.enter:w);0;var L=!1!==i&&!Z,F=ci(k),M=e._enterCb=R((function(){L&&(Qr(e,D),Qr(e,O)),M.cancelled?(L&&Qr(e,_),j&&j(e)):B&&B(e),e._enterCb=null}));n.data.show||lt(n,"insert",(function(){var t=e.parentNode,r=t&&t._pending&&t._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),k&&k(e,M)})),T&&T(e),L&&(Kr(e,_),Kr(e,O),Zr((function(){Qr(e,_),M.cancelled||(Kr(e,D),F||(si(U)?setTimeout(M,U):ni(e,s,M)))}))),n.data.show&&(t&&t(),k&&k(e,M)),L||F||M()}}}function ai(n,t){var e=n.elm;a(e._enterCb)&&(e._enterCb.cancelled=!0,e._enterCb());var r=Hr(n.data.transition);if(o(r)||1!==e.nodeType)return t();if(!a(e._leaveCb)){var i=r.css,s=r.type,c=r.leaveClass,l=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,b=r.duration,y=!1!==i&&!Z,x=ci(f),A=v(u(b)?b.leave:b);0;var C=e._leaveCb=R((function(){e.parentNode&&e.parentNode._pending&&(e.parentNode._pending[n.key]=null),y&&(Qr(e,l),Qr(e,p)),C.cancelled?(y&&Qr(e,c),m&&m(e)):(t(),h&&h(e)),e._leaveCb=null}));g?g(S):S()}function S(){C.cancelled||(!n.data.show&&e.parentNode&&((e.parentNode._pending||(e.parentNode._pending={}))[n.key]=n),d&&d(e),y&&(Kr(e,c),Kr(e,p),Zr((function(){Qr(e,c),C.cancelled||(Kr(e,l),x||(si(A)?setTimeout(C,A):ni(e,s,C)))}))),f&&f(e,C),y||x||C())}}function si(n){return"number"==typeof n&&!isNaN(n)}function ci(n){if(o(n))return!1;var t=n.fns;return a(t)?ci(Array.isArray(t)?t[0]:t):(n._length||n.length)>1}function ui(n,t){!0!==t.data.show&&oi(t)}var li=function(n){var t,e,r={},i=n.modules,u=n.nodeOps;for(t=0;t<er.length;++t)for(r[er[t]]=[],e=0;e<i.length;++e)a(i[e][er[t]])&&r[er[t]].push(i[e][er[t]]);function l(n){var t=u.parentNode(n);a(t)&&u.removeChild(t,n)}function p(n,t,e,i,o,c,l){if(a(n.elm)&&a(c)&&(n=c[l]=xn(n)),n.isRootInsert=!o,!function(n,t,e,i){var o=n.data;if(a(o)){var c=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return d(n,t),f(e,n.elm,i),s(c)&&function(n,t,e,i){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](tr,s);t.push(s);break}f(e,n.elm,i)}(n,t,e,i),!0}}(n,t,e,i)){var p=n.data,m=n.children,g=n.tag;a(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),h(n,m,t),a(p)&&v(n,t),f(e,n.elm,i)):s(n.isComment)?(n.elm=u.createComment(n.text),f(e,n.elm,i)):(n.elm=u.createTextNode(n.text),f(e,n.elm,i))}}function d(n,t){a(n.data.pendingInsert)&&(t.push.apply(t,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(v(n,t),b(n)):(nr(n),t.push(n))}function f(n,t,e){a(n)&&(a(e)?u.parentNode(e)===n&&u.insertBefore(n,t,e):u.appendChild(n,t))}function h(n,t,e){if(Array.isArray(t)){0;for(var r=0;r<t.length;++r)p(t[r],e,n.elm,null,!0,t,r)}else c(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function v(n,e){for(var i=0;i<r.create.length;++i)r.create[i](tr,n);a(t=n.data.hook)&&(a(t.create)&&t.create(tr,n),a(t.insert)&&e.push(n))}function b(n){var t;if(a(t=n.fnScopeId))u.setStyleScope(n.elm,t);else for(var e=n;e;)a(t=e.context)&&a(t=t.$options._scopeId)&&u.setStyleScope(n.elm,t),e=e.parent;a(t=Kt)&&t!==n.context&&t!==n.fnContext&&a(t=t.$options._scopeId)&&u.setStyleScope(n.elm,t)}function y(n,t,e,r,i,o){for(;r<=i;++r)p(e[r],o,n,t,!1,e,r)}function x(n){var t,e,i=n.data;if(a(i))for(a(t=i.hook)&&a(t=t.destroy)&&t(n),t=0;t<r.destroy.length;++t)r.destroy[t](n);if(a(t=n.children))for(e=0;e<n.children.length;++e)x(n.children[e])}function A(n,t,e){for(;t<=e;++t){var r=n[t];a(r)&&(a(r.tag)?(C(r),x(r)):l(r.elm))}}function C(n,t){if(a(t)||a(n.data)){var e,i=r.remove.length+1;for(a(t)?t.listeners+=i:t=function(n,t){function e(){0==--e.listeners&&l(n)}return e.listeners=t,e}(n.elm,i),a(e=n.componentInstance)&&a(e=e._vnode)&&a(e.data)&&C(e,t),e=0;e<r.remove.length;++e)r.remove[e](n,t);a(e=n.data.hook)&&a(e=e.remove)?e(n,t):t()}else l(n.elm)}function S(n,t,e,r){for(var i=e;i<r;i++){var o=t[i];if(a(o)&&rr(n,o))return i}}function w(n,t,e,i,c,l){if(n!==t){a(t.elm)&&a(i)&&(t=i[c]=xn(t));var d=t.elm=n.elm;if(s(n.isAsyncPlaceholder))a(t.asyncFactory.resolved)?P(n.elm,t,e):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(n.isStatic)&&t.key===n.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=n.componentInstance;else{var f,h=t.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,t);var v=n.children,g=t.children;if(a(h)&&m(t)){for(f=0;f<r.update.length;++f)r.update[f](n,t);a(f=h.hook)&&a(f=f.update)&&f(n,t)}o(t.text)?a(v)&&a(g)?v!==g&&function(n,t,e,r,i){var s,c,l,d=0,f=0,h=t.length-1,m=t[0],v=t[h],g=e.length-1,b=e[0],x=e[g],C=!i;for(0;d<=h&&f<=g;)o(m)?m=t[++d]:o(v)?v=t[--h]:rr(m,b)?(w(m,b,r,e,f),m=t[++d],b=e[++f]):rr(v,x)?(w(v,x,r,e,g),v=t[--h],x=e[--g]):rr(m,x)?(w(m,x,r,e,g),C&&u.insertBefore(n,m.elm,u.nextSibling(v.elm)),m=t[++d],x=e[--g]):rr(v,b)?(w(v,b,r,e,f),C&&u.insertBefore(n,v.elm,m.elm),v=t[--h],b=e[++f]):(o(s)&&(s=ir(t,d,h)),o(c=a(b.key)?s[b.key]:S(b,t,d,h))?p(b,r,n,m.elm,!1,e,f):rr(l=t[c],b)?(w(l,b,r,e,f),t[c]=void 0,C&&u.insertBefore(n,l.elm,m.elm)):p(b,r,n,m.elm,!1,e,f),b=e[++f]);d>h?y(n,o(e[g+1])?null:e[g+1].elm,e,f,g,r):f>g&&A(t,d,h)}(d,v,g,e,l):a(g)?(a(n.text)&&u.setTextContent(d,""),y(d,null,g,0,g.length-1,e)):a(v)?A(v,0,v.length-1):a(n.text)&&u.setTextContent(d,""):n.text!==t.text&&u.setTextContent(d,t.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,t)}}}function I(n,t,e){if(s(e)&&a(n.parent))n.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}var E=g("attrs,class,staticClass,staticStyle,key");function P(n,t,e,r){var i,o=t.tag,c=t.data,u=t.children;if(r=r||c&&c.pre,t.elm=n,s(t.isComment)&&a(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(a(c)&&(a(i=c.hook)&&a(i=i.init)&&i(t,!0),a(i=t.componentInstance)))return d(t,e),!0;if(a(o)){if(a(u))if(n.hasChildNodes())if(a(i=c)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var l=!0,p=n.firstChild,f=0;f<u.length;f++){if(!p||!P(p,u[f],e,r)){l=!1;break}p=p.nextSibling}if(!l||p)return!1}else h(t,u,e);if(a(c)){var m=!1;for(var g in c)if(!E(g)){m=!0,v(t,e);break}!m&&c.class&&at(c.class)}}else n.data!==t.text&&(n.data=t.text);return!0}return function(n,t,e,i){if(!o(t)){var c,l=!1,d=[];if(o(n))l=!0,p(t,d);else{var f=a(n.nodeType);if(!f&&rr(n,t))w(n,t,d,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),e=!0),s(e)&&P(n,t,d))return I(t,d,!0),n;c=n,n=new vn(u.tagName(c).toLowerCase(),{},[],void 0,c)}var h=n.elm,v=u.parentNode(h);if(p(t,d,h._leaveCb?null:v,u.nextSibling(h)),a(t.parent))for(var g=t.parent,b=m(t);g;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](g);if(g.elm=t.elm,b){for(var C=0;C<r.create.length;++C)r.create[C](tr,g);var S=g.data.hook.insert;if(S.merged)for(var E=1;E<S.fns.length;E++)S.fns[E]()}else nr(g);g=g.parent}a(v)?A([n],0,0):a(n.tag)&&x(n)}}return I(t,d,l),t.elm}a(n)&&x(n)}}({nodeOps:Ke,modules:[mr,br,Ir,_r,Mr,V?{create:ui,activate:ui,remove:function(n,t){!0!==n.data.show?ai(n,t):t()}}:{}].concat(pr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var pi={inserted:function(n,t,e,r){"select"===e.tag?(r.elm&&!r.elm._vOptions?lt(e,"postpatch",(function(){pi.componentUpdated(n,t,e)})):di(n,t,e.context),n._vOptions=[].map.call(n.options,mi)):("textarea"===e.tag||Ze(n.type))&&(n._vModifiers=t.modifiers,t.modifiers.lazy||(n.addEventListener("compositionstart",vi),n.addEventListener("compositionend",gi),n.addEventListener("change",gi),Z&&(n.vmodel=!0)))},componentUpdated:function(n,t,e){if("select"===e.tag){di(n,t,e.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,mi);if(i.some((function(n,t){return!U(n,r[t])})))(n.multiple?t.value.some((function(n){return hi(n,i)})):t.value!==t.oldValue&&hi(t.value,i))&&bi(n,"change")}}};function di(n,t,e){fi(n,t,e),(Y||K)&&setTimeout((function(){fi(n,t,e)}),0)}function fi(n,t,e){var r=t.value,i=n.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=n.options.length;s<c;s++)if(a=n.options[s],i)o=L(r,mi(a))>-1,a.selected!==o&&(a.selected=o);else if(U(mi(a),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function hi(n,t){return t.every((function(t){return!U(t,n)}))}function mi(n){return"_value"in n?n._value:n.value}function vi(n){n.target.composing=!0}function gi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,t){var e=document.createEvent("HTMLEvents");e.initEvent(t,!0,!0),n.dispatchEvent(e)}function yi(n){return!n.componentInstance||n.data&&n.data.transition?n:yi(n.componentInstance._vnode)}var xi={model:pi,show:{bind:function(n,t,e){var r=t.value,i=(e=yi(e)).data&&e.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(e.data.show=!0,oi(e,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,t,e){var r=t.value;!r!=!t.oldValue&&((e=yi(e)).data&&e.data.transition?(e.data.show=!0,r?oi(e,(function(){n.style.display=n.__vOriginalDisplay})):ai(e,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,t,e,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Ai={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ci(n){var t=n&&n.componentOptions;return t&&t.Ctor.options.abstract?Ci(Gt(t.children)):n}function Si(n){var t={},e=n.$options;for(var r in e.propsData)t[r]=n[r];var i=e._parentListeners;for(var o in i)t[w(o)]=i[o];return t}function wi(n,t){if(/\d-keep-alive$/.test(t.tag))return n("keep-alive",{props:t.componentOptions.propsData})}var Ii=function(n){return n.tag||gt(n)},Ei=function(n){return"show"===n.name},Pi={name:"transition",props:Ai,abstract:!0,render:function(n){var t=this,e=this.$slots.default;if(e&&(e=e.filter(Ii)).length){0;var r=this.mode;0;var i=e[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var o=Ci(i);if(!o)return i;if(this._leaving)return wi(n,i);var a="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?a+"comment":a+o.tag:c(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Si(this),u=this._vnode,l=Ci(u);if(o.data.directives&&o.data.directives.some(Ei)&&(o.data.show=!0),l&&l.data&&!function(n,t){return t.key===n.key&&t.tag===n.tag}(o,l)&&!gt(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var p=l.data.transition=D({},s);if("out-in"===r)return this._leaving=!0,lt(p,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),wi(n,i);if("in-out"===r){if(gt(o))return u;var d,f=function(){d()};lt(s,"afterEnter",f),lt(s,"enterCancelled",f),lt(p,"delayLeave",(function(n){d=n}))}}return i}}},_i=D({tag:String,moveClass:String},Ai);function Oi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Di(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ti(n){var t=n.data.pos,e=n.data.newPos,r=t.left-e.left,i=t.top-e.top;if(r||i){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}delete _i.mode;var ki={Transition:Pi,TransitionGroup:{props:_i,beforeMount:function(){var n=this,t=this._update;this._update=function(e,r){var i=Qt(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),t.call(n,e,r)}},render:function(n){for(var t=this.tag||this.$vnode.data.tag||"span",e=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Si(this),s=0;s<i.length;s++){var c=i[s];if(c.tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))o.push(c),e[c.key]=c,(c.data||(c.data={})).transition=a;else;}if(r){for(var u=[],l=[],p=0;p<r.length;p++){var d=r[p];d.data.transition=a,d.data.pos=d.elm.getBoundingClientRect(),e[d.key]?u.push(d):l.push(d)}this.kept=n(t,null,u),this.removed=l}return n(t,null,o)},updated:function(){var n=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,t)&&(n.forEach(Oi),n.forEach(Di),n.forEach(Ti),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var e=n.elm,r=e.style;Kr(e,t),r.transform=r.WebkitTransform=r.transitionDuration="",e.addEventListener(Gr,e._moveCb=function n(r){r&&r.target!==e||r&&!/transform$/.test(r.propertyName)||(e.removeEventListener(Gr,n),e._moveCb=null,Qr(e,t))})}})))},methods:{hasMove:function(n,t){if(!Wr)return!1;if(this._hasMove)return this._hasMove;var e=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Xr(e,n)})),Nr(e,t),e.style.display="none",this.$el.appendChild(e);var r=ei(e);return this.$el.removeChild(e),this._hasMove=r.hasTransform}}}};Ie.config.mustUseProp=function(n,t,e){return"value"===e&&je(n)&&"button"!==t||"selected"===e&&"option"===n||"checked"===e&&"input"===n||"muted"===e&&"video"===n},Ie.config.isReservedTag=Je,Ie.config.isReservedAttr=Be,Ie.config.getTagNamespace=function(n){return qe(n)?"svg":"math"===n?"math":void 0},Ie.config.isUnknownElement=function(n){if(!V)return!0;if(Je(n))return!1;if(n=n.toLowerCase(),null!=Ye[n])return Ye[n];var t=document.createElement(n);return n.indexOf("-")>-1?Ye[n]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Ye[n]=/HTMLUnknownElement/.test(t.toString())},D(Ie.options.directives,xi),D(Ie.options.components,ki),Ie.prototype.__patch__=V?li:k,Ie.prototype.$mount=function(n,t){return function(n,t,e){var r;return n.$el=t,n.$options.render||(n.$options.render=bn),ee(n,"beforeMount"),r=function(){n._update(n._render(),e)},new he(n,r,k,{before:function(){n._isMounted&&!n._isDestroyed&&ee(n,"beforeUpdate")}},!0),e=!1,null==n.$vnode&&(n._isMounted=!0,ee(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var t=document.querySelector(n);return t||document.createElement("div")}return n}(n):void 0,t)},V&&setTimeout((function(){z.devtools&&an&&an.emit("init",Ie)}),0);var Bi=Ie;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function ji(n,t){for(var e in t)n[e]=t[e];return n}var Ui=/[!'()*]/g,Li=function(n){return"%"+n.charCodeAt(0).toString(16)},Ri=/%2C/g,Fi=function(n){return encodeURIComponent(n).replace(Ui,Li).replace(Ri,",")};function Mi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var zi=function(n){return null==n||"object"==typeof n?n:String(n)};function Ni(n){var t={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var e=n.replace(/\+/g," ").split("="),r=Mi(e.shift()),i=e.length>0?Mi(e.join("=")):null;void 0===t[r]?t[r]=i:Array.isArray(t[r])?t[r].push(i):t[r]=[t[r],i]})),t):t}function Xi(n){var t=n?Object.keys(n).map((function(t){var e=n[t];if(void 0===e)return"";if(null===e)return Fi(t);if(Array.isArray(e)){var r=[];return e.forEach((function(n){void 0!==n&&(null===n?r.push(Fi(t)):r.push(Fi(t)+"="+Fi(n)))})),r.join("&")}return Fi(t)+"="+Fi(e)})).filter((function(n){return n.length>0})).join("&"):null;return t?"?"+t:""}var Hi=/\/?$/;function $i(n,t,e,r){var i=r&&r.options.stringifyQuery,o=t.query||{};try{o=Wi(o)}catch(n){}var a={name:t.name||n&&n.name,meta:n&&n.meta||{},path:t.path||"/",hash:t.hash||"",query:o,params:t.params||{},fullPath:qi(t,i),matched:n?Gi(n):[]};return e&&(a.redirectedFrom=qi(e,i)),Object.freeze(a)}function Wi(n){if(Array.isArray(n))return n.map(Wi);if(n&&"object"==typeof n){var t={};for(var e in n)t[e]=Wi(n[e]);return t}return n}var Vi=$i(null,{path:"/"});function Gi(n){for(var t=[];n;)t.unshift(n),n=n.parent;return t}function qi(n,t){var e=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(e||"/")+(t||Xi)(r)+i}function Ji(n,t,e){return t===Vi?n===t:!!t&&(n.path&&t.path?n.path.replace(Hi,"")===t.path.replace(Hi,"")&&(e||n.hash===t.hash&&Yi(n.query,t.query)):!(!n.name||!t.name)&&(n.name===t.name&&(e||n.hash===t.hash&&Yi(n.query,t.query)&&Yi(n.params,t.params))))}function Yi(n,t){if(void 0===n&&(n={}),void 0===t&&(t={}),!n||!t)return n===t;var e=Object.keys(n).sort(),r=Object.keys(t).sort();return e.length===r.length&&e.every((function(e,i){var o=n[e];if(r[i]!==e)return!1;var a=t[e];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?Yi(o,a):String(o)===String(a)}))}function Zi(n){for(var t=0;t<n.matched.length;t++){var e=n.matched[t];for(var r in e.instances){var i=e.instances[r],o=e.enteredCbs[r];if(i&&o){delete e.enteredCbs[r];for(var a=0;a<o.length;a++)i._isBeingDestroyed||o[a](i)}}}}var Ki={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,t){var e=t.props,r=t.children,i=t.parent,o=t.data;o.routerView=!0;for(var a=i.$createElement,s=e.name,c=i.$route,u=i._routerViewCache||(i._routerViewCache={}),l=0,p=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&l++,d.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(o.routerViewDepth=l,p){var f=u[s],h=f&&f.component;return h?(f.configProps&&Qi(h,o,f.route,f.configProps),a(h,o,r)):a()}var m=c.matched[l],v=m&&m.components[s];if(!m||!v)return u[s]=null,a();u[s]={component:v},o.registerRouteInstance=function(n,t){var e=m.instances[s];(t&&e!==n||!t&&e===n)&&(m.instances[s]=t)},(o.hook||(o.hook={})).prepatch=function(n,t){m.instances[s]=t.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),Zi(c)};var g=m.props&&m.props[s];return g&&(ji(u[s],{route:c,configProps:g}),Qi(v,o,c,g)),a(v,o,r)}};function Qi(n,t,e,r){var i=t.props=function(n,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(n);case"boolean":return t?n.params:void 0;default:0}}(e,r);if(i){i=t.props=ji({},i);var o=t.attrs=t.attrs||{};for(var a in i)n.props&&a in n.props||(o[a]=i[a],delete i[a])}}function no(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function to(n){return n.replace(/\/+/g,"/")}var eo=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ro=bo,io=uo,oo=function(n,t){return po(uo(n,t),t)},ao=po,so=go,co=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function uo(n,t){for(var e,r=[],i=0,o=0,a="",s=t&&t.delimiter||"/";null!=(e=co.exec(n));){var c=e[0],u=e[1],l=e.index;if(a+=n.slice(o,l),o=l+c.length,u)a+=u[1];else{var p=n[o],d=e[2],f=e[3],h=e[4],m=e[5],v=e[6],g=e[7];a&&(r.push(a),a="");var b=null!=d&&null!=p&&p!==d,y="+"===v||"*"===v,x="?"===v||"*"===v,A=e[2]||s,C=h||m;r.push({name:f||i++,prefix:d||"",delimiter:A,optional:x,repeat:y,partial:b,asterisk:!!g,pattern:C?ho(C):g?".*":"[^"+fo(A)+"]+?"})}}return o<n.length&&(a+=n.substr(o)),a&&r.push(a),r}function lo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function po(n,t){for(var e=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(e[r]=new RegExp("^(?:"+n[r].pattern+")$",vo(t)));return function(t,r){for(var i="",o=t||{},a=(r||{}).pretty?lo:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var u,l=o[c.name];if(null==l){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(eo(l)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(l)+"`");if(0===l.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<l.length;p++){if(u=a(l[p]),!e[s].test(u))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(u)+"`");i+=(0===p?c.prefix:c.delimiter)+u}}else{if(u=c.asterisk?encodeURI(l).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(l),!e[s].test(u))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+u+'"');i+=c.prefix+u}}else i+=c}return i}}function fo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ho(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function mo(n,t){return n.keys=t,n}function vo(n){return n&&n.sensitive?"":"i"}function go(n,t,e){eo(t)||(e=t||e,t=[]);for(var r=(e=e||{}).strict,i=!1!==e.end,o="",a=0;a<n.length;a++){var s=n[a];if("string"==typeof s)o+=fo(s);else{var c=fo(s.prefix),u="(?:"+s.pattern+")";t.push(s),s.repeat&&(u+="(?:"+c+u+")*"),o+=u=s.optional?s.partial?c+"("+u+")?":"(?:"+c+"("+u+"))?":c+"("+u+")"}}var l=fo(e.delimiter||"/"),p=o.slice(-l.length)===l;return r||(o=(p?o.slice(0,-l.length):o)+"(?:"+l+"(?=$))?"),o+=i?"$":r&&p?"":"(?="+l+"|$)",mo(new RegExp("^"+o,vo(e)),t)}function bo(n,t,e){return eo(t)||(e=t||e,t=[]),e=e||{},n instanceof RegExp?function(n,t){var e=n.source.match(/\((?!\?)/g);if(e)for(var r=0;r<e.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return mo(n,t)}(n,t):eo(n)?function(n,t,e){for(var r=[],i=0;i<n.length;i++)r.push(bo(n[i],t,e).source);return mo(new RegExp("(?:"+r.join("|")+")",vo(e)),t)}(n,t,e):function(n,t,e){return go(uo(n,e),t,e)}(n,t,e)}ro.parse=io,ro.compile=oo,ro.tokensToFunction=ao,ro.tokensToRegExp=so;var yo=Object.create(null);function xo(n,t,e){t=t||{};try{var r=yo[n]||(yo[n]=ro.compile(n));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),r(t,{pretty:!0})}catch(n){return""}finally{delete t[0]}}function Ao(n,t,e,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=ji({},n)).params;return o&&"object"==typeof o&&(i.params=ji({},o)),i}if(!i.path&&i.params&&t){(i=ji({},i))._normalized=!0;var a=ji(ji({},t.params),i.params);if(t.name)i.name=t.name,i.params=a;else if(t.matched.length){var s=t.matched[t.matched.length-1].path;i.path=xo(s,a,t.path)}else 0;return i}var c=function(n){var t="",e="",r=n.indexOf("#");r>=0&&(t=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(e=n.slice(i+1),n=n.slice(0,i)),{path:n,query:e,hash:t}}(i.path||""),u=t&&t.path||"/",l=c.path?no(c.path,u,e||i.append):u,p=function(n,t,e){void 0===t&&(t={});var r,i=e||Ni;try{r=i(n||"")}catch(n){r={}}for(var o in t){var a=t[o];r[o]=Array.isArray(a)?a.map(zi):zi(a)}return r}(c.query,i.query,r&&r.options.parseQuery),d=i.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:l,query:p,hash:d}}var Co,So=function(){},wo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var t=this,e=this.$router,r=this.$route,i=e.resolve(this.to,r,this.append),o=i.location,a=i.route,s=i.href,c={},u=e.options.linkActiveClass,l=e.options.linkExactActiveClass,p=null==u?"router-link-active":u,d=null==l?"router-link-exact-active":l,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=a.redirectedFrom?$i(null,Ao(a.redirectedFrom),null,e):a;c[h]=Ji(r,m,this.exactPath),c[f]=this.exact||this.exactPath?c[h]:function(n,t){return 0===n.path.replace(Hi,"/").indexOf(t.path.replace(Hi,"/"))&&(!t.hash||n.hash===t.hash)&&function(n,t){for(var e in t)if(!(e in n))return!1;return!0}(n.query,t.query)}(r,m);var v=c[h]?this.ariaCurrentValue:null,g=function(n){Io(n)&&(t.replace?e.replace(o,So):e.push(o,So))},b={click:Io};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var y={class:c},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:g,isActive:c[f],isExactActive:c[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":v};else{var A=function n(t){var e;if(t)for(var r=0;r<t.length;r++){if("a"===(e=t[r]).tag)return e;if(e.children&&(e=n(e.children)))return e}}(this.$slots.default);if(A){A.isStatic=!1;var C=A.data=ji({},A.data);for(var S in C.on=C.on||{},C.on){var w=C.on[S];S in b&&(C.on[S]=Array.isArray(w)?w:[w])}for(var I in b)I in C.on?C.on[I].push(b[I]):C.on[I]=g;var E=A.data.attrs=ji({},A.data.attrs);E.href=s,E["aria-current"]=v}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Io(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var t=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return n.preventDefault&&n.preventDefault(),!0}}var Eo="undefined"!=typeof window;function Po(n,t,e,r,i){var o=t||[],a=e||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(t,e,r,i,o,a){var s=i.path,c=i.name;0;var u=i.pathToRegexpOptions||{},l=function(n,t,e){e||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==t)return n;return to(t.path+"/"+n)}(s,o,u.strict);"boolean"==typeof i.caseSensitive&&(u.sensitive=i.caseSensitive);var p={path:l,regex:_o(l,u),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:o,matchAs:a,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var o=a?to(a+"/"+i.path):void 0;n(t,e,r,i,p,o)}));e[p.path]||(t.push(p.path),e[p.path]=p);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:i.children};n(t,e,r,h,o,p.path||"/")}c&&(r[c]||(r[c]=p))}(o,a,s,n,i)}));for(var c=0,u=o.length;c<u;c++)"*"===o[c]&&(o.push(o.splice(c,1)[0]),u--,c--);return{pathList:o,pathMap:a,nameMap:s}}function _o(n,t){return ro(n,[],t)}function Oo(n,t){var e=Po(n),r=e.pathList,i=e.pathMap,o=e.nameMap;function a(n,e,a){var s=Ao(n,e,!1,t),u=s.name;if(u){var l=o[u];if(!l)return c(null,s);var p=l.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),e&&"object"==typeof e.params)for(var d in e.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=e.params[d]);return s.path=xo(l.path,s.params),c(l,s,a)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Do(m.regex,s.path,s.params))return c(m,s,a)}}return c(null,s)}function s(n,e){var r=n.redirect,i="function"==typeof r?r($i(n,e,null,t)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,e);var s=i,u=s.name,l=s.path,p=e.query,d=e.hash,f=e.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,u){o[u];return a({_normalized:!0,name:u,query:p,hash:d,params:f},void 0,e)}if(l){var h=function(n,t){return no(n,t.parent?t.parent.path:"/",!0)}(l,n);return a({_normalized:!0,path:xo(h,f),query:p,hash:d},void 0,e)}return c(null,e)}function c(n,e,r){return n&&n.redirect?s(n,r||e):n&&n.matchAs?function(n,t,e){var r=a({_normalized:!0,path:xo(e,t.params)});if(r){var i=r.matched,o=i[i.length-1];return t.params=r.params,c(o,t)}return c(null,t)}(0,e,n.matchAs):$i(n,e,r,t)}return{match:a,addRoute:function(n,t){var e="object"!=typeof n?o[n]:void 0;Po([t||n],r,i,o,e),e&&e.alias.length&&Po(e.alias.map((function(n){return{path:n,children:[t]}})),r,i,o,e)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Po(n,r,i,o)}}}function Do(n,t,e){var r=t.match(n);if(!r)return!1;if(!e)return!0;for(var i=1,o=r.length;i<o;++i){var a=n.keys[i-1];a&&(e[a.name||"pathMatch"]="string"==typeof r[i]?Mi(r[i]):r[i])}return!0}var To=Eo&&window.performance&&window.performance.now?window.performance:Date;function ko(){return To.now().toFixed(3)}var Bo=ko();function jo(){return Bo}function Uo(n){return Bo=n}var Lo=Object.create(null);function Ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(n,""),e=ji({},window.history.state);return e.key=jo(),window.history.replaceState(e,"",t),window.addEventListener("popstate",zo),function(){window.removeEventListener("popstate",zo)}}function Fo(n,t,e,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var o=function(){var n=jo();if(n)return Lo[n]}(),a=i.call(n,t,e,r?o:null);a&&("function"==typeof a.then?a.then((function(n){Wo(n,o)})).catch((function(n){0})):Wo(a,o))}))}}function Mo(){var n=jo();n&&(Lo[n]={x:window.pageXOffset,y:window.pageYOffset})}function zo(n){Mo(),n.state&&n.state.key&&Uo(n.state.key)}function No(n){return Ho(n.x)||Ho(n.y)}function Xo(n){return{x:Ho(n.x)?n.x:window.pageXOffset,y:Ho(n.y)?n.y:window.pageYOffset}}function Ho(n){return"number"==typeof n}var $o=/^#\d/;function Wo(n,t){var e,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=$o.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var o=n.offset&&"object"==typeof n.offset?n.offset:{};t=function(n,t){var e=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-e.left-t.x,y:r.top-e.top-t.y}}(i,o={x:Ho((e=o).x)?e.x:0,y:Ho(e.y)?e.y:0})}else No(n)&&(t=Xo(n))}else r&&No(n)&&(t=Xo(n));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:n.behavior}):window.scrollTo(t.x,t.y))}var Vo,Go=Eo&&((-1===(Vo=window.navigator.userAgent).indexOf("Android 2.")&&-1===Vo.indexOf("Android 4.0")||-1===Vo.indexOf("Mobile Safari")||-1!==Vo.indexOf("Chrome")||-1!==Vo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function qo(n,t){Mo();var e=window.history;try{if(t){var r=ji({},e.state);r.key=jo(),e.replaceState(r,"",n)}else e.pushState({key:Uo(ko())},"",n)}catch(e){window.location[t?"replace":"assign"](n)}}function Jo(n){qo(n,!0)}function Yo(n,t,e){var r=function(i){i>=n.length?e():n[i]?t(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Zo={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ko(n,t){return na(n,t,Zo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var t={};return ta.forEach((function(e){e in n&&(t[e]=n[e])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function Qo(n,t){return na(n,t,Zo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function na(n,t,e,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=t,i.type=e,i}var ta=["params","query","hash"];function ea(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ra(n,t){return ea(n)&&n._isRouter&&(null==t||n.type===t)}function ia(n){return function(t,e,r){var i=!1,o=0,a=null;oa(n,(function(n,t,e,s){if("function"==typeof n&&void 0===n.cid){i=!0,o++;var c,u=ca((function(t){var i;((i=t).__esModule||sa&&"Module"===i[Symbol.toStringTag])&&(t=t.default),n.resolved="function"==typeof t?t:Co.extend(t),e.components[s]=t,--o<=0&&r()})),l=ca((function(n){var t="Failed to resolve async component "+s+": "+n;a||(a=ea(n)?n:new Error(t),r(a))}));try{c=n(u,l)}catch(n){l(n)}if(c)if("function"==typeof c.then)c.then(u,l);else{var p=c.component;p&&"function"==typeof p.then&&p.then(u,l)}}})),i||r()}}function oa(n,t){return aa(n.map((function(n){return Object.keys(n.components).map((function(e){return t(n.components[e],n.instances[e],n,e)}))})))}function aa(n){return Array.prototype.concat.apply([],n)}var sa="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ca(n){var t=!1;return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];if(!t)return t=!0,n.apply(this,e)}}var ua=function(n,t){this.router=n,this.base=function(n){if(!n)if(Eo){var t=document.querySelector("base");n=(n=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(t),this.current=Vi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function la(n,t,e,r){var i=oa(n,(function(n,r,i,o){var a=function(n,t){"function"!=typeof n&&(n=Co.extend(n));return n.options[t]}(n,t);if(a)return Array.isArray(a)?a.map((function(n){return e(n,r,i,o)})):e(a,r,i,o)}));return aa(r?i.reverse():i)}function pa(n,t){if(t)return function(){return n.apply(t,arguments)}}ua.prototype.listen=function(n){this.cb=n},ua.prototype.onReady=function(n,t){this.ready?n():(this.readyCbs.push(n),t&&this.readyErrorCbs.push(t))},ua.prototype.onError=function(n){this.errorCbs.push(n)},ua.prototype.transitionTo=function(n,t,e){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(t){t(n)})),n}var o=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),t&&t(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){e&&e(n),n&&!i.ready&&(ra(n,Zo.redirected)&&o===Vi||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(n)}))))}))},ua.prototype.confirmTransition=function(n,t,e){var r=this,i=this.current;this.pending=n;var o,a,s=function(n){!ra(n)&&ea(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(t){t(n)})):console.error(n)),e&&e(n)},c=n.matched.length-1,u=i.matched.length-1;if(Ji(n,i)&&c===u&&n.matched[c]===i.matched[u])return this.ensureURL(),n.hash&&Fo(this.router,i,n,!1),s(((a=na(o=i,n,Zo.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var l=function(n,t){var e,r=Math.max(n.length,t.length);for(e=0;e<r&&n[e]===t[e];e++);return{updated:t.slice(0,e),activated:t.slice(e),deactivated:n.slice(e)}}(this.current.matched,n.matched),p=l.updated,d=l.deactivated,f=l.activated,h=[].concat(function(n){return la(n,"beforeRouteLeave",pa,!0)}(d),this.router.beforeHooks,function(n){return la(n,"beforeRouteUpdate",pa)}(p),f.map((function(n){return n.beforeEnter})),ia(f)),m=function(t,e){if(r.pending!==n)return s(Qo(i,n));try{t(n,i,(function(t){!1===t?(r.ensureURL(!0),s(function(n,t){return na(n,t,Zo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,n))):ea(t)?(r.ensureURL(!0),s(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(s(Ko(i,n)),"object"==typeof t&&t.replace?r.replace(t):r.push(t)):e(t)}))}catch(n){s(n)}};Yo(h,m,(function(){Yo(function(n){return la(n,"beforeRouteEnter",(function(n,t,e,r){return function(n,t,e){return function(r,i,o){return n(r,i,(function(n){"function"==typeof n&&(t.enteredCbs[e]||(t.enteredCbs[e]=[]),t.enteredCbs[e].push(n)),o(n)}))}}(n,e,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(Qo(i,n));r.pending=null,t(n),r.router.app&&r.router.app.$nextTick((function(){Zi(n)}))}))}))},ua.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},ua.prototype.setupListeners=function(){},ua.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Vi,this.pending=null};var da=function(n){function t(t,e){n.call(this,t,e),this._startLocation=fa(this.base)}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router,e=t.options.scrollBehavior,r=Go&&e;r&&this.listeners.push(Ro());var i=function(){var e=n.current,i=fa(n.base);n.current===Vi&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Fo(t,n,e,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(n){window.history.go(n)},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){qo(to(r.base+n.fullPath)),Fo(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Jo(to(r.base+n.fullPath)),Fo(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.ensureURL=function(n){if(fa(this.base)!==this.current.fullPath){var t=to(this.base+this.current.fullPath);n?qo(t):Jo(t)}},t.prototype.getCurrentLocation=function(){return fa(this.base)},t}(ua);function fa(n){var t=window.location.pathname,e=t.toLowerCase(),r=n.toLowerCase();return!n||e!==r&&0!==e.indexOf(to(r+"/"))||(t=t.slice(n.length)),(t||"/")+window.location.search+window.location.hash}var ha=function(n){function t(t,e,r){n.call(this,t,e),r&&function(n){var t=fa(n);if(!/^\/#/.test(t))return window.location.replace(to(n+"/#"+t)),!0}(this.base)||ma()}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,e=Go&&t;e&&this.listeners.push(Ro());var r=function(){var t=n.current;ma()&&n.transitionTo(va(),(function(r){e&&Fo(n.router,r,t,!0),Go||ya(r.fullPath)}))},i=Go?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){ba(n.fullPath),Fo(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){ya(n.fullPath),Fo(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.go=function(n){window.history.go(n)},t.prototype.ensureURL=function(n){var t=this.current.fullPath;va()!==t&&(n?ba(t):ya(t))},t.prototype.getCurrentLocation=function(){return va()},t}(ua);function ma(){var n=va();return"/"===n.charAt(0)||(ya("/"+n),!1)}function va(){var n=window.location.href,t=n.indexOf("#");return t<0?"":n=n.slice(t+1)}function ga(n){var t=window.location.href,e=t.indexOf("#");return(e>=0?t.slice(0,e):t)+"#"+n}function ba(n){Go?qo(ga(n)):window.location.hash=n}function ya(n){Go?Jo(ga(n)):window.location.replace(ga(n))}var xa=function(n){function t(t,e){n.call(this,t,e),this.stack=[],this.index=-1}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.push=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),t&&t(n)}),e)},t.prototype.go=function(n){var t=this,e=this.index+n;if(!(e<0||e>=this.stack.length)){var r=this.stack[e];this.confirmTransition(r,(function(){var n=t.current;t.index=e,t.updateRoute(r),t.router.afterHooks.forEach((function(t){t&&t(r,n)}))}),(function(n){ra(n,Zo.duplicated)&&(t.index=e)}))}},t.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},t.prototype.ensureURL=function(){},t}(ua),Aa=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Oo(n.routes||[],this);var t=n.mode||"hash";switch(this.fallback="history"===t&&!Go&&!1!==n.fallback,this.fallback&&(t="hash"),Eo||(t="abstract"),this.mode=t,t){case"history":this.history=new da(this,n.base);break;case"hash":this.history=new ha(this,n.base,this.fallback);break;case"abstract":this.history=new xa(this,n.base);break;default:0}},Ca={currentRoute:{configurable:!0}};function Sa(n,t){return n.push(t),function(){var e=n.indexOf(t);e>-1&&n.splice(e,1)}}Aa.prototype.match=function(n,t,e){return this.matcher.match(n,t,e)},Ca.currentRoute.get=function(){return this.history&&this.history.current},Aa.prototype.init=function(n){var t=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var e=t.apps.indexOf(n);e>-1&&t.apps.splice(e,1),t.app===n&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=n;var e=this.history;if(e instanceof da||e instanceof ha){var r=function(n){e.setupListeners(),function(n){var r=e.current,i=t.options.scrollBehavior;Go&&i&&"fullPath"in n&&Fo(t,n,r,!1)}(n)};e.transitionTo(e.getCurrentLocation(),r,r)}e.listen((function(n){t.apps.forEach((function(t){t._route=n}))}))}},Aa.prototype.beforeEach=function(n){return Sa(this.beforeHooks,n)},Aa.prototype.beforeResolve=function(n){return Sa(this.resolveHooks,n)},Aa.prototype.afterEach=function(n){return Sa(this.afterHooks,n)},Aa.prototype.onReady=function(n,t){this.history.onReady(n,t)},Aa.prototype.onError=function(n){this.history.onError(n)},Aa.prototype.push=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.push(n,t,e)}));this.history.push(n,t,e)},Aa.prototype.replace=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.replace(n,t,e)}));this.history.replace(n,t,e)},Aa.prototype.go=function(n){this.history.go(n)},Aa.prototype.back=function(){this.go(-1)},Aa.prototype.forward=function(){this.go(1)},Aa.prototype.getMatchedComponents=function(n){var t=n?n.matched?n:this.resolve(n).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(n){return Object.keys(n.components).map((function(t){return n.components[t]}))}))):[]},Aa.prototype.resolve=function(n,t,e){var r=Ao(n,t=t||this.history.current,e,this),i=this.match(r,t),o=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,t,e){var r="hash"===e?"#"+t:t;return n?to(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:i}},Aa.prototype.getRoutes=function(){return this.matcher.getRoutes()},Aa.prototype.addRoute=function(n,t){this.matcher.addRoute(n,t),this.history.current!==Vi&&this.history.transitionTo(this.history.getCurrentLocation())},Aa.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Vi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Aa.prototype,Ca),Aa.install=function n(t){if(!n.installed||Co!==t){n.installed=!0,Co=t;var e=function(n){return void 0!==n},r=function(n,t){var r=n.$options._parentVnode;e(r)&&e(r=r.data)&&e(r=r.registerRouteInstance)&&r(n,t)};t.mixin({beforeCreate:function(){e(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Ki),t.component("RouterLink",wo);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Aa.version="3.5.3",Aa.isNavigationFailure=ra,Aa.NavigationFailureType=Zo,Aa.START_LOCATION=Vi,Eo&&window.Vue&&window.Vue.use(Aa);var wa=Aa;e(225),e(174),e(251),e(99),e(253),e(37),e(38),e(254);function Ia(n){n.locales&&Object.keys(n.locales).forEach((function(t){n.locales[t].path=t})),Object.freeze(n)}e(74),e(89),e(120);function Ea(n){return(Ea="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Pa=e(68),_a=(e(184),e(18),e(44),e(227),e(228),e(40),e(25),{NotFound:function(){return Promise.all([e.e(0),e.e(4)]).then(e.bind(null,471))},Layout:function(){return Promise.all([e.e(0),e.e(2)]).then(e.bind(null,470))}}),Oa={"v-11903474":function(){return e.e(5).then(e.bind(null,472))},"v-65bcb3b0":function(){return e.e(6).then(e.bind(null,473))},"v-e9c9f3c2":function(){return e.e(7).then(e.bind(null,474))},"v-0f04cd24":function(){return e.e(8).then(e.bind(null,475))},"v-101804a5":function(){return e.e(9).then(e.bind(null,476))},"v-3be4d484":function(){return e.e(10).then(e.bind(null,477))},"v-741e2425":function(){return e.e(13).then(e.bind(null,478))},"v-4bb22690":function(){return e.e(14).then(e.bind(null,479))},"v-557938bc":function(){return e.e(11).then(e.bind(null,480))},"v-257b116f":function(){return e.e(15).then(e.bind(null,481))},"v-7c85b34c":function(){return e.e(16).then(e.bind(null,482))},"v-d5fd0592":function(){return e.e(17).then(e.bind(null,483))},"v-9e40a888":function(){return e.e(12).then(e.bind(null,484))},"v-b75bc230":function(){return e.e(21).then(e.bind(null,485))},"v-0ebed345":function(){return e.e(19).then(e.bind(null,486))},"v-7cfc0d66":function(){return e.e(23).then(e.bind(null,487))},"v-579999c0":function(){return e.e(18).then(e.bind(null,488))},"v-11af5453":function(){return e.e(22).then(e.bind(null,489))},"v-744e4a64":function(){return e.e(25).then(e.bind(null,490))},"v-06417f73":function(){return e.e(24).then(e.bind(null,491))},"v-5476c9e9":function(){return e.e(20).then(e.bind(null,492))},"v-a1b67a0a":function(){return e.e(27).then(e.bind(null,493))},"v-f4040932":function(){return e.e(28).then(e.bind(null,494))},"v-30d162f2":function(){return e.e(33).then(e.bind(null,495))},"v-556e5941":function(){return e.e(29).then(e.bind(null,496))},"v-334cc282":function(){return e.e(26).then(e.bind(null,497))},"v-47c172c3":function(){return e.e(31).then(e.bind(null,498))},"v-a66c34a6":function(){return e.e(30).then(e.bind(null,499))},"v-d83bdb10":function(){return e.e(32).then(e.bind(null,500))},"v-d4c9be1a":function(){return e.e(35).then(e.bind(null,501))},"v-7fb91247":function(){return e.e(34).then(e.bind(null,502))}};function Da(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var Ta=/-(\w)/g,ka=Da((function(n){return n.replace(Ta,(function(n,t){return t?t.toUpperCase():""}))})),Ba=/\B([A-Z])/g,ja=Da((function(n){return n.replace(Ba,"-$1").toLowerCase()})),Ua=Da((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function La(n,t){if(t)return n(t)?n(t):t.includes("-")?n(Ua(ka(t))):n(Ua(t))||n(ja(t))}var Ra=Object.assign({},_a,Oa),Fa=function(n){return Ra[n]},Ma=function(n){return Oa[n]},za=function(n){return _a[n]},Na=function(n){return Bi.component(n)};function Xa(n){return La(Ma,n)}function Ha(n){return La(za,n)}function $a(n){return La(Fa,n)}function Wa(n){return La(Na,n)}function Va(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return Promise.all(t.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(t){var e;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Wa(t)||!$a(t)){n.next=5;break}return n.next=3,$a(t)();case 3:e=n.sent,Bi.component(t,e.default);case 5:case"end":return n.stop()}}),n)})));return function(t){return n.apply(this,arguments)}}()))}function Ga(n,t){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=t)}var qa=e(131),Ja=(e(185),e(106),e(70),e(215)),Ya=e.n(Ja),Za=e(216),Ka=e.n(Za),Qa={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(qa.a)(n,1)[0]})).map((function(n){var t=Object(qa.a)(n,2);t[0];return t[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(t=n)?t.map((function(n){var t="<meta";return Object.keys(n).forEach((function(e){t+=" ".concat(e,'="').concat(Ka()(n[e]),'"')})),t+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=ts(this.$canonicalUrl)}var t},mounted:function(){this.currentMetaTags=Object(Pa.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=es(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Ya()([{name:"description",content:this.$description}],n,this.siteMeta,rs)},updateCanonicalLink:function(){ns(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",ts(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){es(null,this.currentMetaTags),ns()}};function ns(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function ts(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function es(n,t){if(t&&Object(Pa.a)(t).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var t=document.createElement("meta");return Object.keys(n).forEach((function(e){t.setAttribute(e,n[e])})),document.head.appendChild(t),t}))}function rs(n){for(var t=0,e=["name","property","itemprop"];t<e.length;t++){var r=e[t];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}e(133);var is=e(148),os={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:e.n(is)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,t=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return t.some((function(t){return t.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,a=0;a<e.length;a++){var s=e[a],c=e[a+1],u=0===a&&0===r||r>=s.parentElement.offsetTop+10&&(!c||r<c.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(u&&l!==decodeURIComponent(s.hash)){var p=s;if(o===i)for(var d=a+1;d<e.length;d++)if(l===decodeURIComponent(e[d].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(p.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},as=(e(102),e(97)),ss=e.n(as),cs={mounted:function(){var n=this;ss.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,t,e){n.path===t.path||Bi.component(n.name)||ss.a.start(),e()})),this.$router.afterEach((function(){ss.a.done(),n.isSidebarOpen=!1}))}};e(72),e(71),e(75),e(361);function us(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}e(137);function ls(n,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ps(n,t,e){return t&&ls(n.prototype,t),e&&ls(n,e),Object.defineProperty(n,"prototype",{writable:!1}),n}e(362);var ds=function(){function n(){us(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ps(n,[{key:"show",value:function(n){var t=this,e=n.text,r=void 0===e?"":e,i=n.duration,o=void 0===i?3e3:i,a=document.createElement("div");a.className="message move-in",a.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(a),o>0&&setTimeout((function(){t.close(a)}),o)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),fs={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(t){document.querySelectorAll(t).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var t=this;if(!n.classList.contains("codecopy-enabled")){var e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",(function(){t.copyToClipboard(n.innerText)})),n.appendChild(e),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var t=document.createElement("textarea");t.value=n,t.setAttribute("readonly",""),t.style.position="absolute",t.style.left="-9999px",document.body.appendChild(t);var e=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);t.select(),document.execCommand("copy"),(new ds).show({text:"复制成功",duration:1e3}),document.body.removeChild(t),e&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(e))}}};e(230),e(98),e(132),e(134),e(364);!function(n,t){void 0===t&&(t={});var e=t.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===e&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var hs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ms={},vs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},gs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:hs[n]},bs=function n(t,e,r){var i=document.createElement(t);return e&&Object.keys(e).forEach((function(n){if(n.indexOf("data"))i[n]=e[n];else{var t=n.replace("data","");i.dataset[t]=e[n]}})),r&&r.forEach((function(t){var e=t.tag,r=t.attrs,o=t.children;i.appendChild(n(e,r,o))})),i},ys=function(n,t,e){var r,i=(r=n.querySelectorAll(".".concat(t)),Array.prototype.slice.call(r));return 1!==i.length||e?i:i[0]},xs=function(n,t){var e,r,i=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};s.htmlTpl=vs(s.html),s.jsTpl=(e=s.js,r=e.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,t){var e=n.split(/export\s+default/),r="(function() {".concat(e[0]," ; return ").concat(e[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](i);return o.template=t,o}(s.js,s.html);var c=gs("vue");return s.jsLib.unshift(c),s},As=function(n,t){var e,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),a={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(e=a.js,window.Babel?window.Babel.transform(e,{presets:["es2015"]}).code:e),a},Cs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ss(){var n=ys(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var t=ys(n,"vuepress-plugin-demo-block__code"),e=ys(n,"vuepress-plugin-demo-block__display"),r=ys(n,"vuepress-plugin-demo-block__footer"),i=ys(e,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),a=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);a=a?JSON.parse(a):{};var c=t.querySelector("div").clientHeight,u="react"===s?function(n,t){var e=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(e,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),o={js:i,css:i.__style__||"",jsLib:t.jsLib||[],cssLib:t.cssLib||[],jsTpl:Cs(n),htmlTpl:vs("")},a=gs("react"),s=gs("reactDOM");return o.jsLib.unshift(a,s),o}(o,a):"vanilla"===s?As(o,a):xs(o,a),l=bs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(l),l.addEventListener("click",ws.bind(null,l,c,t,r)),gs("jsfiddle")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,a=i.concat(o).concat(gs("cssLib")).concat(gs("jsLib")).join(",");return bs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:t}},{tag:"input",attrs:{type:"hidden",name:"html",value:e}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(u)),gs("codepen")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,a=JSON.stringify({css:t,html:e,js:r,js_external:i.concat(gs("jsLib")).join(";"),css_external:o.concat(gs("cssLib")).join(";"),layout:gs("codepenLayout"),js_pre_processor:gs("codepenJsProcessor"),editors:gs("codepenEditors")});return bs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(u)),void 0!==a.horizontal?a.horizontal:gs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=t.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),e.appendChild(p)}if(u.css&&function(n){if(!ms[n]){var t=bs("style",{innerHTML:n});document.body.appendChild(t),ms[n]=!0}}(u.css),"react"===s)ReactDOM.render(React.createElement(u.js),i);else if("vue"===s){var d=(new(Vue.extend(u.script))).$mount();i.appendChild(d.$el)}else"vanilla"===s&&(i.innerHTML=u.html,new Function("return (function(){".concat(u.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ss()}),300)}function ws(n,t,e,r){var i="1"!==n.dataset.isExpand;e.style.height=i?"".concat(t,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Is={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ss()},updated:function(){Ss()}},Es=(e(219),"auto"),Ps="zoom-in",_s="zoom-out",Os="grab",Ds="move";function Ts(n,t,e){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(t,e,i):n.removeEventListener(t,e,i)}function ks(n,t){if(n){var e=new Image;e.onload=function(){t&&t(e)},e.src=n}}function Bs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function js(n,t,e){!function(n){var t=Us,e=Ls;if(n.transition){var r=n.transition;delete n.transition,n[t]=r}if(n.transform){var i=n.transform;delete n.transform,n[e]=i}}(t);var r=n.style,i={};for(var o in t)e&&(i[o]=r[o]||""),r[o]=t[o];return i}var Us="transition",Ls="transform",Rs="transform",Fs="transitionend";var Ms=function(){},zs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ms,onClose:Ms,onGrab:Ms,onMove:Ms,onRelease:Ms,onBeforeOpen:Ms,onBeforeClose:Ms,onBeforeGrab:Ms,onBeforeRelease:Ms,onImageLoading:Ms,onImageLoaded:Ms},Ns={init:function(n){var t,e;t=this,e=n,Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((function(n){t[n]=t[n].bind(e)}))},click:function(n){if(n.preventDefault(),Hs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,t=window.pageXOffset||n.scrollLeft,e=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:t,y:e});var r=this.lastScrollPosition.x-t,i=this.lastScrollPosition.y-e,o=this.options.scrollThreshold;(Math.abs(i)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Xs(n)&&!Hs(n)){n.preventDefault();var t=n.clientX,e=n.clientY;this.pressTimer=setTimeout(function(){this.grab(t,e)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Xs(n)&&!Hs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var t=n.touches[0],e=t.clientX,r=t.clientY;this.pressTimer=setTimeout(function(){this.grab(e,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var t=n.touches[0],e=t.clientX,r=t.clientY;this.move(e,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Xs(n){return 0===n.button}function Hs(n){return n.metaKey||n.ctrlKey}var $s={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,js(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ts(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){js(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ws="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Vs=function(){function n(n,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}}(),Gs=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r])}return n},qs={init:function(n,t){this.el=n,this.instance=t,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,t=n.zIndex,e=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:t+1,cursor:e?Os:_s,transition:Rs+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=js(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,js(this.el,{transform:"none"})},grab:function(n,t,e){var r=Js(),i=r.x-n,o=r.y-t;js(this.el,{cursor:Ds,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},move:function(n,t,e){var r=Js(),i=r.x-n,o=r.y-t;js(this.el,{transition:Rs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},restoreCloseStyle:function(){js(this.el,this.styleClose)},restoreOpenStyle:function(){js(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var t=this.el.cloneNode(!1);t.setAttribute("src",this.srcOriginal),t.style.position="fixed",t.style.visibility="hidden",n.appendChild(t),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(t)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Js(),t=this.rect.left+this.rect.width/2,e=this.rect.top+this.rect.height/2;return{x:n.x-t,y:n.y-e}},calculateScale:function(){var n=this.el.dataset,t=n.zoomingHeight,e=n.zoomingWidth,r=this.instance.options,i=r.customSize,o=r.scaleBase;if(!i&&t&&e)return{x:e/this.rect.width,y:t/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ws(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var a=this.rect.width/2,s=this.rect.height/2,c=Js(),u={x:c.x-a,y:c.y-s},l=u.x/a,p=u.y/s,d=o+Math.min(l,p);if(i&&"string"==typeof i){var f=e||this.el.naturalWidth,h=t||this.el.naturalHeight,m=parseFloat(i)*f/(100*this.rect.width),v=parseFloat(i)*h/(100*this.rect.height);if(d>m||d>v)return{x:m,y:v}}return{x:d,y:d}}};function Js(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ys(n,t,e){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Ts(n,r,t[r],e)}))}var Zs=function(){function n(t){!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(qs),this.overlay=Object.create($s),this.handler=Object.create(Ns),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Gs({},zs,t),this.overlay.init(this),this.handler.init(this)}return Vs(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var t=document.querySelectorAll(n),e=t.length;e--;)this.listen(t[e]);else"IMG"===n.tagName&&(n.style.cursor=Ps,Ts(n,"click",this.handler.click),this.options.preloadImage&&ks(Bs(n)));return this}},{key:"config",value:function(n){return n?(Gs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var t=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),ks(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ts(document,"scroll",this.handler.scroll),Ts(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ts(window,"resize",this.handler.resizeWindow);var o=function n(){Ts(r,Fs,n,!1),t.lock=!1,t.target.upgradeSource(),t.options.enableGrab&&Ys(document,t.handler,!0),e(r)};return Ts(r,Fs,o),this}}}},{key:"close",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeClose(e),this.lock=!0,this.body.style.cursor=Es,this.overlay.fadeOut(),this.target.zoomOut(),Ts(document,"scroll",this.handler.scroll,!1),Ts(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ts(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Ts(e,Fs,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ys(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),t(e)};return Ts(e,Fs,r),this}}},{key:"grab",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,t,e);var o=function n(){Ts(i,Fs,n,!1),r(i)};return Ts(i,Fs,o),this}}},{key:"move",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ds,this.target.move(n,t,e);var i=this.target.el,o=function n(){Ts(i,Fs,n,!1),r(i)};return Ts(i,Fs,o),this}}},{key:"release",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeRelease(e),this.lock=!0,this.body.style.cursor=Es,this.target.restoreOpenStyle();var r=function r(){Ts(e,Fs,r,!1),n.lock=!1,n.released=!0,t(e)};return Ts(e,Fs,r),this}}}]),n}(),Ks=".theme-vdoing-content img:not(.no-zoom)",Qs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nc=Number("500"),tc=function(){function n(){us(this,n),this.instance=new Zs(Qs)}return ps(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ks;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ks,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:nc;setTimeout((function(){return n.update(t)}),e)}}]),n}(),ec=[Qa,os,cs,fs,Is,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new tc,this.$vuepress.zooming.updateDelay()}}],rc={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Ga("layout",n),Bi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ic=e(29),oc=Object(ic.a)(rc,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,t,e){var r;switch(t){case"components":n[t]||(n[t]={}),Object.assign(n[t],e);break;case"mixins":n[t]||(n[t]=[]),(r=n[t]).push.apply(r,Object(Pa.a)(e));break;default:throw new Error("Unknown option name.")}}(oc,"mixins",ec);var ac=[{name:"v-11903474",path:"/c1/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-11903474").then(e)}},{path:"/c1/index.html",redirect:"/c1/"},{path:"/00.目录页/02.练习题.html",redirect:"/c1/"},{name:"v-65bcb3b0",path:"/c/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-65bcb3b0").then(e)}},{path:"/c/index.html",redirect:"/c/"},{path:"/00.目录页/50.C语言.html",redirect:"/c/"},{name:"v-e9c9f3c2",path:"/notes/0/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-e9c9f3c2").then(e)}},{path:"/notes/0/index.html",redirect:"/notes/0/"},{path:"/01.考试报名流程/00.考试报名流程.html",redirect:"/notes/0/"},{name:"v-0f04cd24",path:"/c1/1/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-0f04cd24").then(e)}},{path:"/c1/1/index.html",redirect:"/c1/1/"},{path:"/02.练习题/00.C语言编程题.html",redirect:"/c1/1/"},{name:"v-101804a5",path:"/c1/2/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-101804a5").then(e)}},{path:"/c1/2/index.html",redirect:"/c1/2/"},{path:"/02.练习题/01.微机原理简答题.html",redirect:"/c1/2/"},{name:"v-3be4d484",path:"/c1/3/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-3be4d484").then(e)}},{path:"/c1/3/index.html",redirect:"/c1/3/"},{path:"/02.练习题/02.微机原理填空题.html",redirect:"/c1/3/"},{name:"v-741e2425",path:"/c1/6/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-741e2425").then(e)}},{path:"/c1/6/index.html",redirect:"/c1/6/"},{path:"/02.练习题/05.微机原理简答题（分类）.html",redirect:"/c1/6/"},{name:"v-4bb22690",path:"/pages/038c37/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-4bb22690").then(e)}},{path:"/pages/038c37/index.html",redirect:"/pages/038c37/"},{path:"/10.关于/01.关于 - 我/01.关于 - 我.html",redirect:"/pages/038c37/"},{name:"v-557938bc",path:"/c1/4/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-557938bc").then(e)}},{path:"/c1/4/index.html",redirect:"/c1/4/"},{path:"/02.练习题/03.微机原理指令集.html",redirect:"/c1/4/"},{name:"v-257b116f",path:"/pages/c6c456/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-257b116f").then(e)}},{path:"/pages/c6c456/index.html",redirect:"/pages/c6c456/"},{path:"/10.关于/02.关于 - 本站/02.文档 -  快速上手.html",redirect:"/pages/c6c456/"},{name:"v-7c85b34c",path:"/pages/2a3030/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-7c85b34c").then(e)}},{path:"/pages/2a3030/index.html",redirect:"/pages/2a3030/"},{path:"/10.关于/02.关于 - 本站/03.文档 - md文件写作.html",redirect:"/pages/2a3030/"},{name:"v-d5fd0592",path:"/pages/39f283/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-d5fd0592").then(e)}},{path:"/pages/39f283/index.html",redirect:"/pages/39f283/"},{path:"/10.关于/02.关于 - 本站/05.文档 - 部署.html",redirect:"/pages/39f283/"},{name:"v-9e40a888",path:"/c1/5/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-9e40a888").then(e)}},{path:"/c1/5/index.html",redirect:"/c1/5/"},{path:"/02.练习题/04.输入输出系统接口芯片.html",redirect:"/c1/5/"},{name:"v-b75bc230",path:"/c/note1/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-b75bc230").then(e)}},{path:"/c/note1/index.html",redirect:"/c/note1/"},{path:"/50.C语言/02.第一章基础语法.html",redirect:"/c/note1/"},{name:"v-0ebed345",path:"/pages/8bac8d/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-0ebed345").then(e)}},{path:"/pages/8bac8d/index.html",redirect:"/pages/8bac8d/"},{path:"/10.关于/02.关于 - 本站/12.标题 - 锚点比较.html",redirect:"/pages/8bac8d/"},{name:"v-7cfc0d66",path:"/c/note3/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-7cfc0d66").then(e)}},{path:"/c/note3/index.html",redirect:"/c/note3/"},{path:"/50.C语言/04.第三章数组.html",redirect:"/c/note3/"},{name:"v-579999c0",path:"/pages/2bde62/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-579999c0").then(e)}},{path:"/pages/2bde62/index.html",redirect:"/pages/2bde62/"},{path:"/10.关于/02.关于 - 本站/11.标题 - 目录生成.html",redirect:"/pages/2bde62/"},{name:"v-11af5453",path:"/c/note2/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-11af5453").then(e)}},{path:"/c/note2/index.html",redirect:"/c/note2/"},{path:"/50.C语言/03.第二章控制语句.html",redirect:"/c/note2/"},{name:"v-744e4a64",path:"/c/note5/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-744e4a64").then(e)}},{path:"/c/note5/index.html",redirect:"/c/note5/"},{path:"/50.C语言/06.第五章指针.html",redirect:"/c/note5/"},{name:"v-06417f73",path:"/c/note4/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-06417f73").then(e)}},{path:"/c/note4/index.html",redirect:"/c/note4/"},{path:"/50.C语言/05.第四章函数实现模块化设计.html",redirect:"/c/note4/"},{name:"v-5476c9e9",path:"/c/note0/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-5476c9e9").then(e)}},{path:"/c/note0/index.html",redirect:"/c/note0/"},{path:"/50.C语言/01.C语言发展历程.html",redirect:"/c/note0/"},{name:"v-a1b67a0a",path:"/c/note7/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-a1b67a0a").then(e)}},{path:"/c/note7/index.html",redirect:"/c/note7/"},{path:"/50.C语言/08.第七章对文件的输入输出.html",redirect:"/c/note7/"},{name:"v-f4040932",path:"/c/note8/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-f4040932").then(e)}},{path:"/c/note8/index.html",redirect:"/c/note8/"},{path:"/50.C语言/09.变量的存储类别及作用域.html",redirect:"/c/note8/"},{name:"v-30d162f2",path:"/vue/note0/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-30d162f2").then(e)}},{path:"/vue/note0/index.html",redirect:"/vue/note0/"},{path:"/70.vue/01.vue.html",redirect:"/vue/note0/"},{name:"v-556e5941",path:"/smc/0/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-556e5941").then(e)}},{path:"/smc/0/index.html",redirect:"/smc/0/"},{path:"/60.SMC/01.前言.html",redirect:"/smc/0/"},{name:"v-334cc282",path:"/c/note6/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-334cc282").then(e)}},{path:"/c/note6/index.html",redirect:"/c/note6/"},{path:"/50.C语言/07.第六章自定数据类型.html",redirect:"/c/note6/"},{name:"v-47c172c3",path:"/smc/2/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-47c172c3").then(e)}},{path:"/smc/2/index.html",redirect:"/smc/2/"},{path:"/60.SMC/03.第二章80X86微处理器.html",redirect:"/smc/2/"},{name:"v-a66c34a6",path:"/smc/1/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-a66c34a6").then(e)}},{path:"/smc/1/index.html",redirect:"/smc/1/"},{path:"/60.SMC/02.第一章计算机基础知识.html",redirect:"/smc/1/"},{name:"v-d83bdb10",path:"/smc/3/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-d83bdb10").then(e)}},{path:"/smc/3/index.html",redirect:"/smc/3/"},{path:"/60.SMC/04.第三章微型计算机的基本工作原理.html",redirect:"/smc/3/"},{name:"v-d4c9be1a",path:"/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-d4c9be1a").then(e)}},{path:"/index.html",redirect:"/"},{name:"v-7fb91247",path:"/archives/",component:oc,beforeEnter:function(n,t,e){Va("Layout","v-7fb91247").then(e)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{path:"*",component:oc}],sc={title:"wfmiss Notes",description:"我们在黑暗中并肩前行，走在各自的朝圣路上!",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"wfmiss,eric"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"c语言页面",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.练习题",imgUrl:"/img/web.png",description:"c语言编程题"}},title:"c语言页面",permalink:"/c1",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-05-09T13:57:16.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E7%BB%83%E4%B9%A0%E9%A2%98.html",relativePath:"00.目录页/02.练习题.md",key:"v-11903474",path:"/c1/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"c语言页面",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.C语言",imgUrl:"/img/web.png",description:"c语言笔记"}},title:"c语言页面",permalink:"/c",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-05-09T13:57:16.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/50.C%E8%AF%AD%E8%A8%80.html",relativePath:"00.目录页/50.C语言.md",key:"v-65bcb3b0",path:"/c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"报名流程",frontmatter:{title:"报名流程",date:"2022-03-10T15:30:00.000Z",permalink:"/notes/0",author:{name:"eric",href:"https://xt.wfmiss.cn"}},regularPath:"/01.%E8%80%83%E8%AF%95%E6%8A%A5%E5%90%8D%E6%B5%81%E7%A8%8B/00.%E8%80%83%E8%AF%95%E6%8A%A5%E5%90%8D%E6%B5%81%E7%A8%8B.html",relativePath:"01.考试报名流程/00.考试报名流程.md",key:"v-e9c9f3c2",path:"/notes/0/",headers:[{level:2,title:"1、考生注册",slug:"_1、考生注册",normalizedTitle:"1、考生注册",charIndex:33},{level:2,title:"2、报名",slug:"_2、报名",normalizedTitle:"2、报名",charIndex:175},{level:2,title:"3、缴费（收费标准  ）",slug:"_3、缴费-收费标准",normalizedTitle:"3、缴费（收费标准  ）",charIndex:null},{level:2,title:"4、下一步",slug:"_4、下一步",normalizedTitle:"4、下一步",charIndex:539}],headersStr:"1、考生注册 2、报名 3、缴费（收费标准  ） 4、下一步",content:"# 报名流程\n\n3月11日上午9点——3月15日下午5点\n\n\n# 1、考生注册\n\n * 打开河北省专接本报名系统网址：河北省专接本报名系统\n\n * http://zjbks.hee.gov.cn/\n\n * 点击考生注册---\x3e注册完成后开始登录\n\n * 用户名：本人身份证号码;密码：（初始密码）本人省份证号后六位\n\n应及时登录系统修改密码\n\n\n# 2、报名\n\n重要的事说三遍：（填写时确认信息正确）\n\n缴费确认后信息将不能修改！\n\n缴费确认后信息将不能修改！\n\n缴费确认后信息将不能修改！\n\n登录完成后选择考生专业志愿填报\n\n * 点击 第一步：网上报名须知---\x3e阅读完成后点击 我已阅知 进入第二步；\n\n * 点击 第二部：报考信息录入---\x3e填写相应信息（填写时一定要认真核对填写信息）---\x3e保存\n\n * 点击 第三步：报考信息确认---\x3e查看已经填写的信息（确认无误后！）---\x3e进入第四步\n\n * 点击 第四步：缴费状态查看---\x3e勾选同意诚信协议确认（下载）---\x3e填写缴费手机号---\x3e点击入缴费系统进行缴费即可！\n\n\n# 3、缴费（收费标准 ）\n\n1、报名缴费成功后，不可退款\n\n2、具体收费标准为：艺术、体育类每生120元、其他类别每生100元。\n\n\n# 4、下一步\n\n需要等待24小时，出现支付成功页面，自己 下载保存好诚信协议和考生报名表即可。",normalizedContent:"# 报名流程\n\n3月11日上午9点——3月15日下午5点\n\n\n# 1、考生注册\n\n * 打开河北省专接本报名系统网址：河北省专接本报名系统\n\n * http://zjbks.hee.gov.cn/\n\n * 点击考生注册---\x3e注册完成后开始登录\n\n * 用户名：本人身份证号码;密码：（初始密码）本人省份证号后六位\n\n应及时登录系统修改密码\n\n\n# 2、报名\n\n重要的事说三遍：（填写时确认信息正确）\n\n缴费确认后信息将不能修改！\n\n缴费确认后信息将不能修改！\n\n缴费确认后信息将不能修改！\n\n登录完成后选择考生专业志愿填报\n\n * 点击 第一步：网上报名须知---\x3e阅读完成后点击 我已阅知 进入第二步；\n\n * 点击 第二部：报考信息录入---\x3e填写相应信息（填写时一定要认真核对填写信息）---\x3e保存\n\n * 点击 第三步：报考信息确认---\x3e查看已经填写的信息（确认无误后！）---\x3e进入第四步\n\n * 点击 第四步：缴费状态查看---\x3e勾选同意诚信协议确认（下载）---\x3e填写缴费手机号---\x3e点击入缴费系统进行缴费即可！\n\n\n# 3、缴费（收费标准 ）\n\n1、报名缴费成功后，不可退款\n\n2、具体收费标准为：艺术、体育类每生120元、其他类别每生100元。\n\n\n# 4、下一步\n\n需要等待24小时，出现支付成功页面，自己 下载保存好诚信协议和考生报名表即可。",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"C语言编程题",frontmatter:{title:"C语言编程题",date:"2022-03-04T15:30:00.000Z",permalink:"/c1/1",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/00.C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%A2%98.html",relativePath:"02.练习题/00.C语言编程题.md",key:"v-0f04cd24",path:"/c1/1/",headersStr:null,content:'# C语言编程题\n\n * 将输入的数字逆序输出\n\n#include<stdio.h>\nvoid main(){\n    int x=0;\n    scanf("%d",&x);\n    while (x!=0)\n    {   \n        printf("%d",x%10);\n        x/=10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 将输入数字，逆序组成一个数字输出\n\n#include<stdio.h>\nvoid main(){\n    int num,snum;\n    scanf("%d",&num);\n    snum=num%10;\n    num/=10;\n    while (num!=0)\n    {\n        snum=snum*10+num%10;\n        num/=10;\n    }\n    printf("%d",snum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 九九乘法表\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=9;i++){\n        for(m=1;m<=i;m++){printf("%d*%d=%2d  ",m,i,i*m);}\n        printf("\\n");\n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输出直角三角形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=5;i++){\n     for(m=i;m>=1;m--)printf("*");\n     printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输出等腰三角形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=5;i++){\n        for(m=1;m<=5-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 输出菱形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=4;i++){\n        for(m=1;m<=4-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n    for(i=3;i>=1;i--){\n        for(m=1;m<=4-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 费波那西(Fibonacci)数列：第1，2个数为1，从第三个数开始为前两个数的和(输出前40个数)\n\n提示：a1=a2=1；a[n]=a[n-1]+a[n-2];\n\n#include<stdio.h>\nvoid main(){\n    //方法一：\n    long num[40];\n    int i=2;\n    num[0]=1;\n    num[1]=1;\n    while (i<40)\n    {\n        num[i]=num[i-1]+num[i-2];\n        i++;\n    }\n    i=0;\n    while (i<40)\n    {\n        printf("%d\\n",num[i]);\n        i++;\n    }\n    //方法二：\n    int f1=1,f2=1,i=1;\n    while (i<=20)\n    {\n        printf("%12d %12d",f1,f2);\n        if(i%2==0) printf("\\n");\n        f1=f1+f2;\n        f2=f1+f2;\n        i++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 判断一个数是否为素数\n\n#include<stdio.h>\nvoid main(){\n    int num1=0,num2;\n    scanf("%d",&num1);\n    num2=num1-1;\n    while (num2>1)\n    {\n        if(num1%num2==0) break;\n        num2--;\n    }\n    if(num2>1) printf("%d,此数不是素数！",num1);\n    else printf("%d,此个数是素数！",num1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 水仙花数（每位数字的立方和等于自己）\n\n#include<stdio.h>\n#include<math.h>\nvoid main(){\n    float sum=0;\n    int s,i=100;\n    while (i<=999)\n    {\n        s=i;\n        while (s>0)\n        {\n            sum+=pow(s%10,3.0);\n            s/=10;\n        }\n        if(sum==i) printf("%.1f ",sum);\n        sum=0;\n        i++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 译密码\n\n提示：A->E,B->F,C->G,D->H;W->A,X->B,Y->C,Z->D\n\n#include<stdio.h>\nvoid main(){\n    char str;\n    while ((str=getchar())!=\'\\n\')\n    {\n        if ((str>=\'A\'&&str<=\'V\')||(str>=\'a\'&&str<=\'v\'))\n            printf("%c\\n",str+4);\n        if ((str>=\'W\'&&str<=\'Z\')||(str>=\'w\'&&str<=\'z\'))\n            printf("%c\\n",str-22);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 求1000以内的所有完全数，一个数如果恰好等于它的因子之和，这个数就成为“完全数”\n\n#include<stdio.h>\nvoid main(){\n//方法一：\n    int i=1,x,sum;\n    while (i<1000)\n    {\n        sum=0;\n        x=1;\n        while (x<i)\n        {\n            if(i%x==0)sum+=x;\n            x++;\n        }\n        if(sum==i)printf("%4d",x);\n        i++;\n    }\n//方法二：\n    int s;\n    for (int i=1;i<1000; i++)\n    {\n        s=0;\n        for (int k = 1; k<i; k++)\n            if(i%k==0) s+=k;\n        if(s==i)printf("%4d",i);   \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 输入一行字符，统计各个大写字母出现的次数\n\n#include<stdio.h>\nvoid main(){\n    int i,num[26]={0};\n    char str=0;\n    while ((str=getchar())!=\'\\n\')\n        if(str>=\'A\'&&str<=\'Z\') num[str-\'A\']++;\n    for ( i = 0; i < 26; i++)\n        printf("%c(%d)\\n",\'A\'+i,num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 输入一行字符，统计各个数字出现的次数\n\n#include<stdio.h>\nvoid main(){\n    int i,num[10]={0};\n    char str=0;\n    while ((str=getchar())!=\'\\n\')\n        if(str>=\'0\'&&str<=\'9\') num[str-\'0\']++;\n    for ( i = 0; i < 10; i++)\n        printf("%c(%d)\\n",\'0\'+i,num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 冒泡排序（从小到大）\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},t;\n    for(int j=0;j<10>;j++){\n        for(int i=0;i<j;i++){\n            if(num[i]>num[i+1]){\n                t=num[i+1];\n                num[i+1]=num[i];\n                num[i]=t;\n            }\n        }\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 冒泡排序（从大到小）\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},t;\n    for(int j=0;j<10;j++){\n        for(int i=0;i<9-j;i++){\n            if(num[i]<num[i+1]){\n                t=num[i+1];\n                num[i+1]=num[i];\n                num[i]=t;\n            }\n        }\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 选择排序法：每一趟从无序区选一个最小的元素，与无序区第一个元素交换\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},min,t;\n    for(int i=0;i<9;i++){\n        min=i;\n        for (int j=i+1;j<10;j++)\n            min=num[j]<num[min]?j:min;\n        t=num[i];\n        num[i]=num[min];\n        num[min]=t;\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 将一个二维数组和列元素互换 ，存到另一个二维数组中。\n\n#include<stdio.h>\nvoid main(){\n/*\n测试输入的数据：\n12 22 33\n44 55 66\n*/\n    int a[2][3],b[3][2];\n    printf("输入一个二维矩阵：\\n");\n    for(int i=0;i<2;i++)\n    \tfor(int j=0;j<3;j++)\n    \t\tscanf("%d",&a[i][j]);\n\n    for(int i=0;i<2;i++)\n    \tfor(int j=0;j<3;j++)\n     \t\tb[j][i]=a[i][j];\n    \n    printf("交换行列后:\\n");\n    for(int i=0;i<3;i++){\n    \tfor(int j=0;j<2;j++)\n    \t\tprintf("%4d",b[i][j]);\n    \tprintf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 将二维数组a[n][n]中的元素行列互换，存到a[n][n]中\n\n#include<stdio.h>\nvoid main(){\n/**\n测试输入数据：\n12 22 33\n44 55 66\n77 88 99\n**/\n    int a[3][3],b,i=0;\n    printf("输入一个二维矩阵：\\n");\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            scanf("%d",&a[i][j]);\n    for(int j=0;j<3;j++){\n        b=a[0][j];\n        a[0][j]=a[j][0];\n        a[j][0]=b;\n    }\n\n    printf("交换行列后:\\n");\n    for(i=0;i<3;i++){\n        for(int j=0;j<3;j++)\n            printf("%4d",a[i][j]);\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 打印杨辉三角（要求打印出10行）\n\n提示：a[i][j]=a[i-1][j-1]+a[i-1][j];\n\n#include<stdio.h>\nvoid main(){\n    int a[10][10]={0},i=0,j=0;\n    for(i=0;i<10;i++){\n        a[i][i]=1;\n        a[i][0]=1;\n    }\n    for (i = 2; i < 10; i++)\n        for(j=1;j<i;j++)\n            a[i][j]=a[i-1][j-1]+a[i-1][j];\n    \n    for ( i = 0; i < 10; i++)\n    {\n        for(j=0;j<=i;j++)\n            printf("%4d",a[i][j]);\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 求字符串长度\n\n#include<stdio.h>\nvoid main(){\n    char str[]="hello";\n    int count=0;\n    while (str[count]!=\'\\0\')\n    {\n        count++;\n    }\n    printf("%d",count);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 从键盘输入一个不超过9个字符的字符串，以回车结束，判断其中数字字符个数。\n\n#include<stdio.h>\nvoid main(){\n    char str[10];\n    int i=0,sum=0;\n    while((str[i++]=getchar())!=\'\\n\'){\n        if(str[i-1]>= \'0\' && str[i-1]<=\'9\'){\n            sum++;\n        }\n    }\n    printf("%d个数字符\\n",sum);\n}\n/*\n\t用一维数组可以表示一个字符串，但字符数组不是字符串！C语言没有字符串变量。仅借用字符数组表示串。\n\t字符数组与字符串的区别在于后者一定有一个\'\\0\'，用作串的结束标志！\n\t因此字符数组存放串的长度至多=字符数组长度-1\n\t用字符数组表示字符串的初始化——用字符串常量来初始化字符数组\n\tchar c[]={"I am happy"};或char c[]="I am happy";\n\t初始化后：字符串长度为：10；字符数组长度为：11；\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 输入一个字符串逆序后输出\n\n#include<stdio.h>\n#include<string.h>\nvoid main(){\n    char str[80],c;\n    int i,j,k=0;\n    gets(str);\n    j=strlen(str);\n    i=j/2;\n    while (i>0)\n    {\n        c=str[--j];\n        str[j]=str[k];\n        str[k++]=c;\n        i--;\n    }\n    puts(str);\n}\n/*\n使用字符处理函数需要加上<string.h>\ngets(str):输入一个字符串\nputs(str):输出一个字符串\nstrlen(str):获取字符串长度（不加‘\\0’）\nstrcpy(str1,str2):将str2的串复制到str1（str2的位置可以是"字符串"）\nstrcmp(str1,str2):将str1与str2的字符逐个比较\n\t\t\t\t  【str1<str2=-1；str1==str2=0；str1>str2=1】\nstrcat(str1,str2):将str2的串拼接到str1后面\n\t\t\t\t  （str1的长度必须足够长，str2的位置可以是"字符串"）\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 有三个字符串，要求找出其中最大者\n\n#include<stdio.h>\n#include<string.h>\nvoid main(){\n    char s[3][4]={"csd","cxz","scc"};\n    int max=0;\n    for(int i=1;i<3;i++) max=strcmp(s[max],s[i])?i:max;\n    puts(s[max]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输入一行字符，统计其中有多少个单词，单词之间用空格隔开\n\n#include<stdio.h>\nvoid main(){\n    char str[80];\n    gets(str);\n    int i=0,sum=0,bool=0;\n    while (str[i]!=\'\\0\')\n    {\n        if(str[i]==\' \')bool=0;\n        else if(bool==0){\n            sum++;\n            bool=1;\n        } \n        i++;\n    }\n    printf("共有 %d 个单词！",sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 从键盘任意输入a,b,c的值，编程计算并输出一元二次方程ax²+bx+c=0的两个实根，否则就输出“方程无实根”的信息。\n\n提示：b²-4ac>=0则x1、x2为实根\n#include <stdio.h>\n#include <math.h>\nvoid main()\n{\n    double a,b,c,disc,x1,x2,p,q;\n    scanf("%lf%lf%lf",&a,&b,&c);\n    disc=b*b-4*a*c;\n    if(disc<0)printf(“has not real roots\\n”);\n    else{\n    \tp=-b/(2.0*a);\n    \tq=sqrt(disc)/(2.0*a);\n    \tx1=p+q;\n    \tx2=p-q;\n    \tprintf(“real roots:\\nx1=%7.2f\\n x2=%7.2f\\n”,x1,x2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 有n个人围成一群圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位。\n\n/*\n经典算法--约瑟夫环问题：\n\t约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。通常解决这类问题时我们把编号从0~n-1，最后 [1]  结果+1即为原问题的解。\n*/\n#include<stdio.h>\nint main()\n{\n\tint n,num[100],count=0,i,temp;\n\tprintf("请输入总人数n=");\n\tscanf("%d",&n);\n\ttemp=n;\n\tfor ( i = 0; i < n; i++) num[i]=i+1;\n\ti=0;\n\twhile(temp>1)\n\t{\n\t\tif(num[i]!=0) count++;\n\t\tif(count==3){\n\t\t\tnum[i]=0;\n\t\t\tcount=0;\n\t\t\ttemp--;\n\t\t}\n\t\ti++;\n\t\tif(i==n)i=0;\n\t}\n\tfor ( i = 0; i < n; i++)\n\t\tif(num[i]!=0)printf("剩下的：%d",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 两个乒乓球队员进行比赛，各出三人。甲队为a，b，c三人，乙队为x，y，z三人。已抽签决定比赛名单。有人向队员打听比赛名单。a说他不和x比赛，c说他不和x，y比，请编程找出三队赛手的名单。\n\n#include<stdio.h>\nvoid main(){\n\tchar i,j,k;\t\t\t\t\t\t\t\t\t\t\t//定义3个字符变量，分别表示 i是a的对手，j是b的对手，k是c的对手 \n\tfor(i=\'x\';i<=\'z\';i++){ \t\t\t\t\t\t\t\t//匹配a的对手\n\t\tfor(j=\'x\';j<=\'z\';j++){  \t\t\t\t\t\t//匹配b的对手\n\t\t\tif(i!=j){ \t\t\t\t\t\t\t\t\t//确保b的对手与a不是同一人  \n\t\t\t\tfor(k=\'x\';k<=\'z\';k++){  \t\t\t\t//匹配c的对手\n\t\t\t\t\tif(i!=k&&j!=k){ \t\t\t\t\t//确保c的对手与a、b不是同一人 \n\t\t\t\t\t\tif(i!=\'x\'&&k!=\'x\'&&k!=\'z\'){ \t//确保a不和x比，c不和x、z比 \n\t\t\t\t\t\t\tprintf("a 的对手为 %c\\nb 的对手为 %c\\nc 的对手为 %c\\n",i,j,k);  //输出结果 \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 编写程序，删除一维数组中重复出现的元素。\n\n#include<stdio.h>\nvoid main(){\nint i, j, n = 20, k = 0;\n\tint arr[20] = { 10 ,3, 2 ,3 ,4 ,9,4, 5, 6, 6, 3 ,3 ,7, 7, 8, 9, 9, 10, 10, 10 };\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = i + 1; j < n; j++)//每次都是和i的下一个元素比较比较到最后一个元素\n\t\t{\n\t\t\tif (arr[i] == arr[j]) {//下个元素的值和当前的元素值相等\n\t\t\t\tfor (k = j; k < n - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tarr[k] = arr[k + 1];\n            /*把下下一个元素的值放到的重复的元素下标上，arr[i]就是保留下来的一个值\n              即跳过保留下的值把重复的值用下一个值就行填充覆盖*/\n\t\t\t\t}\n\t\t\t\tn--;//进行完上一次的往前挪的操作进行长度减少\n\t\t\t\tj--;//重新指回上一次元素匹配相等的下标\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < n; ++i)\n\t\tprintf("%d,", arr[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 编写程序，输入两个正整数m和n，求其最大公约数和最小公倍数。\n\n//1、求最大公约数和最小公倍数要求分别用函数实现；\n//最大公约数：更相减损术；\nint GreatestCommonDivisor(int n, int m)\n{\n    int temp;\n    while (n!=m)\n    {\n        if(n<m){\n            temp=n;\n            n=m;\n            m=temp;\n        }\n        n-=m;\n    }\n    return n;\n}\n//最小公倍数：两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。\nint LeastCommonMultiple(int n, int m)\n{\n    int temp, p, r;\n    if (n < m)\n    {\n        temp = n;\n        n = m;\n        m = temp;\n    }\n    p = m * n;\n    while (m != 0) //通过循环求两数的余数\n    {\n        r = n % m; // r为余数\n        n = m;\n        m = r;\n    }\n    return n;\n}\n\n//2、编写主函数输入，调用函数，输出；\n#include<stdio.h>\nvoid main(){\n    int m, n, p;\n    printf("请输入两个整数：\\n");\n    scanf("%d,%d", &n, &m);\n    p = GreatestCommonDivisor(n, m);\n    n = LeastCommonMultiple(n, m);\n    printf("最大公约数为：%d\\n", n);\n    printf("最小公倍数为：%d\\n", p);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 编写程序，利用e^x^=1+x+x^2^/2!+x^3^/3!+x^4^/4!……，计算e^x^的近似值，要求误差小于10^-6^。\n\n#include<stdio.h>\n#define EPS 1e-6\nvoid main(){\n#include <stdio.h>\n    double e, item;\n    int i, x;\n    scanf("%d", &x);\n    item = 1;\n    e = 1;\n    i = 1;\n    do\n    {\n        item = item * i;\n        e = e + x / item;\n        i++;\n        x = x * x;\n    } while (1.0 / item > EPS);\n    printf("e=%lf\\n", e);\n    printf("共累加了%d 项\\n", i - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 编写程序，判断是否是回文数（回文数：数字对称，如：12321，123321）。\n\n#include <stdio.h>\nint main()\n{\n    int b[10], i, j, k, m;\n    long num, n;\n    printf("输入一个正整数:");\n    scanf("%ld", &num);\n    k = 0;\n    n = num;\n    do\n    {\n        b[k++] = n % 10;\n        n = n / 10;\n    } while (n != 0);\n    m = 1;\n    for (i = 0; i <= (k - 1) / 2; i++)\n        if (b[i] != b[k - 1 - i])\n            m = 0;\n    if (m)\n        printf("%ld 是回文数", num);\n    else\n        printf("%ld 是不回文数", num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 编程：输入一行字符，分别统计求出其中的英文字母、空格、数字和其他字符的个数并输出结果。\n\n#include <stdio.h>\nvoid main()\n{\n    char ch;\n    int char_num = 0, kg_num = 0, int_num = 0, other_num = 0;\n    while ((ch = getchar()) != \'\\n\')\n    {\n        if (ch >= \'a\' && ch <= \'z\' || ch <= \'z\' && ch >= \'a\')\n            char_num++;\n        else if (ch == \' \')\n            kg_num++;\n        else if (ch >= \'0\' && ch <= \'9\')\n            int_num++;\n        else\n            other_num++;\n    }\n    printf("字母= %d,空格= %d,数字= %d,其它= %d\\n", char_num, kg_num, int_num, other_num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * ----------------------------------------\n\n#include<stdio.h>\nvoid main(){\n\n}\n\n\n1\n2\n3\n4\n\n\n * ----------------------------------------\n\n#include<stdio.h>\nvoid main(){\n\n}\n\n\n1\n2\n3\n4\n',normalizedContent:'# c语言编程题\n\n * 将输入的数字逆序输出\n\n#include<stdio.h>\nvoid main(){\n    int x=0;\n    scanf("%d",&x);\n    while (x!=0)\n    {   \n        printf("%d",x%10);\n        x/=10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 将输入数字，逆序组成一个数字输出\n\n#include<stdio.h>\nvoid main(){\n    int num,snum;\n    scanf("%d",&num);\n    snum=num%10;\n    num/=10;\n    while (num!=0)\n    {\n        snum=snum*10+num%10;\n        num/=10;\n    }\n    printf("%d",snum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 九九乘法表\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=9;i++){\n        for(m=1;m<=i;m++){printf("%d*%d=%2d  ",m,i,i*m);}\n        printf("\\n");\n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输出直角三角形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=5;i++){\n     for(m=i;m>=1;m--)printf("*");\n     printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输出等腰三角形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=5;i++){\n        for(m=1;m<=5-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 输出菱形\n\n#include<stdio.h>\nvoid main(){\n    int i,m;\n    for(i=1;i<=4;i++){\n        for(m=1;m<=4-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n    for(i=3;i>=1;i--){\n        for(m=1;m<=4-i;m++) printf(" ");\n        for(m=1;m<=i*2-1;m++) printf("*");\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 费波那西(fibonacci)数列：第1，2个数为1，从第三个数开始为前两个数的和(输出前40个数)\n\n提示：a1=a2=1；a[n]=a[n-1]+a[n-2];\n\n#include<stdio.h>\nvoid main(){\n    //方法一：\n    long num[40];\n    int i=2;\n    num[0]=1;\n    num[1]=1;\n    while (i<40)\n    {\n        num[i]=num[i-1]+num[i-2];\n        i++;\n    }\n    i=0;\n    while (i<40)\n    {\n        printf("%d\\n",num[i]);\n        i++;\n    }\n    //方法二：\n    int f1=1,f2=1,i=1;\n    while (i<=20)\n    {\n        printf("%12d %12d",f1,f2);\n        if(i%2==0) printf("\\n");\n        f1=f1+f2;\n        f2=f1+f2;\n        i++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 判断一个数是否为素数\n\n#include<stdio.h>\nvoid main(){\n    int num1=0,num2;\n    scanf("%d",&num1);\n    num2=num1-1;\n    while (num2>1)\n    {\n        if(num1%num2==0) break;\n        num2--;\n    }\n    if(num2>1) printf("%d,此数不是素数！",num1);\n    else printf("%d,此个数是素数！",num1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 水仙花数（每位数字的立方和等于自己）\n\n#include<stdio.h>\n#include<math.h>\nvoid main(){\n    float sum=0;\n    int s,i=100;\n    while (i<=999)\n    {\n        s=i;\n        while (s>0)\n        {\n            sum+=pow(s%10,3.0);\n            s/=10;\n        }\n        if(sum==i) printf("%.1f ",sum);\n        sum=0;\n        i++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 译密码\n\n提示：a->e,b->f,c->g,d->h;w->a,x->b,y->c,z->d\n\n#include<stdio.h>\nvoid main(){\n    char str;\n    while ((str=getchar())!=\'\\n\')\n    {\n        if ((str>=\'a\'&&str<=\'v\')||(str>=\'a\'&&str<=\'v\'))\n            printf("%c\\n",str+4);\n        if ((str>=\'w\'&&str<=\'z\')||(str>=\'w\'&&str<=\'z\'))\n            printf("%c\\n",str-22);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 求1000以内的所有完全数，一个数如果恰好等于它的因子之和，这个数就成为“完全数”\n\n#include<stdio.h>\nvoid main(){\n//方法一：\n    int i=1,x,sum;\n    while (i<1000)\n    {\n        sum=0;\n        x=1;\n        while (x<i)\n        {\n            if(i%x==0)sum+=x;\n            x++;\n        }\n        if(sum==i)printf("%4d",x);\n        i++;\n    }\n//方法二：\n    int s;\n    for (int i=1;i<1000; i++)\n    {\n        s=0;\n        for (int k = 1; k<i; k++)\n            if(i%k==0) s+=k;\n        if(s==i)printf("%4d",i);   \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 输入一行字符，统计各个大写字母出现的次数\n\n#include<stdio.h>\nvoid main(){\n    int i,num[26]={0};\n    char str=0;\n    while ((str=getchar())!=\'\\n\')\n        if(str>=\'a\'&&str<=\'z\') num[str-\'a\']++;\n    for ( i = 0; i < 26; i++)\n        printf("%c(%d)\\n",\'a\'+i,num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 输入一行字符，统计各个数字出现的次数\n\n#include<stdio.h>\nvoid main(){\n    int i,num[10]={0};\n    char str=0;\n    while ((str=getchar())!=\'\\n\')\n        if(str>=\'0\'&&str<=\'9\') num[str-\'0\']++;\n    for ( i = 0; i < 10; i++)\n        printf("%c(%d)\\n",\'0\'+i,num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 冒泡排序（从小到大）\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},t;\n    for(int j=0;j<10>;j++){\n        for(int i=0;i<j;i++){\n            if(num[i]>num[i+1]){\n                t=num[i+1];\n                num[i+1]=num[i];\n                num[i]=t;\n            }\n        }\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 冒泡排序（从大到小）\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},t;\n    for(int j=0;j<10;j++){\n        for(int i=0;i<9-j;i++){\n            if(num[i]<num[i+1]){\n                t=num[i+1];\n                num[i+1]=num[i];\n                num[i]=t;\n            }\n        }\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 选择排序法：每一趟从无序区选一个最小的元素，与无序区第一个元素交换\n\n#include<stdio.h>\nvoid main(){\n    int num[10]={99,77,55,44,3,56,78,90,78,2},min,t;\n    for(int i=0;i<9;i++){\n        min=i;\n        for (int j=i+1;j<10;j++)\n            min=num[j]<num[min]?j:min;\n        t=num[i];\n        num[i]=num[min];\n        num[min]=t;\n    }\n    for(int i=0;i<10;i++) printf("%d\\n",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 将一个二维数组和列元素互换 ，存到另一个二维数组中。\n\n#include<stdio.h>\nvoid main(){\n/*\n测试输入的数据：\n12 22 33\n44 55 66\n*/\n    int a[2][3],b[3][2];\n    printf("输入一个二维矩阵：\\n");\n    for(int i=0;i<2;i++)\n    \tfor(int j=0;j<3;j++)\n    \t\tscanf("%d",&a[i][j]);\n\n    for(int i=0;i<2;i++)\n    \tfor(int j=0;j<3;j++)\n     \t\tb[j][i]=a[i][j];\n    \n    printf("交换行列后:\\n");\n    for(int i=0;i<3;i++){\n    \tfor(int j=0;j<2;j++)\n    \t\tprintf("%4d",b[i][j]);\n    \tprintf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 将二维数组a[n][n]中的元素行列互换，存到a[n][n]中\n\n#include<stdio.h>\nvoid main(){\n/**\n测试输入数据：\n12 22 33\n44 55 66\n77 88 99\n**/\n    int a[3][3],b,i=0;\n    printf("输入一个二维矩阵：\\n");\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            scanf("%d",&a[i][j]);\n    for(int j=0;j<3;j++){\n        b=a[0][j];\n        a[0][j]=a[j][0];\n        a[j][0]=b;\n    }\n\n    printf("交换行列后:\\n");\n    for(i=0;i<3;i++){\n        for(int j=0;j<3;j++)\n            printf("%4d",a[i][j]);\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 打印杨辉三角（要求打印出10行）\n\n提示：a[i][j]=a[i-1][j-1]+a[i-1][j];\n\n#include<stdio.h>\nvoid main(){\n    int a[10][10]={0},i=0,j=0;\n    for(i=0;i<10;i++){\n        a[i][i]=1;\n        a[i][0]=1;\n    }\n    for (i = 2; i < 10; i++)\n        for(j=1;j<i;j++)\n            a[i][j]=a[i-1][j-1]+a[i-1][j];\n    \n    for ( i = 0; i < 10; i++)\n    {\n        for(j=0;j<=i;j++)\n            printf("%4d",a[i][j]);\n        printf("\\n");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 求字符串长度\n\n#include<stdio.h>\nvoid main(){\n    char str[]="hello";\n    int count=0;\n    while (str[count]!=\'\\0\')\n    {\n        count++;\n    }\n    printf("%d",count);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 从键盘输入一个不超过9个字符的字符串，以回车结束，判断其中数字字符个数。\n\n#include<stdio.h>\nvoid main(){\n    char str[10];\n    int i=0,sum=0;\n    while((str[i++]=getchar())!=\'\\n\'){\n        if(str[i-1]>= \'0\' && str[i-1]<=\'9\'){\n            sum++;\n        }\n    }\n    printf("%d个数字符\\n",sum);\n}\n/*\n\t用一维数组可以表示一个字符串，但字符数组不是字符串！c语言没有字符串变量。仅借用字符数组表示串。\n\t字符数组与字符串的区别在于后者一定有一个\'\\0\'，用作串的结束标志！\n\t因此字符数组存放串的长度至多=字符数组长度-1\n\t用字符数组表示字符串的初始化——用字符串常量来初始化字符数组\n\tchar c[]={"i am happy"};或char c[]="i am happy";\n\t初始化后：字符串长度为：10；字符数组长度为：11；\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 输入一个字符串逆序后输出\n\n#include<stdio.h>\n#include<string.h>\nvoid main(){\n    char str[80],c;\n    int i,j,k=0;\n    gets(str);\n    j=strlen(str);\n    i=j/2;\n    while (i>0)\n    {\n        c=str[--j];\n        str[j]=str[k];\n        str[k++]=c;\n        i--;\n    }\n    puts(str);\n}\n/*\n使用字符处理函数需要加上<string.h>\ngets(str):输入一个字符串\nputs(str):输出一个字符串\nstrlen(str):获取字符串长度（不加‘\\0’）\nstrcpy(str1,str2):将str2的串复制到str1（str2的位置可以是"字符串"）\nstrcmp(str1,str2):将str1与str2的字符逐个比较\n\t\t\t\t  【str1<str2=-1；str1==str2=0；str1>str2=1】\nstrcat(str1,str2):将str2的串拼接到str1后面\n\t\t\t\t  （str1的长度必须足够长，str2的位置可以是"字符串"）\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 有三个字符串，要求找出其中最大者\n\n#include<stdio.h>\n#include<string.h>\nvoid main(){\n    char s[3][4]={"csd","cxz","scc"};\n    int max=0;\n    for(int i=1;i<3;i++) max=strcmp(s[max],s[i])?i:max;\n    puts(s[max]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 输入一行字符，统计其中有多少个单词，单词之间用空格隔开\n\n#include<stdio.h>\nvoid main(){\n    char str[80];\n    gets(str);\n    int i=0,sum=0,bool=0;\n    while (str[i]!=\'\\0\')\n    {\n        if(str[i]==\' \')bool=0;\n        else if(bool==0){\n            sum++;\n            bool=1;\n        } \n        i++;\n    }\n    printf("共有 %d 个单词！",sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 从键盘任意输入a,b,c的值，编程计算并输出一元二次方程ax²+bx+c=0的两个实根，否则就输出“方程无实根”的信息。\n\n提示：b²-4ac>=0则x1、x2为实根\n#include <stdio.h>\n#include <math.h>\nvoid main()\n{\n    double a,b,c,disc,x1,x2,p,q;\n    scanf("%lf%lf%lf",&a,&b,&c);\n    disc=b*b-4*a*c;\n    if(disc<0)printf(“has not real roots\\n”);\n    else{\n    \tp=-b/(2.0*a);\n    \tq=sqrt(disc)/(2.0*a);\n    \tx1=p+q;\n    \tx2=p-q;\n    \tprintf(“real roots:\\nx1=%7.2f\\n x2=%7.2f\\n”,x1,x2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 有n个人围成一群圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位。\n\n/*\n经典算法--约瑟夫环问题：\n\t约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。通常解决这类问题时我们把编号从0~n-1，最后 [1]  结果+1即为原问题的解。\n*/\n#include<stdio.h>\nint main()\n{\n\tint n,num[100],count=0,i,temp;\n\tprintf("请输入总人数n=");\n\tscanf("%d",&n);\n\ttemp=n;\n\tfor ( i = 0; i < n; i++) num[i]=i+1;\n\ti=0;\n\twhile(temp>1)\n\t{\n\t\tif(num[i]!=0) count++;\n\t\tif(count==3){\n\t\t\tnum[i]=0;\n\t\t\tcount=0;\n\t\t\ttemp--;\n\t\t}\n\t\ti++;\n\t\tif(i==n)i=0;\n\t}\n\tfor ( i = 0; i < n; i++)\n\t\tif(num[i]!=0)printf("剩下的：%d",num[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 两个乒乓球队员进行比赛，各出三人。甲队为a，b，c三人，乙队为x，y，z三人。已抽签决定比赛名单。有人向队员打听比赛名单。a说他不和x比赛，c说他不和x，y比，请编程找出三队赛手的名单。\n\n#include<stdio.h>\nvoid main(){\n\tchar i,j,k;\t\t\t\t\t\t\t\t\t\t\t//定义3个字符变量，分别表示 i是a的对手，j是b的对手，k是c的对手 \n\tfor(i=\'x\';i<=\'z\';i++){ \t\t\t\t\t\t\t\t//匹配a的对手\n\t\tfor(j=\'x\';j<=\'z\';j++){  \t\t\t\t\t\t//匹配b的对手\n\t\t\tif(i!=j){ \t\t\t\t\t\t\t\t\t//确保b的对手与a不是同一人  \n\t\t\t\tfor(k=\'x\';k<=\'z\';k++){  \t\t\t\t//匹配c的对手\n\t\t\t\t\tif(i!=k&&j!=k){ \t\t\t\t\t//确保c的对手与a、b不是同一人 \n\t\t\t\t\t\tif(i!=\'x\'&&k!=\'x\'&&k!=\'z\'){ \t//确保a不和x比，c不和x、z比 \n\t\t\t\t\t\t\tprintf("a 的对手为 %c\\nb 的对手为 %c\\nc 的对手为 %c\\n",i,j,k);  //输出结果 \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 编写程序，删除一维数组中重复出现的元素。\n\n#include<stdio.h>\nvoid main(){\nint i, j, n = 20, k = 0;\n\tint arr[20] = { 10 ,3, 2 ,3 ,4 ,9,4, 5, 6, 6, 3 ,3 ,7, 7, 8, 9, 9, 10, 10, 10 };\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = i + 1; j < n; j++)//每次都是和i的下一个元素比较比较到最后一个元素\n\t\t{\n\t\t\tif (arr[i] == arr[j]) {//下个元素的值和当前的元素值相等\n\t\t\t\tfor (k = j; k < n - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tarr[k] = arr[k + 1];\n            /*把下下一个元素的值放到的重复的元素下标上，arr[i]就是保留下来的一个值\n              即跳过保留下的值把重复的值用下一个值就行填充覆盖*/\n\t\t\t\t}\n\t\t\t\tn--;//进行完上一次的往前挪的操作进行长度减少\n\t\t\t\tj--;//重新指回上一次元素匹配相等的下标\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < n; ++i)\n\t\tprintf("%d,", arr[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 编写程序，输入两个正整数m和n，求其最大公约数和最小公倍数。\n\n//1、求最大公约数和最小公倍数要求分别用函数实现；\n//最大公约数：更相减损术；\nint greatestcommondivisor(int n, int m)\n{\n    int temp;\n    while (n!=m)\n    {\n        if(n<m){\n            temp=n;\n            n=m;\n            m=temp;\n        }\n        n-=m;\n    }\n    return n;\n}\n//最小公倍数：两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。\nint leastcommonmultiple(int n, int m)\n{\n    int temp, p, r;\n    if (n < m)\n    {\n        temp = n;\n        n = m;\n        m = temp;\n    }\n    p = m * n;\n    while (m != 0) //通过循环求两数的余数\n    {\n        r = n % m; // r为余数\n        n = m;\n        m = r;\n    }\n    return n;\n}\n\n//2、编写主函数输入，调用函数，输出；\n#include<stdio.h>\nvoid main(){\n    int m, n, p;\n    printf("请输入两个整数：\\n");\n    scanf("%d,%d", &n, &m);\n    p = greatestcommondivisor(n, m);\n    n = leastcommonmultiple(n, m);\n    printf("最大公约数为：%d\\n", n);\n    printf("最小公倍数为：%d\\n", p);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 编写程序，利用e^x^=1+x+x^2^/2!+x^3^/3!+x^4^/4!……，计算e^x^的近似值，要求误差小于10^-6^。\n\n#include<stdio.h>\n#define eps 1e-6\nvoid main(){\n#include <stdio.h>\n    double e, item;\n    int i, x;\n    scanf("%d", &x);\n    item = 1;\n    e = 1;\n    i = 1;\n    do\n    {\n        item = item * i;\n        e = e + x / item;\n        i++;\n        x = x * x;\n    } while (1.0 / item > eps);\n    printf("e=%lf\\n", e);\n    printf("共累加了%d 项\\n", i - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 编写程序，判断是否是回文数（回文数：数字对称，如：12321，123321）。\n\n#include <stdio.h>\nint main()\n{\n    int b[10], i, j, k, m;\n    long num, n;\n    printf("输入一个正整数:");\n    scanf("%ld", &num);\n    k = 0;\n    n = num;\n    do\n    {\n        b[k++] = n % 10;\n        n = n / 10;\n    } while (n != 0);\n    m = 1;\n    for (i = 0; i <= (k - 1) / 2; i++)\n        if (b[i] != b[k - 1 - i])\n            m = 0;\n    if (m)\n        printf("%ld 是回文数", num);\n    else\n        printf("%ld 是不回文数", num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 编程：输入一行字符，分别统计求出其中的英文字母、空格、数字和其他字符的个数并输出结果。\n\n#include <stdio.h>\nvoid main()\n{\n    char ch;\n    int char_num = 0, kg_num = 0, int_num = 0, other_num = 0;\n    while ((ch = getchar()) != \'\\n\')\n    {\n        if (ch >= \'a\' && ch <= \'z\' || ch <= \'z\' && ch >= \'a\')\n            char_num++;\n        else if (ch == \' \')\n            kg_num++;\n        else if (ch >= \'0\' && ch <= \'9\')\n            int_num++;\n        else\n            other_num++;\n    }\n    printf("字母= %d,空格= %d,数字= %d,其它= %d\\n", char_num, kg_num, int_num, other_num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * ----------------------------------------\n\n#include<stdio.h>\nvoid main(){\n\n}\n\n\n1\n2\n3\n4\n\n\n * ----------------------------------------\n\n#include<stdio.h>\nvoid main(){\n\n}\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/06/26, 10:06:00",lastUpdatedTimestamp:165621188e4},{title:"微机原理简答题",frontmatter:{title:"微机原理简答题",date:"2022-03-04T02:10:00.000Z",permalink:"/c1/2",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/01.%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AE%80%E7%AD%94%E9%A2%98.html",relativePath:"02.练习题/01.微机原理简答题.md",key:"v-101804a5",path:"/c1/2/",headers:[{level:2,title:"微机原理简答题",slug:"微机原理简答题",normalizedTitle:"微机原理简答题",charIndex:2}],headersStr:"微机原理简答题",content:'# 微机原理简答题\n\n简述触发器、寄存器与存储器之间的关系：\n\n答：触发器是计算机记忆装置的基本单元，一个触发器能存储一位二进制数也为一个一位寄存器；\n\t多个出触发器就可以构成一个多位寄存器，而一个寄存器为为一个存储单元；\n\t多个寄存器组成一个存储器。\n\n\n1\n2\n3\n\n\n计算机硬件组成的五个部件是什么：？\n\n答：输入设备、输出设备、运算器、存储器、控制器\n\n\n1\n\n\n计算器系统由什么组成？\n\n答：硬件系统和软件系统两部分组成。\n\n\n1\n\n\n简述总线的定义：\n\n答：在计算机系统中，各个部件之间传送信息的公共通道叫做总线（BUS），\n按照所传输的信息种类可划分为数据总线、地址总线、控制总线。\n\n\n1\n2\n\n\n简述RISC（精简指令集）的特点：\n\n答：1、CPU处理指令是由硬件完成、运行速度快；\n    2、指令长度固定、指令格式种类少、寻址方式种类少；\n    3、只有取数/存数指令访问存储器，其余指令的操作都在寄存器内完成；\n    4、采用流水线技术，大部分指令在一个时钟周期内完成；\n    5、控制器采用组合逻辑控制，不用微程序控制。\n    6、采用优化的编译程序。\n\n\n1\n2\n3\n4\n5\n6\n\n\n寄存器按功能可分为几大类，分别说明包含什么寄存器？\n\n答：可分为3大类8个通用寄存器、4个段寄存器、2个控制寄存器；\n    分别是：通用寄存器又分为4个数据寄存器、2个地址寄存器、2个变址寄存器；\n            数据寄存器：AX（累加器）、BX（基址寄存器）、CX（计数寄存器）、DX（数据寄存器）\n            地址寄存器：BP（基址指针寄存器）、SP（堆栈指针寄存器）\n            变址寄存器：SI（源变址寄存器）、DI（目标变址寄存器）\n            段寄存器：CS（代码段寄存器）、DS（数据段寄存器）、ES（附加段寄存器）、SS（堆栈段寄存器）\n            控制寄存器：IP（指令寄存器）、FLAGS（状态标志寄存器）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述8086和8088的区别：\n\n答：1.8086：是完全16位机，外部总线和内部总线是16根；\n      8088：内部总线是16根，外部总线是8根；\n    2.8086：有6字节的指令队列；\n      8088：有4字节的指令队列；\n    3.8086：使用M/IO非（IO非，低电平）引脚；\n      8088：使用IO/M非（M非，低电平）引脚；\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述最小工作模式：\n\n答：MN/MX非=1，为最小工作模式；\n    在系统中只有8086/8088一个微处理器，所有的总线控制信号直接由8086/8088产生；\n    因此，系统中的总线控制逻辑电路被减到最少，最小模式是单处理器系统。\n\n\n1\n2\n3\n\n\n简述最大工作模式：\n\n答：MN/MX非=0，为最大工作模式；\n    系统中有两个或两个以上的微处理器；即除了主处理器8086/8088以外，\n还有协处理器（8087算数协处理器或8089输入输出协处理器），最大模式可构成多处理器系统，\n系统中所有的控制信号由总线控制器（8288）提供。\n\n\n1\n2\n3\n4\n\n\n最小工作模式与最大工作模式的区别：\n\n答：最大模式是相对最小模式而言的；\n    最大模式用在中等规模的或者大型8086/8088系统中；\n    在最大模式系统中，总是包含两个或多个微处理器其中一个主处理器就是8086/8088，\n其他的称为协处理器，它们是协助处理器工作的；\n    CPU工作模式的选择是由硬件决定的。\n\n\n1\n2\n3\n4\n5\n\n\n简述中断的概念：\n\n答：当CPU执行主程序时，由于内外部事件使得CPU暂时中断当前主程序转而去执行子程序，\n\t当子程序执行完之后返回主程序的过程叫做中断。\n\n\n1\n2\n\n\n简述中断嵌套：\n\n答：中断嵌套是指中断系统正在执行一个中断服务子程序时，有另一个优先级更高的中断提出中断请求，\n这时会暂停终止当前正在执行的级别较低的中断源的服务程序，去处理级别更高的中断源，待处理完毕，\n再返回到被中断了的中断服务子程序继续执行的过程。\n\n\n1\n2\n3\n\n\n中断响应过程中为什么要保护现场，如何保护？\n\n答：因为一般主程序和中断服务程序都可能会用到累加器，PSW寄存器及其他一些寄存器。\nCPU在进入中断服务程序后，用到上述寄存器时，就会破坏它原来存在寄存器中的内容；\n一旦中断返回，将会造成主程序的混乱。因而在进入中断服务程序后，一般要先保护现场，\n然后再执行中断处理程序，在返回主程序以前再恢复现场。\n\t保护方法一般是把累加器、PSW寄存器及其他一些与主程序有关的寄存器压入堆栈。\n在保护现场和恢复现场时，为了不使现场受到破坏或者造成混乱，一般规定此时CPU不响应新的中断请求。\n这就要求在编写中断服务程序时，注意在保护现场之前要关中断，在恢复现场之后开中断。\n如果在中断处理时允许有更高级的中断打断它，则在保护现场之后再开中断，恢复现场之前关中断。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断源的识别通常有哪两种方法，并简述其特点：\n\n答：查询中断和向量中断；\n\t前者的特点时多个中断源共用一个中断入口服务程序，通过执行一段查询程序，\n确定引起中断的中断源状态，然后做相应的中断处理。\n\t后者的特点是每个中断源对应一个中断服务入口地址，由中断向量来指示中断服务程序入口地址。\n\n\n1\n2\n3\n4\n\n\n简述IDE、SCSI、SATA接口总线：\n\n答：是硬盘和光驱接口标准。\n\tIDE：Intergrated Drive Electronics；【电子集成驱动器】16/32位\n\tSCSI：Small Computer System Interface；【小型计算机系统接口】32位\n\tSATA：串行ATA（Serial ATA），SATA3.0接口。【目前硬盘和光驱的主要接口】\n\n\n1\n2\n3\n4\n\n\n简述IEEE394总线、AGP总线、PCI总线功能：\n\n答：IEEE394总线：是高性能串行总线标准；视频采集、数码影像设备的传输标准。\n\tAGP总线：图形加速口：提高视频带宽。\n\tPCI总线：（Peripheral Component Interconnect）外设部件互联标准；\n\t\t可以通过桥连接多条PCI总线；PCI总线上的设备可以与CPU并行工作。\n\n\n1\n2\n3\n4\n\n\n总线的性能指标：\n\n答：1、总线贷款：数据传输率，单位：bps\n\t2、总线位宽：同时传输的二进制位数；\n\t一次所能并行传送信息的位数，亦称为数据路宽度。\n\t3、总线工作频率：Mhz\n\n\n1\n2\n3\n4\n\n\n88/86两个单元的功能：\n\n答：1、BIU：负责CUP对主存和外设接口进行访问\n\t\t①取指令：从内存取指令，送指令队列\n\t\t④取操作数：从内存或接口取操作数\n\t\t⑦送结果：从BIU送内存或接口外设\n\t2、EU：负责指令译码、执行和数据的运算\n\t\t②取指令：从指令队列取指令送控制器\n\t\t③分析译码：识别指令功能\n\t\t⑤执行指令：在ALU中运算加工\n\t\t⑥送结果：由EU送BIU\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n写出CPU中主要寄存器：\n\n答：AX、BX、CX、DX、SI、DI、BP、SP、IP、CS、DS、ES、SS、FR\n\n\n1\n\n\n寄存器、cache、内存和外存的区别：\n\n答：寄存器：是CUP内部暂存数据单元，如：AX、BX等；\ncache：位于CPU和内存之间，可直接与CPU进行数据交换，解决内存速度不足的问题；\n内存：也叫主存，可直接与CPU进行数据交换；\n外存：主要用来长久保存数据，如：硬盘、光盘、U盘等。外存的数据只能通过主存间接地与CPU交换数据。\n\n\n1\n2\n3\n4\n\n\n8086为什么要采用分体结构：\n\n答：存储体以8位（1B）作为基本存储单位；\n访问一个字节时，只用16位数据线中的8位；\n访问一个字时，16位数据线的高8位和低8位同时访问两个存储单元，提高了CPU的效率。\n\n\n1\n2\n3\n\n\n如何划分奇偶体：\n\n答：在8086系统中，将总容量为1MB的存储器分为奇地址存储体和偶地址存储体，各为512K；\n\t奇体与高8位（D15——D8）相连；\n\t偶体与低8位（D7——D0）相连；\n\t选择奇体还是偶体由信号BHE！、A0决定。\n\n\n1\n2\n3\n4\n\n\n在8086微处理器构成的系统中，什么是存储器的规则字和非规则字？8086微处理器对一个规则字和一个非规则字读写时，有什么区别？\n\n答：规则字：从偶地址开始的字；\n\t读写规则字时：只需要一个总线周期，BHE!=0、A0=0\n\t非规则字：从奇地址开始的字；\n\t读写规则字时：需要两个个总线周期；\n\t\t读奇地址内容D8-D15（BHE!=0、A0=1）、读偶地址内容D0-D7（BHE!=1、A0=0）\n\n\n1\n2\n3\n4\n5\n\n\nROM、PROM、EPROM和EEPROM在使用上各有什么特点？\n\n答：ROM：掩膜ROM，信息制作在芯片中，不可更改\n\tPROM：允许一次编程，此后不可更改\n\tEPROM：紫外线照射擦除，可多次擦除和编程，未编程前所有单元格信息都为1，写入后的部分为0\n\tEEPROM：加电在线擦除和编写，可多次擦写\n\n\n1\n2\n3\n4\n\n\n简述CPU与外部设备采用中断控制方式传输数据的过程。\n\n答：\n（1）当外部设备需要与CPU进行数据交换时，由接口部件8259芯片发出一个中断请求信号；\n（2）CPU响应这一中断请求，便可在中断服务程序中完成一个字节或一个字的信息交换；\n（3）数据交换完成后，返回原程序。\n（4）CPU每执行一次中断传送数据，要打断原来执行的程序去执行中断服务子程序。\n（5）执行前要保护PSW和断点，执行后再恢复它们。\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述中断传送方式和DMA传送方式相比有什么不同。\n\n答：1、中断方式通过程序实现数据传送，而DMA方式直接靠硬件来实现，信息传输速度快。\n\t2、CPU对中断的响应是在执行完一条指令之后，而对DMA的响应则可以在指令执行过程中的任何总线周期之后，请求响应快。\n\t3、中断方式必须切换程序，要进行CPU现场的保护中恢复操作。DMA仅挪用了一个存储周期，不改变CPU现场，额外花销小。\n\t4、DMA请求的优先权比中断请求高。CPU优先响应DMA请求。\n\t5、中断方式不仅具有I/O数据传送能力，而且还能处理异常事件，DMA只能进行I/O数据传送。\n总而言之，在进行I/O控制时，DMA控制方式比程序中断控制方式速度快，但程序中断控制方式的应用范国比DMA控制方式广。\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述缓冲器、锁存器和触发器的作用。\n\n答：\n（1）缓冲器：又称缓冲寄存器。\n\t①完成速度的匹配，在高速工作的 CPU 与慢速工作的外设间起协调和缓冲作用，实现数据传送的同步。（1 分）\n\t②提供一个暂存的空间。它分输入缓冲器和输出缓冲器两种。输入缓冲器是将外设送来的数据暂时存放，以便处理器将它取走；输出缓冲器是用来暂时存放处理器送往外设的数据。（1 分）\n\t③提高驱动能力。（1 分）\n\t④信号隔离的作用，消除负载对信号源的影响。（1 分）\n（2）锁存器（latch）：利用电平控制数据的传输。（1 分）\n\t①缓存。（1 分）\n\t②完成高速的控制器与慢速的外设的不同步问题。（1 分）\n\t③解决驱动的问题。（1 分）\n（3）触发器：是最小的记忆单元,能记忆二进制数的一个数位，是寄存器、存储器基本元件。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n什么是中断？计算机使用中断的好处？\n\n答：\n（1）中断是指当处理器执行主程序时，由于内外部事件转而去执行子程序，当子程序执行完成后返回主程序的过程。（2 分）\n(2) 中断的优点：\n\t① 解决快速 CPU 与慢速外设之间的矛盾，使 CPU 可以与外设同时工作，不交换信息时，处理器和外围设备处于各自独立的并行工作状态。提高计算机系统效率。（2 分）\n\t② 维持系统可靠正常工作。在程序运行过程中，如出现异常，向处理器发出中断请求，处理器立即采取保护措施。（2 分）\n\t③ 计算机实现对控制对象的实时处理，处理器随时响应外设请求并处理。（2 分）\n\t④ 计算机可以对故障自行处理。处理器中设有各种故障检测和错误诊断的部件，一旦发现故障或错误，立即发出中断请求，进行故障现场记录和隔离。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么叫端口？通常有哪几类端口？计算机对I/O端口编址时采用哪两种方法？在8086/8088系统中，用哪种方法对I/O端口进行编址？\n\n答：\n（1）CPU 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。（2 分）\n（2）端口通常有 3 类：数据端口、状态端口、控制端口。（3 分）\n（3）计算机对端口编址的两种方法为：计算机对内存和 I/O 端口统一编址；计算机对内存和I/O端口独立编址。（4 分）\n（4）在 8086/8088 系统中用内存和 I/O 端口各自独立编址。（1 分）\n\n\n1\n2\n3\n4\n5\n\n\n“8086执行了一个总线周期”是指8086做了哪些可能的操作？基本总线周期如何组成？在一个典型的都存储周期中，地址信号、ALE信号 ， RD 信号、数据信号分别在何时产生？\n\n答：（1）“8086执行了一个总线周期”是指：\n\t\t1、8086可能从片外的存储器取指令；\n\t\t2、8086可能对片外的存储器或I/O接口进行了一次读/写数据的操作。\n\t（2）基本总线周期由T1至T4四个时钟周期组成。\n\t（3）在一个典型的读存储器总线周期中，地址信号在 T1 周期内产生，ALE 信号在T1 周期内产生，\n\t\tRD信号在 T2 周期内产生，数据信号一般在 T3 周期内产生，若存储器在 T3 内来不及提供数据，\n\t\t8086 会在总线周期中的 T3 后插入等待状态 Tw，存储器将在某 Tw 中给出数据。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么是地址锁存器？8088/8086为什么要用地址锁存器？锁存的是什么信息？举例说明。\n\n答：（1）地址锁存器是一个暂存器，它根据控制信号的状态将总线上的地址代码暂存起来。\n\t（2）8088/8086 的数据和地址总线采用分时复用操作方式，即用同一总线既传送地址又传送数据。\n\t\t当微处理器与存储器交换信号时，首先由 CPU 发送存储器的地址，同时发允许锁存信号ALE给锁存器，\n\t\t当锁存器接到该信号后将地址/数据总线上的地址锁存在锁存器中，随后才能传送数据信息。\n\t（3）8088/8086 系统的地址锁存器采用 74LS373/273 或者 8282/8283，每片能够锁8 位地址。\n\n\n1\n2\n3\n4\n5\n\n\n什么是中断类型码、中断向量、中断向量表？在基于8088/8086的微机操作系统中中断类型码和中断向量之间有什么关系？\n\n答：处理机可处理的每种中断的编号为中断类型码。\n\t中断向量是指中断处理程序的入口地址，由处理机自动寻址。\n\t中断向量表是存放所有类型中断处理程序入口地址的一个默认的内存区域。\n\t在 8086 系统中，中断类型码乘以 4 得到向量表的地址指针，\n\t从此处读出4 字节内容即为中断向量。\n\n\n1\n2\n3\n4\n5\n\n\n8086CPU从接口上分为几部分？各部分由什么组成？各部分功能是什么？\n\n答：（1）8086CPU 从功能上分为两大部分：一是执行部件(EU)，二是总线接口部件(BIU)。\n\t（2）执行部件(EU)是由以下 4 部分组成：\n\t\t①4 个通用寄存器：AX、BX、CX、DX。\n\t\t②4 个专用寄存器：基址指针寄存器 BP，堆栈指针寄存器 SP，源变址寄存器SI，目的变址寄存器DI。\n\t\t③标志寄存器 FR。\n\t\t④算术逻辑部件 ALU。\n\t\t功能：负责执行所有的指令，向总线接口部件(BIU)提供指令执行的结果数据和地址，并对通用寄存器和标志寄存器进行管理。\n\t（3）总线接口部件(BIU)由以下部件组成:\n\t\t①4 个段寄存器：代码段寄存器 CS，数据段寄存器 DS，附加段寄存器 ES，堆栈段寄存器SS。②指令指针寄存器。\n\t\t③地址加法器。\n\t\t④指令队列。\n\t\t功能：执行外部总线周期，负责 CPU 与主存储器和外设之间的信息交换。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n8086如何响应一个INTR中断请求？\n\n答：在 INTR 中断请求响应条件满足的情况下，\n\t(1) 8086 在连续的两个总线周期中发出INTA中断请求响应信号；\n\t(2) 在第二个 INTA信号期间，中断源经数据总线向 8086 发出一字节的中断类型码，8086 收到中断类型码后放入暂存器；\n\t(3) 8086 保护现场：标志寄存器入栈，清除 IF、TF 标志位，断点 CS、IP 值入栈；\n\t(4) 8086 将中断类型码乘以 4 后得到中断向量表的入口地址，从此地址开始的4 个单元中读出中断服务程序的入口地址（IP，CS）；\n\t(5) 8086 从此地址取指令执行，使控制转向中断处理过程。\n\n\n1\n2\n3\n4\n5\n6\n\n\n站在80X86，汇编语言程序员的角度，说明数据存储位置有哪些？访问这些数据可采用的寻址方式分别是什么？对这些位置对数据访问速度是否相同，为什么？\n\n答：（1）数据存储位置有 CPU 内部的寄存器、内存、IO 端口\n\t（2）采用的寻址方式分别是：\n\t\t①寄存器操作数采用寄存器寻址\n\t\t②存储器操作数采用直接寻址，寄存器间接寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址 \n\t\t③IO 端口的访问需专门的 IO 指令，有直接寻址和间接寻址。\n\t（3）速度不同，寄存器位于 CPU 内部，因此速度最快，存储器操作数速度较慢，因为需要通过系统总线访问内存，\n\t\t端口的访问最慢，属于输入/输出操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么是总线，简述各类总线的应用场合？\n\n答：（1）总线（Bus）是计算机各种功能部件之间传送信息的公共通信线，\n\t\t它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，\n\t\t外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。\n\t（2）按总线功能或信号类型来分，有数据总线、地址总线和控制总线。 按总线的层次结构分来为，有：\n\t\t① CPU 片内总线：微机系统中速度最快的总线，主要在 CPU 内部，连接 CPU 内部部件，提供系统原始的控制和命令。\n\t\t②系统总线：在系统总线和 CPU 总线之间的一级总线，提供 CPU 和主板器件之间以及CPU到高速外设之间的快速信息通道。\n\t\t③通信总线：也称为外部总线，是微机与微机、微机与外设之间进行通信的总线。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述在最小工作模式下，8086如何响应一个总线请求？\n\n答：外部总线主控模块经 HOLD 引线向 8086 发出总线请求信号；\n\t8086 在每个时钟周期的上升沿采样HOLD 引线；\n\t若发现 HOLD=1 则在当前总线周期结束时(T4 结束)发出总线请求的响应信号HLDA；\n\t8086使地址、数据及控制总线进入高阻状态，让出总线控制权，完成响应过程。\n\n\n1\n2\n3\n4\n\n\n简述CPU与外设进行数据交换的方式，并说明每种方式的特点。\n\n答：CPU 与外设进行数据交换的方式有：无条件传送方式、查询传送方式、中断控制方式、直接存储器存取控制方式（DMA）和通道方式。\n\t（1）程序控制方式: 特点是依靠程序的控制来实现主机和外设的数据传送，可分为无条件传送方式、查询方式和中断方式。\n\t\t三种方式都是以 CPU 为中心的控制方式，都需要 CPU 执行程序来进行I/O数据传送。\n\t\t①无条件传送方式：程序简单，所需的硬件和软件都比较少、传送速度快，但必须在确信外设已准备好的情况下才能使用。\n\t\t②查询传送方式：CPU 通过程序不断查询相应设备的状态，状态不符合要求，则CPU 需要等待；只有当状态信号符合要求时，\n\t\t\tCPU 才能进行相应的操作。硬件线路简单，程序易于实现；缺点是CPU利用率低下，实时性差。\n\t\t③中断控制方式: 外设在准备就绪的条件下通过请求引脚信号，主动向处理器提出交换数据的请求。CPU与外设、外设与外设之间能并行工作。\n\t\t\t一般适合于传送数据量少的中低速外部设备，尤其适合实时控制中的紧急事件处理，对于高速外部设备的大批量数据传送不适合。\n\t（2）直接存储器存取控制方式（DMA）：CPU 不参加数据传送，而是由 DMA 控制器来实现内存与外设，外设与外设之间的直接传递。\n\t\t此种方式适用于需要大量数据高速传送的场合。CPU 与外设可以并行工作，提高了 CPU 的效率。\n\t（3）通道方式：可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一般接口电路中具有哪些电路器件？\n\n答：（1）输入/输出数据锁存器和缓冲器，用于解决 CPU 与外设之间速度不匹配的矛盾，以及起隔离和缓冲的作用。\n\t（2）控制命令和状态寄存器，以存放 CPU 对外设的控制命令以及外设的状态信息。\n\t（3）地址译码器，用于选择接口电路中的不同端口（寄存器）。\n\t（4）读写控制逻辑。\n\t（5）中断控制逻辑。\n\n\n1\n2\n3\n4\n5\n\n\n比较串行通信与并行通信的优缺点。\n\n答：（1）从传送距离上看：并行通信适宜于近距离的数据传送，通常小于 30 米；而串行通信适宜于远距离的数据传送可以从几米到数千公里；\n\t（2）从传送速度上看：并行通信传送数据的速度比串行通信快得多；\n\t（3）从传送设备和费用上：在远距离传送中通信线路的费用占很大的比重，因而串行通信的费用由于传送线少，比并行通信的费用低得多。\n\n\n1\n2\n3\n\n\n什么叫总线周期？8086CPU的一个总线周期包括多少时钟周期，什么情况下要插入Tw等待周期？插入多少个Tw取决于什么因素？\n\n答：8086/8088CPU 把 BIU 完成一次访问主存储器或外设操作所需的时间称为一个总线周期。一个总线周期最少包含 4 个时钟周期（T1~T4）。\n\t当访问存储器（读/写）或外设时，存储器或外设不能及时地配合 CPU 传送数据，T3 之后插入一个或多个等待等待周期 Tw。\n\t当存储器或外设准备好数据，通过“READY”发“准备好”信号，CPU 接收到这个信号后，会自动完成Tw 状态进人 T4 状态，因此插入多少个 Tw 取决于“READY"信号，即取决于主存或外设的速度。\n\n\n1\n2\n3\n\n\n在8086/8088系统中，什么是最大模式？什么是最小模式？用什么方法将8086/8088置为最大模式或最小模式？\n\n答：（1）最小模式：在系统中只有 8086/8088 一个微处理器，所有的总线控制信号都直接由 8086/8088产生，因此，系统中总线控制电路被减到最少。\n\t（2）最大模式：在系统中包含两个或多个微处理器，其中一个主处理器就是 8088/8086，其它处理器为协处理器，用于协助主处理器工作。它用在中等规模或大型的 8088/8086 系统中。一般情况下和 8088/8086配合的协处理器有两个：一个是数值运算协处理器 8087，一个是输入/输出协处理器 8089。\n\t（3）将 8088/8086 CPU 的第 33 脚接地，系统处于最大模式，当第 33 脚接+5V 时，系统为最小模式。\n\n\n1\n2\n3\n\n\n8259A的主要功能是什么？三个寄存器IRR、IMR、ISR各有什么作用？\n\n答：（1）8259 的功能：\n\t\t①可以管理 8 级中断，通过级联的方式，用 9 片 8259 管理 64 级中断。\n\t\t②判断一个中断请求输入信号 IR 是否有效，是否符合信号的电器约定，是否被屏蔽。\n\t\t③有中断优先逻辑，并可对任一中断单独屏蔽或允许。8259A 的 8 个中断请求输入端 IR0~IR7，哪一个能使 INT 输出有效要由编程选定的优先级方式来判定。\n\t\t④CPU 响应中断后，进入中断响应周期INTA ，8259A 能将获得优先级的 IRi所对应的中断类型号送上数据总线提供给 CPU。\n\t\t⑤ 可通过编程选择工作方式。\n\t（2）三个寄存器 IRR、IMR 和 ISR 的作用：\n\t\t①中断请求寄存器 IRR：保存 8 条外界中断请求信号 IR0～IR7 的请求状态。Di 位为 1 表示 IRi 引脚有中断请求；为 0 表示该引脚无请求。\n\t\t②中断屏蔽寄存器 IMR：保存对中断请求信号 IR 的屏蔽状态。Di 位为 1 表示 IRi 中断被屏蔽（禁止）；为0 表示允许该中断。\n\t\t③中断服务寄存器 ISR：保存正在被 8259A 服务着的中断状态。Di 位为 1 表示 IRi 中断正在服务中；为 0表示没有被服务。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简述半导体存储器的主要技术指标。\n\n答：（1）存储容量。存储器可以存储的二进制信息总量称为存储容量。存储容量有两种表示方法：\n\t\t①位表示方法。以存储器中的存储地址总数与存储字位的乘积表示。如 1K×4 位，表示该芯片有 1K 个单元（1K＝1024），每个存储单元的长度为 4 个二进制位。\n\t\t②字节表示方法。以存储器中的单元总数表示（一个存储单元由 8 个二进制位组成，称为一个字节，用 B 表示）。如 128B，表示该芯片有 128 个单元。\n\t（2）存取速度。存储器的存储速度可以用两个时间参数表示，一个是存取时间：从启动一次存储器操作到完成该操作所经历的时间；另一个是存储周期：启动两次独立的存储器操作之间所需的最小时间间隔。\n\t（3）可靠性。存储器的可靠性用平均故障间隔时间 MTBF 来衡量。MTBF 越长，可靠性越高。\n\t（4）存储带宽。单位时间传输的信息量。\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n12111111111111122121212\n\n论指令周期、总线周期和时钟周期的关系。\n\n答：（1）执行一条指令所需要的时间称为指令周期；\n\t（2）CPU 同外部设备或内存储器之间进行信息交换过程所需要的时间称为总线周期，即启用一次总线进行读或写的时间；\n\t（3）时钟脉冲的重复周期称为时钟周期，它是 CPU 主频的倒数；\n\t（4）一个指令周期由若干个总线周期组成，一个总线周期又由若干个时钟周期组成；\n\t（5）8086CPU 的总线周期至少由 4 个时钟周期组成，当外设不能在 CPU 规定时间内准备好数据时，要在总线周期中插入等待周期。\n\n\n1\n2\n3\n4\n5\n\n\nCPU响应中断时，为什么要执行两个连续的中断响应周期？\n\n答：CPU 响应中断时，执行两个连续的中断响应周期，每个响应周期都给出中断响应信号INTA。\n\t这是因为第一个总线周期通知中断请求设备，微处理器准备响应中断，中断控制器 8259A 应该准备好中断类型码，8259A 的 ISR 和 IRR 对应位分别置 1 清 0；\n\t第二个总线周期中，8259A 把中断类型号送上数据总线，微处理器接收中断类型码，以便得到中断向量，即得到中断服务程序的入口地址。\n\n\n1\n2\n3\n\n\n8086CPU中有哪些寄存器？分别有什么用途。哪些寄存器用来指示存储器单元的偏移地址。\n\n答：8086 CPU 中有 8 个通用寄存器 AX、BX、CX、DX、SP、BP、SI、DI；\n\t两个控制寄存器 IP、FR；\n\t四个段寄存器 CS、DS、SS、ES。\n\t8 个通用寄存器都可以用来暂存参加运算的数据或中间结果，但又有各自的专门用途。\n\t例如：AX 专用做累加器，某些指令指定用它存放操作数和运算结果；CX 为计数寄存器，在某些指令中做计数器使用；DX 为数据寄存器；BX 为基址寄存器，BP 为基址指针，SI 为源变址寄存器，DI 为目的变址寄存器，这 4 个寄存器在数据寻址中用来存放段内偏移地址（有效地址）或段内偏移地址的一部分；SP 为堆栈指示器，用来存放栈顶有效地址。\n\t两个控制寄存器用来存放有关的状态信息和控制信息。\n\t例如：标志寄存器 FR 用来存放状态标志和控制标志；而指令指针用来存放下一条要取指令的有效地址。\n\t四个段寄存器用来存放段地址。\n\t例如：CS 寄存器用来存放代码段的段地址；DS 寄存器用来存放数据段的段地址；SS 寄存器用来存放堆栈段的段地址；ES 寄存器用来存放扩展段的段地址。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在8086中，逻辑地址、偏移地址、物理地址分别指的是什么？具体说明。\n\n答：逻辑地址是在程序中对存储器地址的一种表示方法，由段地址和段内偏移地址两部分组成，\n\t如 1234H：0088H。\n\t偏移地址是指段内某个存储单元相对该段首地址的差值，是一个 16 位的二进制代码。物理地址是 8086 芯片引线送出的 20 位地址码，用来指出一个特定的存储单元。\n\n\n1\n2\n3\n\n\n简述流水线技术，8086怎样实现了最简单的流水线？\n\n答：流水线是指在程序执行时多条指令重叠进行操作的一种并行处理实现技术。流水线的并行处理是指完成一条指令的各个部件在时间上是可以同时重叠工作，分别同时为多条指令的不同部分进行工作，以提高各部件的利用率来提高指令的平均执行速度。流水线技术是把一个重复的过程分解为若干子过程，每个子过程由专门的功能部件来\n实现，将多个处理过程在时间上错开，依次通过个功能段，这样，每个子过程就可以与其他子过程并行进行。\n\t8086 中，指令的读取是在 BIU 单元，而指令的执行是在 EU 单元。因为 BIU 和 EU 两个单元相互独立、分别完成各自操作，所以可以并行操作。也就是说，在 EU 单元对一个指令进行译码执行时，BIU 单元可以同时对后续指令进行读取；这就是最简单的指令流水线技术。\n\n\n1\n2\n3\n\n\n比较8255A三种工作方式的应用场合有何区别？\n\n答：方式 0 适用于同步传送和查询传送方式，\n\t方式 1 适用于外设在能提供选通信号或数据接收信号的场合，且采用中断传送方式比较方便；\n\t方式 2 适用于一个并行外设既可以作为输入设备，又可以作为输出设备，并且输入和输出不会同时进行的场合。\n\n\n1\n2\n3\n\n\n试述程序查询传送方式的工作原理，与查询传送方式相比，中断传送方式有什么优点？\n\n答：查询传送方式在传送数据前先查询外设的状态，当外设准备好时，CPU 执行 I/O指令传送数据；若未准备好时，则 CPU 等待。优点：能较好地协调外设与 CPU 之间的定时关系，因而比无条件传送方式容易实现准确传送。缺点:该方式需要不断查询外设的状态，大量时间花在等待循环中，当主机与中、低速外设交换信息时，大大降低了 CPU 利用率。中断传送方式的优点：提高了 CPU 的效率；CPU 与外设、外设与外设之间能并行工作。\n\n\n1\n\n\n什么叫端口？计算机对I/O端口进行编址时常采用哪俩种方法？在8086/8088系统中，用哪种方法对I/O端口进行编址？\n\n答：CPU 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。\n\t通常有：数据端口、状态端口、控制端口。\n\t对端口编址的两种方法为：计算机对内存和 I/O 端口统一编址；计算机对内存和 I/O 端口独立编址。\n\t在 8086/8088 系统中用计算机对内存和 I/O 端口独立编址。\n\n\n1\n2\n3\n4\n\n\n简述8086内部中断的种类级特点。\n\n答：（1）内部中断又称软件中断，是通过软件调用的不可屏蔽中断，包括溢出中断、除法出错中断、单步中断、INT n 指令中断及单字节 INT3 指令中断。\n\t（2）中断类型码或者包含在指令中，或者是预先规定的；\n\t（3）不执行 INTA 总线周期；\n\t（4）除单步中断外，任何内部中断都无法禁止；\n\t（5）除单步中断外，任何内部中断的优先级都比任何外部中断的高。\n\n\n1\n2\n3\n4\n5\n\n\n汇编语言程序的开发有哪4个步骤，分别利用什么程序完成、产生输出什么文件。\n\n答：汇编语言程序的开发有 4 个步骤：\n\t编辑：用文本编辑器形成一个以 ASM 为扩展名的源程序文件。\n\t汇编：用汇编程序将 ASM 文件转换为 OBJ 模块文件。\n\t连接：用连接程序将一个或多个目标文件链接成一个 EXE 或 COM 可执行文件。\n\t调试：用调试程序排除错误，生成正确的可执行文件。\n\n\n1\n2\n3\n4\n5\n\n\n以可屏蔽中断为例，说明一次完整的中断过程主要包括哪些环节。\n\n答：中断请求：外设通过硬件信号的形式、向处理器引脚发送有效请求信号。\n\t中断响应：在满足一定条件时，处理器进入中断响应总线周期。\n\t关中断：处理器在响应中断后会自动关闭中断。\n\t断点保护：处理器在响应中断后将自动保护断点地址。\n\t中断源识别：处理器识别出当前究竟是哪个中断源提出了请求，并明确与之相应的中断服务程序所在主存位置。\n\t现场保护：对处理器执行程序有影响的工作环境（主要是寄存器）进行保护。\n\t中断服务：处理器执行相应的中断服务程序，进行数据传送等处理工作。\n\t恢复现场：完成中断服务后，恢复处理器原来的工作环境。\n\t开中断：处理器允许新的可屏蔽中断。\n\t中断返回：处理器执行中断返回指令，程序返回断点继续执行原来的程序。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n8086处理器的输入输出信号有RESET、HOLD、NMI和INTR，其中含义各是什么？当它们有效时，8086CPU将出现何种反应？\n\n答：RESET：复位输入信号，高电平有效。该引脚有效时，将迫使处理器回到其初始状态；转为无效时，CPU 重新开始工作。\n\tHOLD：总线请求，是一个高电平有效的输入信号。该引脚有效时，表示其他总线主控设备向处理器申请使用原来由处理器控制的总线。\n\tNMI：不可屏蔽中断请求，是一个利用上升沿有效的输入信号。该引脚信号有效时，表示外界向 CPU 申请不可屏蔽中断。\n\tINTR：可屏蔽中断请求，是一个高电平有效的输入信号。该引脚信号有效时，表示中断请求设备向处理器申请可屏蔽中断。\n\n\n1\n2\n3\n4\n\n\nDMA控制器有哪俩种工作状态？并说明DMA传送的一般过程。\n\n答：(1)DMA 控制器有两种工作状态：\n\t\t①主方式：DMA 控制器 8237A 是系统总线的主控者，取代 CPU 控制 DMA 传送。\n\t\t②从方式：在成为主控者之前，必须由 CPU 对它编程以确定通道的选择、数据传送的模式、存储器区域首地址、传送总字节数等。这时对于 CPU 来说，8237A 只是个外部设备，是系统总线的从设备。\n\t（2）DMA 传送的一般过程：\n\t\t①外设向 DMAC 发出 DMA 请求；\n\t\t②DMAC 向 CPU 发出 DMA 请求；\n\t\t③CPU 执行完当前的总线周期后，向 DMAC 发出响应请求的应答信号，CPU 让出总线的控制权，由 DMAC 控制；\n\t\t④DMAC 向外设发出 DMA 请求的应答信号；\n\t\t⑤进行 DMA 传送，传送完毕，CPU 重新控制总线\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n8259A的ICW2设置了中断类型码的哪几位？并说明对8259A分别设置ICW2为30H、38H、36H有什么差别？\n\n答：ICW2 设置了中断类型码的高 5 位，所以中断类型码基值必须是能被 8 整除的值。\n\t若 ICW2 设置为 30H，则 8 级中断的类型码依次为 30H~37H。\n\t若设置为 38H，则 8 级中断的类型码依次为 38H~3FH。\n\t若设置为 36H，中断类型码为 30H~37H，因其高 5 位仍为00110B。\t\n\n\n1\n2\n3\n4\n\n\n8086系统中存储器的逻辑地址由哪两部分组成？物理地址由何器件生成？如何生成？每个段的逻辑地址与存储器之间有何对应关系？\n\n答：答：（1）8086 系统中存储器的逻辑地址由段地址（段首址）和段内偏移地址（有效地址）两部分组成；\n\t（2）存储单元的物理地址由地址加法器生成。\n\t（3）寻址时，CPU 首先将段地址和段内偏移地址送入地址加法器，地址加法器将段地址左移 4 位并与段内偏移地址相加，得到一个 20 位的物理地址。\n\t（4）数据段的段地址在 DS 寄存器中，段内偏移地址可能在 BX、BP、SI 或 DI 寄存器中。\n\t\t代码段的段地址在 CS 寄存器中，段内偏移地址在 IP 寄存器中。\n\t\t堆栈段的段地址在SS 寄存器中，段内偏移地址在 SP 寄存器中。\n\t\t扩展段的段地址在 ES 寄存器中，段内偏移地址可能在 BX、BP、SI 或 DI 寄存器中。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n',normalizedContent:'# 微机原理简答题\n\n简述触发器、寄存器与存储器之间的关系：\n\n答：触发器是计算机记忆装置的基本单元，一个触发器能存储一位二进制数也为一个一位寄存器；\n\t多个出触发器就可以构成一个多位寄存器，而一个寄存器为为一个存储单元；\n\t多个寄存器组成一个存储器。\n\n\n1\n2\n3\n\n\n计算机硬件组成的五个部件是什么：？\n\n答：输入设备、输出设备、运算器、存储器、控制器\n\n\n1\n\n\n计算器系统由什么组成？\n\n答：硬件系统和软件系统两部分组成。\n\n\n1\n\n\n简述总线的定义：\n\n答：在计算机系统中，各个部件之间传送信息的公共通道叫做总线（bus），\n按照所传输的信息种类可划分为数据总线、地址总线、控制总线。\n\n\n1\n2\n\n\n简述risc（精简指令集）的特点：\n\n答：1、cpu处理指令是由硬件完成、运行速度快；\n    2、指令长度固定、指令格式种类少、寻址方式种类少；\n    3、只有取数/存数指令访问存储器，其余指令的操作都在寄存器内完成；\n    4、采用流水线技术，大部分指令在一个时钟周期内完成；\n    5、控制器采用组合逻辑控制，不用微程序控制。\n    6、采用优化的编译程序。\n\n\n1\n2\n3\n4\n5\n6\n\n\n寄存器按功能可分为几大类，分别说明包含什么寄存器？\n\n答：可分为3大类8个通用寄存器、4个段寄存器、2个控制寄存器；\n    分别是：通用寄存器又分为4个数据寄存器、2个地址寄存器、2个变址寄存器；\n            数据寄存器：ax（累加器）、bx（基址寄存器）、cx（计数寄存器）、dx（数据寄存器）\n            地址寄存器：bp（基址指针寄存器）、sp（堆栈指针寄存器）\n            变址寄存器：si（源变址寄存器）、di（目标变址寄存器）\n            段寄存器：cs（代码段寄存器）、ds（数据段寄存器）、es（附加段寄存器）、ss（堆栈段寄存器）\n            控制寄存器：ip（指令寄存器）、flags（状态标志寄存器）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述8086和8088的区别：\n\n答：1.8086：是完全16位机，外部总线和内部总线是16根；\n      8088：内部总线是16根，外部总线是8根；\n    2.8086：有6字节的指令队列；\n      8088：有4字节的指令队列；\n    3.8086：使用m/io非（io非，低电平）引脚；\n      8088：使用io/m非（m非，低电平）引脚；\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述最小工作模式：\n\n答：mn/mx非=1，为最小工作模式；\n    在系统中只有8086/8088一个微处理器，所有的总线控制信号直接由8086/8088产生；\n    因此，系统中的总线控制逻辑电路被减到最少，最小模式是单处理器系统。\n\n\n1\n2\n3\n\n\n简述最大工作模式：\n\n答：mn/mx非=0，为最大工作模式；\n    系统中有两个或两个以上的微处理器；即除了主处理器8086/8088以外，\n还有协处理器（8087算数协处理器或8089输入输出协处理器），最大模式可构成多处理器系统，\n系统中所有的控制信号由总线控制器（8288）提供。\n\n\n1\n2\n3\n4\n\n\n最小工作模式与最大工作模式的区别：\n\n答：最大模式是相对最小模式而言的；\n    最大模式用在中等规模的或者大型8086/8088系统中；\n    在最大模式系统中，总是包含两个或多个微处理器其中一个主处理器就是8086/8088，\n其他的称为协处理器，它们是协助处理器工作的；\n    cpu工作模式的选择是由硬件决定的。\n\n\n1\n2\n3\n4\n5\n\n\n简述中断的概念：\n\n答：当cpu执行主程序时，由于内外部事件使得cpu暂时中断当前主程序转而去执行子程序，\n\t当子程序执行完之后返回主程序的过程叫做中断。\n\n\n1\n2\n\n\n简述中断嵌套：\n\n答：中断嵌套是指中断系统正在执行一个中断服务子程序时，有另一个优先级更高的中断提出中断请求，\n这时会暂停终止当前正在执行的级别较低的中断源的服务程序，去处理级别更高的中断源，待处理完毕，\n再返回到被中断了的中断服务子程序继续执行的过程。\n\n\n1\n2\n3\n\n\n中断响应过程中为什么要保护现场，如何保护？\n\n答：因为一般主程序和中断服务程序都可能会用到累加器，psw寄存器及其他一些寄存器。\ncpu在进入中断服务程序后，用到上述寄存器时，就会破坏它原来存在寄存器中的内容；\n一旦中断返回，将会造成主程序的混乱。因而在进入中断服务程序后，一般要先保护现场，\n然后再执行中断处理程序，在返回主程序以前再恢复现场。\n\t保护方法一般是把累加器、psw寄存器及其他一些与主程序有关的寄存器压入堆栈。\n在保护现场和恢复现场时，为了不使现场受到破坏或者造成混乱，一般规定此时cpu不响应新的中断请求。\n这就要求在编写中断服务程序时，注意在保护现场之前要关中断，在恢复现场之后开中断。\n如果在中断处理时允许有更高级的中断打断它，则在保护现场之后再开中断，恢复现场之前关中断。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断源的识别通常有哪两种方法，并简述其特点：\n\n答：查询中断和向量中断；\n\t前者的特点时多个中断源共用一个中断入口服务程序，通过执行一段查询程序，\n确定引起中断的中断源状态，然后做相应的中断处理。\n\t后者的特点是每个中断源对应一个中断服务入口地址，由中断向量来指示中断服务程序入口地址。\n\n\n1\n2\n3\n4\n\n\n简述ide、scsi、sata接口总线：\n\n答：是硬盘和光驱接口标准。\n\tide：intergrated drive electronics；【电子集成驱动器】16/32位\n\tscsi：small computer system interface；【小型计算机系统接口】32位\n\tsata：串行ata（serial ata），sata3.0接口。【目前硬盘和光驱的主要接口】\n\n\n1\n2\n3\n4\n\n\n简述ieee394总线、agp总线、pci总线功能：\n\n答：ieee394总线：是高性能串行总线标准；视频采集、数码影像设备的传输标准。\n\tagp总线：图形加速口：提高视频带宽。\n\tpci总线：（peripheral component interconnect）外设部件互联标准；\n\t\t可以通过桥连接多条pci总线；pci总线上的设备可以与cpu并行工作。\n\n\n1\n2\n3\n4\n\n\n总线的性能指标：\n\n答：1、总线贷款：数据传输率，单位：bps\n\t2、总线位宽：同时传输的二进制位数；\n\t一次所能并行传送信息的位数，亦称为数据路宽度。\n\t3、总线工作频率：mhz\n\n\n1\n2\n3\n4\n\n\n88/86两个单元的功能：\n\n答：1、biu：负责cup对主存和外设接口进行访问\n\t\t①取指令：从内存取指令，送指令队列\n\t\t④取操作数：从内存或接口取操作数\n\t\t⑦送结果：从biu送内存或接口外设\n\t2、eu：负责指令译码、执行和数据的运算\n\t\t②取指令：从指令队列取指令送控制器\n\t\t③分析译码：识别指令功能\n\t\t⑤执行指令：在alu中运算加工\n\t\t⑥送结果：由eu送biu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n写出cpu中主要寄存器：\n\n答：ax、bx、cx、dx、si、di、bp、sp、ip、cs、ds、es、ss、fr\n\n\n1\n\n\n寄存器、cache、内存和外存的区别：\n\n答：寄存器：是cup内部暂存数据单元，如：ax、bx等；\ncache：位于cpu和内存之间，可直接与cpu进行数据交换，解决内存速度不足的问题；\n内存：也叫主存，可直接与cpu进行数据交换；\n外存：主要用来长久保存数据，如：硬盘、光盘、u盘等。外存的数据只能通过主存间接地与cpu交换数据。\n\n\n1\n2\n3\n4\n\n\n8086为什么要采用分体结构：\n\n答：存储体以8位（1b）作为基本存储单位；\n访问一个字节时，只用16位数据线中的8位；\n访问一个字时，16位数据线的高8位和低8位同时访问两个存储单元，提高了cpu的效率。\n\n\n1\n2\n3\n\n\n如何划分奇偶体：\n\n答：在8086系统中，将总容量为1mb的存储器分为奇地址存储体和偶地址存储体，各为512k；\n\t奇体与高8位（d15——d8）相连；\n\t偶体与低8位（d7——d0）相连；\n\t选择奇体还是偶体由信号bhe！、a0决定。\n\n\n1\n2\n3\n4\n\n\n在8086微处理器构成的系统中，什么是存储器的规则字和非规则字？8086微处理器对一个规则字和一个非规则字读写时，有什么区别？\n\n答：规则字：从偶地址开始的字；\n\t读写规则字时：只需要一个总线周期，bhe!=0、a0=0\n\t非规则字：从奇地址开始的字；\n\t读写规则字时：需要两个个总线周期；\n\t\t读奇地址内容d8-d15（bhe!=0、a0=1）、读偶地址内容d0-d7（bhe!=1、a0=0）\n\n\n1\n2\n3\n4\n5\n\n\nrom、prom、eprom和eeprom在使用上各有什么特点？\n\n答：rom：掩膜rom，信息制作在芯片中，不可更改\n\tprom：允许一次编程，此后不可更改\n\teprom：紫外线照射擦除，可多次擦除和编程，未编程前所有单元格信息都为1，写入后的部分为0\n\teeprom：加电在线擦除和编写，可多次擦写\n\n\n1\n2\n3\n4\n\n\n简述cpu与外部设备采用中断控制方式传输数据的过程。\n\n答：\n（1）当外部设备需要与cpu进行数据交换时，由接口部件8259芯片发出一个中断请求信号；\n（2）cpu响应这一中断请求，便可在中断服务程序中完成一个字节或一个字的信息交换；\n（3）数据交换完成后，返回原程序。\n（4）cpu每执行一次中断传送数据，要打断原来执行的程序去执行中断服务子程序。\n（5）执行前要保护psw和断点，执行后再恢复它们。\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述中断传送方式和dma传送方式相比有什么不同。\n\n答：1、中断方式通过程序实现数据传送，而dma方式直接靠硬件来实现，信息传输速度快。\n\t2、cpu对中断的响应是在执行完一条指令之后，而对dma的响应则可以在指令执行过程中的任何总线周期之后，请求响应快。\n\t3、中断方式必须切换程序，要进行cpu现场的保护中恢复操作。dma仅挪用了一个存储周期，不改变cpu现场，额外花销小。\n\t4、dma请求的优先权比中断请求高。cpu优先响应dma请求。\n\t5、中断方式不仅具有i/o数据传送能力，而且还能处理异常事件，dma只能进行i/o数据传送。\n总而言之，在进行i/o控制时，dma控制方式比程序中断控制方式速度快，但程序中断控制方式的应用范国比dma控制方式广。\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述缓冲器、锁存器和触发器的作用。\n\n答：\n（1）缓冲器：又称缓冲寄存器。\n\t①完成速度的匹配，在高速工作的 cpu 与慢速工作的外设间起协调和缓冲作用，实现数据传送的同步。（1 分）\n\t②提供一个暂存的空间。它分输入缓冲器和输出缓冲器两种。输入缓冲器是将外设送来的数据暂时存放，以便处理器将它取走；输出缓冲器是用来暂时存放处理器送往外设的数据。（1 分）\n\t③提高驱动能力。（1 分）\n\t④信号隔离的作用，消除负载对信号源的影响。（1 分）\n（2）锁存器（latch）：利用电平控制数据的传输。（1 分）\n\t①缓存。（1 分）\n\t②完成高速的控制器与慢速的外设的不同步问题。（1 分）\n\t③解决驱动的问题。（1 分）\n（3）触发器：是最小的记忆单元,能记忆二进制数的一个数位，是寄存器、存储器基本元件。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n什么是中断？计算机使用中断的好处？\n\n答：\n（1）中断是指当处理器执行主程序时，由于内外部事件转而去执行子程序，当子程序执行完成后返回主程序的过程。（2 分）\n(2) 中断的优点：\n\t① 解决快速 cpu 与慢速外设之间的矛盾，使 cpu 可以与外设同时工作，不交换信息时，处理器和外围设备处于各自独立的并行工作状态。提高计算机系统效率。（2 分）\n\t② 维持系统可靠正常工作。在程序运行过程中，如出现异常，向处理器发出中断请求，处理器立即采取保护措施。（2 分）\n\t③ 计算机实现对控制对象的实时处理，处理器随时响应外设请求并处理。（2 分）\n\t④ 计算机可以对故障自行处理。处理器中设有各种故障检测和错误诊断的部件，一旦发现故障或错误，立即发出中断请求，进行故障现场记录和隔离。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么叫端口？通常有哪几类端口？计算机对i/o端口编址时采用哪两种方法？在8086/8088系统中，用哪种方法对i/o端口进行编址？\n\n答：\n（1）cpu 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。（2 分）\n（2）端口通常有 3 类：数据端口、状态端口、控制端口。（3 分）\n（3）计算机对端口编址的两种方法为：计算机对内存和 i/o 端口统一编址；计算机对内存和i/o端口独立编址。（4 分）\n（4）在 8086/8088 系统中用内存和 i/o 端口各自独立编址。（1 分）\n\n\n1\n2\n3\n4\n5\n\n\n“8086执行了一个总线周期”是指8086做了哪些可能的操作？基本总线周期如何组成？在一个典型的都存储周期中，地址信号、ale信号 ， rd 信号、数据信号分别在何时产生？\n\n答：（1）“8086执行了一个总线周期”是指：\n\t\t1、8086可能从片外的存储器取指令；\n\t\t2、8086可能对片外的存储器或i/o接口进行了一次读/写数据的操作。\n\t（2）基本总线周期由t1至t4四个时钟周期组成。\n\t（3）在一个典型的读存储器总线周期中，地址信号在 t1 周期内产生，ale 信号在t1 周期内产生，\n\t\trd信号在 t2 周期内产生，数据信号一般在 t3 周期内产生，若存储器在 t3 内来不及提供数据，\n\t\t8086 会在总线周期中的 t3 后插入等待状态 tw，存储器将在某 tw 中给出数据。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么是地址锁存器？8088/8086为什么要用地址锁存器？锁存的是什么信息？举例说明。\n\n答：（1）地址锁存器是一个暂存器，它根据控制信号的状态将总线上的地址代码暂存起来。\n\t（2）8088/8086 的数据和地址总线采用分时复用操作方式，即用同一总线既传送地址又传送数据。\n\t\t当微处理器与存储器交换信号时，首先由 cpu 发送存储器的地址，同时发允许锁存信号ale给锁存器，\n\t\t当锁存器接到该信号后将地址/数据总线上的地址锁存在锁存器中，随后才能传送数据信息。\n\t（3）8088/8086 系统的地址锁存器采用 74ls373/273 或者 8282/8283，每片能够锁8 位地址。\n\n\n1\n2\n3\n4\n5\n\n\n什么是中断类型码、中断向量、中断向量表？在基于8088/8086的微机操作系统中中断类型码和中断向量之间有什么关系？\n\n答：处理机可处理的每种中断的编号为中断类型码。\n\t中断向量是指中断处理程序的入口地址，由处理机自动寻址。\n\t中断向量表是存放所有类型中断处理程序入口地址的一个默认的内存区域。\n\t在 8086 系统中，中断类型码乘以 4 得到向量表的地址指针，\n\t从此处读出4 字节内容即为中断向量。\n\n\n1\n2\n3\n4\n5\n\n\n8086cpu从接口上分为几部分？各部分由什么组成？各部分功能是什么？\n\n答：（1）8086cpu 从功能上分为两大部分：一是执行部件(eu)，二是总线接口部件(biu)。\n\t（2）执行部件(eu)是由以下 4 部分组成：\n\t\t①4 个通用寄存器：ax、bx、cx、dx。\n\t\t②4 个专用寄存器：基址指针寄存器 bp，堆栈指针寄存器 sp，源变址寄存器si，目的变址寄存器di。\n\t\t③标志寄存器 fr。\n\t\t④算术逻辑部件 alu。\n\t\t功能：负责执行所有的指令，向总线接口部件(biu)提供指令执行的结果数据和地址，并对通用寄存器和标志寄存器进行管理。\n\t（3）总线接口部件(biu)由以下部件组成:\n\t\t①4 个段寄存器：代码段寄存器 cs，数据段寄存器 ds，附加段寄存器 es，堆栈段寄存器ss。②指令指针寄存器。\n\t\t③地址加法器。\n\t\t④指令队列。\n\t\t功能：执行外部总线周期，负责 cpu 与主存储器和外设之间的信息交换。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n8086如何响应一个intr中断请求？\n\n答：在 intr 中断请求响应条件满足的情况下，\n\t(1) 8086 在连续的两个总线周期中发出inta中断请求响应信号；\n\t(2) 在第二个 inta信号期间，中断源经数据总线向 8086 发出一字节的中断类型码，8086 收到中断类型码后放入暂存器；\n\t(3) 8086 保护现场：标志寄存器入栈，清除 if、tf 标志位，断点 cs、ip 值入栈；\n\t(4) 8086 将中断类型码乘以 4 后得到中断向量表的入口地址，从此地址开始的4 个单元中读出中断服务程序的入口地址（ip，cs）；\n\t(5) 8086 从此地址取指令执行，使控制转向中断处理过程。\n\n\n1\n2\n3\n4\n5\n6\n\n\n站在80x86，汇编语言程序员的角度，说明数据存储位置有哪些？访问这些数据可采用的寻址方式分别是什么？对这些位置对数据访问速度是否相同，为什么？\n\n答：（1）数据存储位置有 cpu 内部的寄存器、内存、io 端口\n\t（2）采用的寻址方式分别是：\n\t\t①寄存器操作数采用寄存器寻址\n\t\t②存储器操作数采用直接寻址，寄存器间接寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址 \n\t\t③io 端口的访问需专门的 io 指令，有直接寻址和间接寻址。\n\t（3）速度不同，寄存器位于 cpu 内部，因此速度最快，存储器操作数速度较慢，因为需要通过系统总线访问内存，\n\t\t端口的访问最慢，属于输入/输出操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么是总线，简述各类总线的应用场合？\n\n答：（1）总线（bus）是计算机各种功能部件之间传送信息的公共通信线，\n\t\t它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，\n\t\t外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。\n\t（2）按总线功能或信号类型来分，有数据总线、地址总线和控制总线。 按总线的层次结构分来为，有：\n\t\t① cpu 片内总线：微机系统中速度最快的总线，主要在 cpu 内部，连接 cpu 内部部件，提供系统原始的控制和命令。\n\t\t②系统总线：在系统总线和 cpu 总线之间的一级总线，提供 cpu 和主板器件之间以及cpu到高速外设之间的快速信息通道。\n\t\t③通信总线：也称为外部总线，是微机与微机、微机与外设之间进行通信的总线。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述在最小工作模式下，8086如何响应一个总线请求？\n\n答：外部总线主控模块经 hold 引线向 8086 发出总线请求信号；\n\t8086 在每个时钟周期的上升沿采样hold 引线；\n\t若发现 hold=1 则在当前总线周期结束时(t4 结束)发出总线请求的响应信号hlda；\n\t8086使地址、数据及控制总线进入高阻状态，让出总线控制权，完成响应过程。\n\n\n1\n2\n3\n4\n\n\n简述cpu与外设进行数据交换的方式，并说明每种方式的特点。\n\n答：cpu 与外设进行数据交换的方式有：无条件传送方式、查询传送方式、中断控制方式、直接存储器存取控制方式（dma）和通道方式。\n\t（1）程序控制方式: 特点是依靠程序的控制来实现主机和外设的数据传送，可分为无条件传送方式、查询方式和中断方式。\n\t\t三种方式都是以 cpu 为中心的控制方式，都需要 cpu 执行程序来进行i/o数据传送。\n\t\t①无条件传送方式：程序简单，所需的硬件和软件都比较少、传送速度快，但必须在确信外设已准备好的情况下才能使用。\n\t\t②查询传送方式：cpu 通过程序不断查询相应设备的状态，状态不符合要求，则cpu 需要等待；只有当状态信号符合要求时，\n\t\t\tcpu 才能进行相应的操作。硬件线路简单，程序易于实现；缺点是cpu利用率低下，实时性差。\n\t\t③中断控制方式: 外设在准备就绪的条件下通过请求引脚信号，主动向处理器提出交换数据的请求。cpu与外设、外设与外设之间能并行工作。\n\t\t\t一般适合于传送数据量少的中低速外部设备，尤其适合实时控制中的紧急事件处理，对于高速外部设备的大批量数据传送不适合。\n\t（2）直接存储器存取控制方式（dma）：cpu 不参加数据传送，而是由 dma 控制器来实现内存与外设，外设与外设之间的直接传递。\n\t\t此种方式适用于需要大量数据高速传送的场合。cpu 与外设可以并行工作，提高了 cpu 的效率。\n\t（3）通道方式：可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一般接口电路中具有哪些电路器件？\n\n答：（1）输入/输出数据锁存器和缓冲器，用于解决 cpu 与外设之间速度不匹配的矛盾，以及起隔离和缓冲的作用。\n\t（2）控制命令和状态寄存器，以存放 cpu 对外设的控制命令以及外设的状态信息。\n\t（3）地址译码器，用于选择接口电路中的不同端口（寄存器）。\n\t（4）读写控制逻辑。\n\t（5）中断控制逻辑。\n\n\n1\n2\n3\n4\n5\n\n\n比较串行通信与并行通信的优缺点。\n\n答：（1）从传送距离上看：并行通信适宜于近距离的数据传送，通常小于 30 米；而串行通信适宜于远距离的数据传送可以从几米到数千公里；\n\t（2）从传送速度上看：并行通信传送数据的速度比串行通信快得多；\n\t（3）从传送设备和费用上：在远距离传送中通信线路的费用占很大的比重，因而串行通信的费用由于传送线少，比并行通信的费用低得多。\n\n\n1\n2\n3\n\n\n什么叫总线周期？8086cpu的一个总线周期包括多少时钟周期，什么情况下要插入tw等待周期？插入多少个tw取决于什么因素？\n\n答：8086/8088cpu 把 biu 完成一次访问主存储器或外设操作所需的时间称为一个总线周期。一个总线周期最少包含 4 个时钟周期（t1~t4）。\n\t当访问存储器（读/写）或外设时，存储器或外设不能及时地配合 cpu 传送数据，t3 之后插入一个或多个等待等待周期 tw。\n\t当存储器或外设准备好数据，通过“ready”发“准备好”信号，cpu 接收到这个信号后，会自动完成tw 状态进人 t4 状态，因此插入多少个 tw 取决于“ready"信号，即取决于主存或外设的速度。\n\n\n1\n2\n3\n\n\n在8086/8088系统中，什么是最大模式？什么是最小模式？用什么方法将8086/8088置为最大模式或最小模式？\n\n答：（1）最小模式：在系统中只有 8086/8088 一个微处理器，所有的总线控制信号都直接由 8086/8088产生，因此，系统中总线控制电路被减到最少。\n\t（2）最大模式：在系统中包含两个或多个微处理器，其中一个主处理器就是 8088/8086，其它处理器为协处理器，用于协助主处理器工作。它用在中等规模或大型的 8088/8086 系统中。一般情况下和 8088/8086配合的协处理器有两个：一个是数值运算协处理器 8087，一个是输入/输出协处理器 8089。\n\t（3）将 8088/8086 cpu 的第 33 脚接地，系统处于最大模式，当第 33 脚接+5v 时，系统为最小模式。\n\n\n1\n2\n3\n\n\n8259a的主要功能是什么？三个寄存器irr、imr、isr各有什么作用？\n\n答：（1）8259 的功能：\n\t\t①可以管理 8 级中断，通过级联的方式，用 9 片 8259 管理 64 级中断。\n\t\t②判断一个中断请求输入信号 ir 是否有效，是否符合信号的电器约定，是否被屏蔽。\n\t\t③有中断优先逻辑，并可对任一中断单独屏蔽或允许。8259a 的 8 个中断请求输入端 ir0~ir7，哪一个能使 int 输出有效要由编程选定的优先级方式来判定。\n\t\t④cpu 响应中断后，进入中断响应周期inta ，8259a 能将获得优先级的 iri所对应的中断类型号送上数据总线提供给 cpu。\n\t\t⑤ 可通过编程选择工作方式。\n\t（2）三个寄存器 irr、imr 和 isr 的作用：\n\t\t①中断请求寄存器 irr：保存 8 条外界中断请求信号 ir0～ir7 的请求状态。di 位为 1 表示 iri 引脚有中断请求；为 0 表示该引脚无请求。\n\t\t②中断屏蔽寄存器 imr：保存对中断请求信号 ir 的屏蔽状态。di 位为 1 表示 iri 中断被屏蔽（禁止）；为0 表示允许该中断。\n\t\t③中断服务寄存器 isr：保存正在被 8259a 服务着的中断状态。di 位为 1 表示 iri 中断正在服务中；为 0表示没有被服务。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简述半导体存储器的主要技术指标。\n\n答：（1）存储容量。存储器可以存储的二进制信息总量称为存储容量。存储容量有两种表示方法：\n\t\t①位表示方法。以存储器中的存储地址总数与存储字位的乘积表示。如 1k×4 位，表示该芯片有 1k 个单元（1k＝1024），每个存储单元的长度为 4 个二进制位。\n\t\t②字节表示方法。以存储器中的单元总数表示（一个存储单元由 8 个二进制位组成，称为一个字节，用 b 表示）。如 128b，表示该芯片有 128 个单元。\n\t（2）存取速度。存储器的存储速度可以用两个时间参数表示，一个是存取时间：从启动一次存储器操作到完成该操作所经历的时间；另一个是存储周期：启动两次独立的存储器操作之间所需的最小时间间隔。\n\t（3）可靠性。存储器的可靠性用平均故障间隔时间 mtbf 来衡量。mtbf 越长，可靠性越高。\n\t（4）存储带宽。单位时间传输的信息量。\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n12111111111111122121212\n\n论指令周期、总线周期和时钟周期的关系。\n\n答：（1）执行一条指令所需要的时间称为指令周期；\n\t（2）cpu 同外部设备或内存储器之间进行信息交换过程所需要的时间称为总线周期，即启用一次总线进行读或写的时间；\n\t（3）时钟脉冲的重复周期称为时钟周期，它是 cpu 主频的倒数；\n\t（4）一个指令周期由若干个总线周期组成，一个总线周期又由若干个时钟周期组成；\n\t（5）8086cpu 的总线周期至少由 4 个时钟周期组成，当外设不能在 cpu 规定时间内准备好数据时，要在总线周期中插入等待周期。\n\n\n1\n2\n3\n4\n5\n\n\ncpu响应中断时，为什么要执行两个连续的中断响应周期？\n\n答：cpu 响应中断时，执行两个连续的中断响应周期，每个响应周期都给出中断响应信号inta。\n\t这是因为第一个总线周期通知中断请求设备，微处理器准备响应中断，中断控制器 8259a 应该准备好中断类型码，8259a 的 isr 和 irr 对应位分别置 1 清 0；\n\t第二个总线周期中，8259a 把中断类型号送上数据总线，微处理器接收中断类型码，以便得到中断向量，即得到中断服务程序的入口地址。\n\n\n1\n2\n3\n\n\n8086cpu中有哪些寄存器？分别有什么用途。哪些寄存器用来指示存储器单元的偏移地址。\n\n答：8086 cpu 中有 8 个通用寄存器 ax、bx、cx、dx、sp、bp、si、di；\n\t两个控制寄存器 ip、fr；\n\t四个段寄存器 cs、ds、ss、es。\n\t8 个通用寄存器都可以用来暂存参加运算的数据或中间结果，但又有各自的专门用途。\n\t例如：ax 专用做累加器，某些指令指定用它存放操作数和运算结果；cx 为计数寄存器，在某些指令中做计数器使用；dx 为数据寄存器；bx 为基址寄存器，bp 为基址指针，si 为源变址寄存器，di 为目的变址寄存器，这 4 个寄存器在数据寻址中用来存放段内偏移地址（有效地址）或段内偏移地址的一部分；sp 为堆栈指示器，用来存放栈顶有效地址。\n\t两个控制寄存器用来存放有关的状态信息和控制信息。\n\t例如：标志寄存器 fr 用来存放状态标志和控制标志；而指令指针用来存放下一条要取指令的有效地址。\n\t四个段寄存器用来存放段地址。\n\t例如：cs 寄存器用来存放代码段的段地址；ds 寄存器用来存放数据段的段地址；ss 寄存器用来存放堆栈段的段地址；es 寄存器用来存放扩展段的段地址。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在8086中，逻辑地址、偏移地址、物理地址分别指的是什么？具体说明。\n\n答：逻辑地址是在程序中对存储器地址的一种表示方法，由段地址和段内偏移地址两部分组成，\n\t如 1234h：0088h。\n\t偏移地址是指段内某个存储单元相对该段首地址的差值，是一个 16 位的二进制代码。物理地址是 8086 芯片引线送出的 20 位地址码，用来指出一个特定的存储单元。\n\n\n1\n2\n3\n\n\n简述流水线技术，8086怎样实现了最简单的流水线？\n\n答：流水线是指在程序执行时多条指令重叠进行操作的一种并行处理实现技术。流水线的并行处理是指完成一条指令的各个部件在时间上是可以同时重叠工作，分别同时为多条指令的不同部分进行工作，以提高各部件的利用率来提高指令的平均执行速度。流水线技术是把一个重复的过程分解为若干子过程，每个子过程由专门的功能部件来\n实现，将多个处理过程在时间上错开，依次通过个功能段，这样，每个子过程就可以与其他子过程并行进行。\n\t8086 中，指令的读取是在 biu 单元，而指令的执行是在 eu 单元。因为 biu 和 eu 两个单元相互独立、分别完成各自操作，所以可以并行操作。也就是说，在 eu 单元对一个指令进行译码执行时，biu 单元可以同时对后续指令进行读取；这就是最简单的指令流水线技术。\n\n\n1\n2\n3\n\n\n比较8255a三种工作方式的应用场合有何区别？\n\n答：方式 0 适用于同步传送和查询传送方式，\n\t方式 1 适用于外设在能提供选通信号或数据接收信号的场合，且采用中断传送方式比较方便；\n\t方式 2 适用于一个并行外设既可以作为输入设备，又可以作为输出设备，并且输入和输出不会同时进行的场合。\n\n\n1\n2\n3\n\n\n试述程序查询传送方式的工作原理，与查询传送方式相比，中断传送方式有什么优点？\n\n答：查询传送方式在传送数据前先查询外设的状态，当外设准备好时，cpu 执行 i/o指令传送数据；若未准备好时，则 cpu 等待。优点：能较好地协调外设与 cpu 之间的定时关系，因而比无条件传送方式容易实现准确传送。缺点:该方式需要不断查询外设的状态，大量时间花在等待循环中，当主机与中、低速外设交换信息时，大大降低了 cpu 利用率。中断传送方式的优点：提高了 cpu 的效率；cpu 与外设、外设与外设之间能并行工作。\n\n\n1\n\n\n什么叫端口？计算机对i/o端口进行编址时常采用哪俩种方法？在8086/8088系统中，用哪种方法对i/o端口进行编址？\n\n答：cpu 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。\n\t通常有：数据端口、状态端口、控制端口。\n\t对端口编址的两种方法为：计算机对内存和 i/o 端口统一编址；计算机对内存和 i/o 端口独立编址。\n\t在 8086/8088 系统中用计算机对内存和 i/o 端口独立编址。\n\n\n1\n2\n3\n4\n\n\n简述8086内部中断的种类级特点。\n\n答：（1）内部中断又称软件中断，是通过软件调用的不可屏蔽中断，包括溢出中断、除法出错中断、单步中断、int n 指令中断及单字节 int3 指令中断。\n\t（2）中断类型码或者包含在指令中，或者是预先规定的；\n\t（3）不执行 inta 总线周期；\n\t（4）除单步中断外，任何内部中断都无法禁止；\n\t（5）除单步中断外，任何内部中断的优先级都比任何外部中断的高。\n\n\n1\n2\n3\n4\n5\n\n\n汇编语言程序的开发有哪4个步骤，分别利用什么程序完成、产生输出什么文件。\n\n答：汇编语言程序的开发有 4 个步骤：\n\t编辑：用文本编辑器形成一个以 asm 为扩展名的源程序文件。\n\t汇编：用汇编程序将 asm 文件转换为 obj 模块文件。\n\t连接：用连接程序将一个或多个目标文件链接成一个 exe 或 com 可执行文件。\n\t调试：用调试程序排除错误，生成正确的可执行文件。\n\n\n1\n2\n3\n4\n5\n\n\n以可屏蔽中断为例，说明一次完整的中断过程主要包括哪些环节。\n\n答：中断请求：外设通过硬件信号的形式、向处理器引脚发送有效请求信号。\n\t中断响应：在满足一定条件时，处理器进入中断响应总线周期。\n\t关中断：处理器在响应中断后会自动关闭中断。\n\t断点保护：处理器在响应中断后将自动保护断点地址。\n\t中断源识别：处理器识别出当前究竟是哪个中断源提出了请求，并明确与之相应的中断服务程序所在主存位置。\n\t现场保护：对处理器执行程序有影响的工作环境（主要是寄存器）进行保护。\n\t中断服务：处理器执行相应的中断服务程序，进行数据传送等处理工作。\n\t恢复现场：完成中断服务后，恢复处理器原来的工作环境。\n\t开中断：处理器允许新的可屏蔽中断。\n\t中断返回：处理器执行中断返回指令，程序返回断点继续执行原来的程序。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n8086处理器的输入输出信号有reset、hold、nmi和intr，其中含义各是什么？当它们有效时，8086cpu将出现何种反应？\n\n答：reset：复位输入信号，高电平有效。该引脚有效时，将迫使处理器回到其初始状态；转为无效时，cpu 重新开始工作。\n\thold：总线请求，是一个高电平有效的输入信号。该引脚有效时，表示其他总线主控设备向处理器申请使用原来由处理器控制的总线。\n\tnmi：不可屏蔽中断请求，是一个利用上升沿有效的输入信号。该引脚信号有效时，表示外界向 cpu 申请不可屏蔽中断。\n\tintr：可屏蔽中断请求，是一个高电平有效的输入信号。该引脚信号有效时，表示中断请求设备向处理器申请可屏蔽中断。\n\n\n1\n2\n3\n4\n\n\ndma控制器有哪俩种工作状态？并说明dma传送的一般过程。\n\n答：(1)dma 控制器有两种工作状态：\n\t\t①主方式：dma 控制器 8237a 是系统总线的主控者，取代 cpu 控制 dma 传送。\n\t\t②从方式：在成为主控者之前，必须由 cpu 对它编程以确定通道的选择、数据传送的模式、存储器区域首地址、传送总字节数等。这时对于 cpu 来说，8237a 只是个外部设备，是系统总线的从设备。\n\t（2）dma 传送的一般过程：\n\t\t①外设向 dmac 发出 dma 请求；\n\t\t②dmac 向 cpu 发出 dma 请求；\n\t\t③cpu 执行完当前的总线周期后，向 dmac 发出响应请求的应答信号，cpu 让出总线的控制权，由 dmac 控制；\n\t\t④dmac 向外设发出 dma 请求的应答信号；\n\t\t⑤进行 dma 传送，传送完毕，cpu 重新控制总线\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n8259a的icw2设置了中断类型码的哪几位？并说明对8259a分别设置icw2为30h、38h、36h有什么差别？\n\n答：icw2 设置了中断类型码的高 5 位，所以中断类型码基值必须是能被 8 整除的值。\n\t若 icw2 设置为 30h，则 8 级中断的类型码依次为 30h~37h。\n\t若设置为 38h，则 8 级中断的类型码依次为 38h~3fh。\n\t若设置为 36h，中断类型码为 30h~37h，因其高 5 位仍为00110b。\t\n\n\n1\n2\n3\n4\n\n\n8086系统中存储器的逻辑地址由哪两部分组成？物理地址由何器件生成？如何生成？每个段的逻辑地址与存储器之间有何对应关系？\n\n答：答：（1）8086 系统中存储器的逻辑地址由段地址（段首址）和段内偏移地址（有效地址）两部分组成；\n\t（2）存储单元的物理地址由地址加法器生成。\n\t（3）寻址时，cpu 首先将段地址和段内偏移地址送入地址加法器，地址加法器将段地址左移 4 位并与段内偏移地址相加，得到一个 20 位的物理地址。\n\t（4）数据段的段地址在 ds 寄存器中，段内偏移地址可能在 bx、bp、si 或 di 寄存器中。\n\t\t代码段的段地址在 cs 寄存器中，段内偏移地址在 ip 寄存器中。\n\t\t堆栈段的段地址在ss 寄存器中，段内偏移地址在 sp 寄存器中。\n\t\t扩展段的段地址在 es 寄存器中，段内偏移地址可能在 bx、bp、si 或 di 寄存器中。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n\n\n----------------------------------------\n\n答：\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/06/26, 10:06:00",lastUpdatedTimestamp:165621188e4},{title:"微机原理填空题",frontmatter:{title:"微机原理填空题",date:"2022-03-04T02:30:00.000Z",permalink:"/c1/3",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/02.%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%A1%AB%E7%A9%BA%E9%A2%98.html",relativePath:"02.练习题/02.微机原理填空题.md",key:"v-3be4d484",path:"/c1/3/",headers:[{level:2,title:"微机原理填空题",slug:"微机原理填空题",normalizedTitle:"微机原理填空题",charIndex:2}],headersStr:"微机原理填空题",content:"# 微机原理填空题\n\n * 计算机主板上总线的发展情况：微型计算机的标准总线从16位的EISA总线，发展到32位的 EISA（扩展标准总线） 总线和 PCI（外设部件互联标准总线） 总线。\n\n * 编程语言发展的三个阶段： 机器语言、汇编语言、高级语言。\n\n * 8086微处理器按功能分为 EU（指令执行部件）、BIU（总线接口部件），两个单元相互独立，各自操作、并行执行，实现指令预取（流水线）。\n\n * 指令执行的步骤： 取指令、分析指令、执行指令。\n\n * 主存与cache的地址映射方式有： 全相连方式、直接相连方式、组相连方式。\n\n * 并行数据和串行数据的转换是用 移位寄存器。\n\n * SP 和 BP 寄存器与 SS 寄存器联合使用以确定堆栈中存储单元地址。\n\n * 执行PUSH AX指令后，SP发生了什么变化 SP-2。\n\n * 执行POP AX指令后，SP发生了什么变化 SP+2。\n\n * 堆栈的特点 先进后出/后进先出。\n\n * 执行HLT（处理器“暂停”指令）需要 一个 总线周期。\n\n * 执行MOV AX,[1000H]需要 二个 总线周期。\n\n * 执行ADD AX,[2000H]需要 三个 总线周期。\n\n * 8086/8088复位时，CS的值为 FFFFH ，IP的值为 0000H 。\n\n * 中断类型有 256 种，分为 内中断 、外中断。\n\n * 中断向量表在内存的前1KB中的地址范围是 0000H ~ 03FFH。\n\n * 一个中断向量占 4 个字节，高字节放 CS 、低字节放 IP。\n\n * 在系统中断，中断类型号是在 中断响应信号（INTA非） 的作用下送完CPU。\n\n * 中断源是指 引起中断的设备或事件 。\n\n * CPU在中断服务程序中需要响应比当前中断源更高级别的中断，则应在中断服务程序的开头加上 STI【开中断（IF置1）】 中断服务子程序的最后一条指令是 iret（返回主程序）。\n\n * CPU的能直接访问 主存 和 cache ，但是不能访问 外存 和 IO设备 。\n\n * BHE =0、A0=1时，cpu访问 奇地址体 。\n\n * BHE =1A0=0时，cpu访问 偶地址体 。\n\n * PSW寄存器中共有 6 位条件状态位，有 3 位控制状态位。\n\n * 8086微型处理器在访问四个当前段时，堆栈段的偏移量由 SP/BP 提供。\n\n * 控制器是微处理器的重要组成部分，下列哪项不是控制器组成部分 A 。【2020年】\n   \n   A.消息队列、B.程序计数器PC、C.指令寄存器、D.时序电路\n\n * 88\\86执行RESET（复位）后CS= FFFFH 、IP= 0000H。\n\n * 一个完整的中断过程一般经历以下五个步骤：中断请求、中断优先级判定、中断相应、中断处理、中断返回。\n\n * 一个存储单元除具有一个唯一的 物理地址 外，还具有多个 逻辑地址 。\n\n * NMI（不可屏蔽中断）引脚所对应的中断类型码是 02H 。\n\n * 中断控制器8259可管理 可屏蔽中断 。\n\n * 实质上，微处理器对外设访问就是对外设 接口 中的端口寄存器进行访问。\n\n * 在8088CPU中，为了减少CPU等待取指令所需要的时间，设置了 指令队列 。\n\n * ROM是 非易失性存储器 ，RAM是 易失性存储器 。\n\n * 中断向量是中断服务程序的 入口地址 ，每个中断向量占 4 字节。8086中对应256类中断的中断向量存放在 中断向量表 中，占据内存从 00000H 到 003FFH 区间。\n\n * 在有多重中断的系统中，通常解决中断优先级的方法有 软件查询 、 硬件查询 和中断优先级编码三种。\n\n * 主存储器的技术指标有 速度 、 容量 和主存带宽。\n\n * 微处理器应包含的最基本功能部件是 算数逻辑单元 、控制器部件 和 存储器单元（寄存器） 。\n\n * 8086/8088在满足 当前指令结束 和标志位IF=1的条件下可以响应一个外部INTR中断请求。\n\n * 在8088CPU中，为了减少CPU等待取指令所需的时间，设置了 指令队列 。\n\n * 在有多重中断的系统中，通常解决中断优先级的方法有 软件查询 、 硬件查询 和 中断优先级编码 三种。\n\n * 保护断点就是保存 当前CS、IP的值 。\n\n * 8086CPU的PUSH指令执行时 先将SP-2，再压数据 。\n\n * 在8086最小工作方式下，典型的 8282芯片 功能是 地址锁存 。\n\n * 8288芯片的作用是 总线控制器 。\n\n * 8086根据所构成系统的大小不同，可以工作在最大方式或最小方式。在最大方式下，系统需要使用 总线控制器（8288） 来形成总线周期。\n\n * DRAM与SRAM比较 DRAM比SRAM价格低 。\n\n * 表示数据的存储器单元符号的地址为 变量 。\n\n * 在8086系统中，为了能正确返回被中断的程序，则当CPU响应外部中断请求并转向中断处理子程序前，应将 断点的地址 压入堆栈。\n\n * 在串操作指令前使用重复前缀指令REPE，终止串的重复操作的条件是 CX=0或ZF=0 。\n\n * 在8086系统中对单片8259A进行初始化时，必须设置的初始化命令字为 ICW1、ICW2、ICW4 。\n\n * 串行同步传送时，每一帧数据都是由 同步字符 开头的。\n\n * 实现微处理器与8259之间信息交换的是 数据总线缓冲器 与读写控制电路。\n\n * 调用程序和子程序之间的信息传送称为 参数传递 。\n\n * RS-232C是应用于 串行 二进制的数据通信设备和数据终端设备之间的总线接口。\n\n * 指令REPNE/REPNZ的功能是相等或为零时重复操作，退出的条件是 CX=0或ZF=1 。\n\n * n+1位有符号数x的补码表示范围为 -2^n^ <x<= 2^n^ -1\n\n * 世界上第一台电子计算机 ENIAC 机。\n\n * 8086微处理器的引脚信号中，不受最小/最大工作方式影响的控制信号是 RD 。\n\n * 8位有符号二进制补码表示范围是 -128—127 。\n\n * 8086CPU的地址总线有20位，可直接寻址1MB的存储空间，在独立编址方式下，可寻址 64KB 个I/O端口。\n\n * 属于串行通信接口芯片标准的是 USB 。\n\n * 使用INT 21H的2号功能显示1十六进制数码，需要 将该数码加30H或加37H在再送DL 。\n\n * 中断屏蔽寄存器的作用是 禁止8259相应某级中断申请传向CPU 。\n\n * 8255A工作于方式0，微处理器可以采用 无条件传送 和 查询传送 方式 。\n\n * 8259A可以接受CPU送来的 初始化（预置） 命令字和 操作 命令字 。\n\n * 在8086最小模式的典型配置中，需 2 片双向总线收发器8286，需 3 片地址锁存器8282。\n\n * 8253具有 3 个独立的 16 位的计数器。\n\n * 8位二进制反码10000000B 表示的十进制数为 -127 8位二进制补码10000000B表示十进制数为 -128 。\n\n * 全译码和线选法 存在地址重叠 问题，部分译码 不存在地址重叠问题 。\n\n * 74LS244是 常用的地址缓冲器 。\n\n * 2732EPROM是 4K*8 的芯片。\n\n * 下列有关程序控制传送方式的说法错误的是 A 。\n\n>  * A.中断传送方式不能实现多个外设并行工作。\n>  * B.查询传送方式又称“异步传送方式” 。\n>  * C.无条件传送方式又称“同步传送方式”。\n>  * D.中断方式数据传送完成后，程序会回到断点处继续执行。\n\n * 设模为2^8^,则53的补码为 35H ，-14的补码为 0F2H，-0的补码为 00H 。\n\n * 在段定义中，默认的定位类型是 PARA 。\n\n * 在进入DMA工作方式之前，DMA控制器被当作CPU总线上的一个 I/O接口 。\n\n * 中断向量号1AH在中断向量类型表中的逻辑地址是 0000H:0068H 。\n\n * 8255A的工作方式有基本型输入输出方式、字节选通I/O 和方式 双向I/O 方式。\n\n * 地址锁存器8282的选通信号STB应接CPU的 ALE 信号，输出允许端OE 应接 地 ;数据收发器8286的方向控制端T应接 DT/R ，输出允许端OE 应接 DEN 。\n\n * 当8253工作在 方式5 时，需要由外部脉冲触发开始计数。\n\n * 有关储存器映像I/O方式正确的是 C 。\n\n * A.称为I/O独立编址 B. I/O端口地址空间独立于存储器地址空间 C. 增加地址译码的复杂性 D. I/O指令类型较少\n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * ",normalizedContent:"# 微机原理填空题\n\n * 计算机主板上总线的发展情况：微型计算机的标准总线从16位的eisa总线，发展到32位的 eisa（扩展标准总线） 总线和 pci（外设部件互联标准总线） 总线。\n\n * 编程语言发展的三个阶段： 机器语言、汇编语言、高级语言。\n\n * 8086微处理器按功能分为 eu（指令执行部件）、biu（总线接口部件），两个单元相互独立，各自操作、并行执行，实现指令预取（流水线）。\n\n * 指令执行的步骤： 取指令、分析指令、执行指令。\n\n * 主存与cache的地址映射方式有： 全相连方式、直接相连方式、组相连方式。\n\n * 并行数据和串行数据的转换是用 移位寄存器。\n\n * sp 和 bp 寄存器与 ss 寄存器联合使用以确定堆栈中存储单元地址。\n\n * 执行push ax指令后，sp发生了什么变化 sp-2。\n\n * 执行pop ax指令后，sp发生了什么变化 sp+2。\n\n * 堆栈的特点 先进后出/后进先出。\n\n * 执行hlt（处理器“暂停”指令）需要 一个 总线周期。\n\n * 执行mov ax,[1000h]需要 二个 总线周期。\n\n * 执行add ax,[2000h]需要 三个 总线周期。\n\n * 8086/8088复位时，cs的值为 ffffh ，ip的值为 0000h 。\n\n * 中断类型有 256 种，分为 内中断 、外中断。\n\n * 中断向量表在内存的前1kb中的地址范围是 0000h ~ 03ffh。\n\n * 一个中断向量占 4 个字节，高字节放 cs 、低字节放 ip。\n\n * 在系统中断，中断类型号是在 中断响应信号（inta非） 的作用下送完cpu。\n\n * 中断源是指 引起中断的设备或事件 。\n\n * cpu在中断服务程序中需要响应比当前中断源更高级别的中断，则应在中断服务程序的开头加上 sti【开中断（if置1）】 中断服务子程序的最后一条指令是 iret（返回主程序）。\n\n * cpu的能直接访问 主存 和 cache ，但是不能访问 外存 和 io设备 。\n\n * bhe =0、a0=1时，cpu访问 奇地址体 。\n\n * bhe =1a0=0时，cpu访问 偶地址体 。\n\n * psw寄存器中共有 6 位条件状态位，有 3 位控制状态位。\n\n * 8086微型处理器在访问四个当前段时，堆栈段的偏移量由 sp/bp 提供。\n\n * 控制器是微处理器的重要组成部分，下列哪项不是控制器组成部分 a 。【2020年】\n   \n   a.消息队列、b.程序计数器pc、c.指令寄存器、d.时序电路\n\n * 88\\86执行reset（复位）后cs= ffffh 、ip= 0000h。\n\n * 一个完整的中断过程一般经历以下五个步骤：中断请求、中断优先级判定、中断相应、中断处理、中断返回。\n\n * 一个存储单元除具有一个唯一的 物理地址 外，还具有多个 逻辑地址 。\n\n * nmi（不可屏蔽中断）引脚所对应的中断类型码是 02h 。\n\n * 中断控制器8259可管理 可屏蔽中断 。\n\n * 实质上，微处理器对外设访问就是对外设 接口 中的端口寄存器进行访问。\n\n * 在8088cpu中，为了减少cpu等待取指令所需要的时间，设置了 指令队列 。\n\n * rom是 非易失性存储器 ，ram是 易失性存储器 。\n\n * 中断向量是中断服务程序的 入口地址 ，每个中断向量占 4 字节。8086中对应256类中断的中断向量存放在 中断向量表 中，占据内存从 00000h 到 003ffh 区间。\n\n * 在有多重中断的系统中，通常解决中断优先级的方法有 软件查询 、 硬件查询 和中断优先级编码三种。\n\n * 主存储器的技术指标有 速度 、 容量 和主存带宽。\n\n * 微处理器应包含的最基本功能部件是 算数逻辑单元 、控制器部件 和 存储器单元（寄存器） 。\n\n * 8086/8088在满足 当前指令结束 和标志位if=1的条件下可以响应一个外部intr中断请求。\n\n * 在8088cpu中，为了减少cpu等待取指令所需的时间，设置了 指令队列 。\n\n * 在有多重中断的系统中，通常解决中断优先级的方法有 软件查询 、 硬件查询 和 中断优先级编码 三种。\n\n * 保护断点就是保存 当前cs、ip的值 。\n\n * 8086cpu的push指令执行时 先将sp-2，再压数据 。\n\n * 在8086最小工作方式下，典型的 8282芯片 功能是 地址锁存 。\n\n * 8288芯片的作用是 总线控制器 。\n\n * 8086根据所构成系统的大小不同，可以工作在最大方式或最小方式。在最大方式下，系统需要使用 总线控制器（8288） 来形成总线周期。\n\n * dram与sram比较 dram比sram价格低 。\n\n * 表示数据的存储器单元符号的地址为 变量 。\n\n * 在8086系统中，为了能正确返回被中断的程序，则当cpu响应外部中断请求并转向中断处理子程序前，应将 断点的地址 压入堆栈。\n\n * 在串操作指令前使用重复前缀指令repe，终止串的重复操作的条件是 cx=0或zf=0 。\n\n * 在8086系统中对单片8259a进行初始化时，必须设置的初始化命令字为 icw1、icw2、icw4 。\n\n * 串行同步传送时，每一帧数据都是由 同步字符 开头的。\n\n * 实现微处理器与8259之间信息交换的是 数据总线缓冲器 与读写控制电路。\n\n * 调用程序和子程序之间的信息传送称为 参数传递 。\n\n * rs-232c是应用于 串行 二进制的数据通信设备和数据终端设备之间的总线接口。\n\n * 指令repne/repnz的功能是相等或为零时重复操作，退出的条件是 cx=0或zf=1 。\n\n * n+1位有符号数x的补码表示范围为 -2^n^ <x<= 2^n^ -1\n\n * 世界上第一台电子计算机 eniac 机。\n\n * 8086微处理器的引脚信号中，不受最小/最大工作方式影响的控制信号是 rd 。\n\n * 8位有符号二进制补码表示范围是 -128—127 。\n\n * 8086cpu的地址总线有20位，可直接寻址1mb的存储空间，在独立编址方式下，可寻址 64kb 个i/o端口。\n\n * 属于串行通信接口芯片标准的是 usb 。\n\n * 使用int 21h的2号功能显示1十六进制数码，需要 将该数码加30h或加37h在再送dl 。\n\n * 中断屏蔽寄存器的作用是 禁止8259相应某级中断申请传向cpu 。\n\n * 8255a工作于方式0，微处理器可以采用 无条件传送 和 查询传送 方式 。\n\n * 8259a可以接受cpu送来的 初始化（预置） 命令字和 操作 命令字 。\n\n * 在8086最小模式的典型配置中，需 2 片双向总线收发器8286，需 3 片地址锁存器8282。\n\n * 8253具有 3 个独立的 16 位的计数器。\n\n * 8位二进制反码10000000b 表示的十进制数为 -127 8位二进制补码10000000b表示十进制数为 -128 。\n\n * 全译码和线选法 存在地址重叠 问题，部分译码 不存在地址重叠问题 。\n\n * 74ls244是 常用的地址缓冲器 。\n\n * 2732eprom是 4k*8 的芯片。\n\n * 下列有关程序控制传送方式的说法错误的是 a 。\n\n>  * a.中断传送方式不能实现多个外设并行工作。\n>  * b.查询传送方式又称“异步传送方式” 。\n>  * c.无条件传送方式又称“同步传送方式”。\n>  * d.中断方式数据传送完成后，程序会回到断点处继续执行。\n\n * 设模为2^8^,则53的补码为 35h ，-14的补码为 0f2h，-0的补码为 00h 。\n\n * 在段定义中，默认的定位类型是 para 。\n\n * 在进入dma工作方式之前，dma控制器被当作cpu总线上的一个 i/o接口 。\n\n * 中断向量号1ah在中断向量类型表中的逻辑地址是 0000h:0068h 。\n\n * 8255a的工作方式有基本型输入输出方式、字节选通i/o 和方式 双向i/o 方式。\n\n * 地址锁存器8282的选通信号stb应接cpu的 ale 信号，输出允许端oe 应接 地 ;数据收发器8286的方向控制端t应接 dt/r ，输出允许端oe 应接 den 。\n\n * 当8253工作在 方式5 时，需要由外部脉冲触发开始计数。\n\n * 有关储存器映像i/o方式正确的是 c 。\n\n * a.称为i/o独立编址 b. i/o端口地址空间独立于存储器地址空间 c. 增加地址译码的复杂性 d. i/o指令类型较少\n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * \n\n * ",charsets:{cjk:!0},lastUpdated:"2022/06/26, 10:06:00",lastUpdatedTimestamp:165621188e4},{title:"微机原理简答题",frontmatter:{title:"微机原理简答题",date:"2022-03-04T02:10:00.000Z",permalink:"/c1/6",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/05.%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AE%80%E7%AD%94%E9%A2%98%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%89.html",relativePath:"02.练习题/05.微机原理简答题（分类）.md",key:"v-741e2425",path:"/c1/6/",headers:[{level:2,title:"计算机的部件及编程语言",slug:"计算机的部件及编程语言",normalizedTitle:"计算机的部件及编程语言",charIndex:18},{level:2,title:"8086/8088最小/最大工作模式",slug:"_8086-8088最小-最大工作模式",normalizedTitle:"8086/8088最小/最大工作模式",charIndex:2773},{level:2,title:"内存、存储器",slug:"内存、存储器",normalizedTitle:"内存、存储器",charIndex:3627},{level:2,title:"总线、接口（总线周期）",slug:"总线、接口-总线周期",normalizedTitle:"总线、接口（总线周期）",charIndex:4899},{level:2,title:"中断",slug:"中断",normalizedTitle:"中断",charIndex:5538},{level:2,title:"传送方式及奇偶地址体",slug:"传送方式及奇偶地址体",normalizedTitle:"传送方式及奇偶地址体",charIndex:9743},{level:2,title:"指令周期、总线周期、时钟周期",slug:"指令周期、总线周期、时钟周期",normalizedTitle:"指令周期、总线周期、时钟周期",charIndex:11249}],headersStr:"计算机的部件及编程语言 8086/8088最小/最大工作模式 内存、存储器 总线、接口（总线周期） 中断 传送方式及奇偶地址体 指令周期、总线周期、时钟周期",content:'# 微机原理简答题（分类）\n\n\n# 计算机的部件及编程语言\n\n计算机硬件组成的五个部件是什么：？\n\n答：输入设备、输出设备、运算器、存储器、控制器\n\n\n1\n\n\n计算器系统由什么组成？\n\n答：硬件系统和软件系统两部分组成。\n\n\n1\n\n\n简述RISC（精简指令集）的特点：\n\n答：1、CPU处理指令是由硬件完成、运行速度快；\n    2、指令长度固定、指令格式种类少、寻址方式种类少；\n    3、只有取数/存数指令访问存储器，其余指令的操作都在寄存器内完成；\n    4、采用流水线技术，大部分指令在一个时钟周期内完成；\n    5、控制器采用组合逻辑控制，不用微程序控制。\n    6、采用优化的编译程序。\n\n\n1\n2\n3\n4\n5\n6\n\n\n寄存器按功能可分为几大类，分别说明包含什么寄存器？\n\n答：可分为3大类8个通用寄存器、4个段寄存器、2个控制寄存器；\n    分别是：通用寄存器又分为4个数据寄存器、2个地址寄存器、2个变址寄存器；\n            数据寄存器：AX（累加器）、BX（基址寄存器）、CX（计数寄存器）、DX（数据寄存器）\n            地址寄存器：BP（基址指针寄存器）、SP（堆栈指针寄存器）\n            变址寄存器：SI（源变址寄存器）、DI（目标变址寄存器）\n            段寄存器：CS（代码段寄存器）、DS（数据段寄存器）、ES（附加段寄存器）、SS（堆栈段寄存器）\n            控制寄存器：IP（指令寄存器）、FLAGS（状态标志寄存器）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述8086和8088的区别：\n\n答：1.8086：是完全16位机，外部总线和内部总线是16根；\n      8088：内部总线是16根，外部总线是8根；\n    2.8086：有6字节的指令队列；\n      8088：有4字节的指令队列；\n    3.8086：使用M/IO非（IO非，低电平）引脚；\n      8088：使用IO/M非（M非，低电平）引脚；\n\n\n1\n2\n3\n4\n5\n6\n\n\n88/86两个单元的功能：\n\n答：1、BIU：负责CUP对主存和外设接口进行访问\n\t\t①取指令：从内存取指令，送指令队列\n\t\t④取操作数：从内存或接口取操作数\n\t\t⑦送结果：从BIU送内存或接口外设\n\t2、EU：负责指令译码、执行和数据的运算\n\t\t②取指令：从指令队列取指令送控制器\n\t\t③分析译码：识别指令功能\n\t\t⑤执行指令：在ALU中运算加工\n\t\t⑥送结果：由EU送BIU\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n写出CPU中主要寄存器：\n\n答：AX、BX、CX、DX、SI、DI、BP、SP、IP、CS、DS、ES、SS、FR\n\n\n1\n\n\n8086CPU中有哪些寄存器？分别有什么用途。哪些寄存器用来指示存储器单元的偏移地址。\n\n答：8086 CPU 中有 8 个通用寄存器 AX、BX、CX、DX、SP、BP、SI、DI；\n\t两个控制寄存器 IP、FR；\n\t四个段寄存器 CS、DS、SS、ES。\n\t8 个通用寄存器都可以用来暂存参加运算的数据或中间结果，但又有各自的专门用途。\n\t例如：AX 专用做累加器，某些指令指定用它存放操作数和运算结果；CX 为计数寄存器，在某些指令中做计数器使用；DX 为数据寄存器；BX 为基址寄存器，BP 为基址指针，SI 为源变址寄存器，DI 为目的变址寄存器，这 4 个寄存器在数据寻址中用来存放段内偏移地址（有效地址）或段内偏移地址的一部分；SP 为堆栈指示器，用来存放栈顶有效地址。\n\t两个控制寄存器用来存放有关的状态信息和控制信息。\n\t例如：标志寄存器 FR 用来存放状态标志和控制标志；而指令指针用来存放下一条要取指令的有效地址。\n\t四个段寄存器用来存放段地址。\n\t例如：CS 寄存器用来存放代码段的段地址；DS 寄存器用来存放数据段的段地址；SS 寄存器用来存放堆栈段的段地址；ES 寄存器用来存放扩展段的段地址。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n什么是地址锁存器？8088/8086为什么要用地址锁存器？锁存的是什么信息？举例说明。\n\n答：（1）地址锁存器是一个暂存器，它根据控制信号的状态将总线上的地址代码暂存起来。\n\t（2）8088/8086 的数据和地址总线采用分时复用操作方式，即用同一总线既传送地址又传送数据。\n\t\t当微处理器与存储器交换信号时，首先由 CPU 发送存储器的地址，同时发允许锁存信号ALE给锁存器，\n\t\t当锁存器接到该信号后将地址/数据总线上的地址锁存在锁存器中，随后才能传送数据信息。\n\t（3）8088/8086 系统的地址锁存器采用 74LS373/273 或者 8282/8283，每片能够锁8 位地址。\n\n\n1\n2\n3\n4\n5\n\n\n8086CPU从接口上分为几部分？各部分由什么组成？各部分功能是什么？\n\n答：（1）8086CPU 从功能上分为两大部分：一是执行部件(EU)，二是总线接口部件(BIU)。\n\t（2）执行部件(EU)是由以下 4 部分组成：\n\t\t①4 个通用寄存器：AX、BX、CX、DX。\n\t\t②4 个专用寄存器：基址指针寄存器 BP，堆栈指针寄存器 SP，源变址寄存器SI，目的变址寄存器DI。\n\t\t③标志寄存器 FR。\n\t\t④算术逻辑部件 ALU。\n\t\t功能：负责执行所有的指令，向总线接口部件(BIU)提供指令执行的结果数据和地址，并对通用寄存器和标志寄存器进行管理。\n\t（3）总线接口部件(BIU)由以下部件组成:\n\t\t①4 个段寄存器：代码段寄存器 CS，数据段寄存器 DS，附加段寄存器 ES，堆栈段寄存器SS。②指令指针寄存器。\n\t\t③地址加法器。\n\t\t④指令队列。\n\t\t功能：执行外部总线周期，负责 CPU 与主存储器和外设之间的信息交换。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n站在80X86，汇编语言程序员的角度，说明数据存储位置有哪些？访问这些数据可采用的寻址方式分别是什么？对这些位置对数据访问速度是否相同，为什么？\n\n答：（1）数据存储位置有 CPU 内部的寄存器、内存、IO 端口\n\t（2）采用的寻址方式分别是：\n\t\t①寄存器操作数采用寄存器寻址\n\t\t②存储器操作数采用直接寻址，寄存器间接寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址 \n\t\t③IO 端口的访问需专门的 IO 指令，有直接寻址和间接寻址。\n\t（3）速度不同，寄存器位于 CPU 内部，因此速度最快，存储器操作数速度较慢，因为需要通过系统总线访问内存，\n\t\t端口的访问最慢，属于输入/输出操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 8086/8088最小/最大工作模式\n\n简述最小工作模式：\n\n答：MN/MX非=1，为最小工作模式；\n    在系统中只有8086/8088一个微处理器，所有的总线控制信号直接由8086/8088产生；\n    因此，系统中的总线控制逻辑电路被减到最少，最小模式是单处理器系统。\n\n\n1\n2\n3\n\n\n简述最大工作模式：\n\n答：MN/MX非=0，为最大工作模式；\n    系统中有两个或两个以上的微处理器；即除了主处理器8086/8088以外，\n还有协处理器（8087算数协处理器或8089输入输出协处理器），最大模式可构成多处理器系统，\n系统中所有的控制信号由总线控制器（8288）提供。\n\n\n1\n2\n3\n4\n\n\n最小工作模式与最大工作模式的区别：\n\n答：最大模式是相对最小模式而言的；\n    最大模式用在中等规模的或者大型8086/8088系统中；\n    在最大模式系统中，总是包含两个或多个微处理器其中一个主处理器就是8086/8088，\n其他的称为协处理器，它们是协助处理器工作的；\n    CPU工作模式的选择是由硬件决定的。\n\n\n1\n2\n3\n4\n5\n\n\n在8086/8088系统中，什么是最大模式？什么是最小模式？用什么方法将8086/8088置为最大模式或最小模式？\n\n答：（1）最小模式：在系统中只有 8086/8088 一个微处理器，所有的总线控制信号都直接由 8086/8088产生，因此，系统中总线控制电路被减到最少。\n\t（2）最大模式：在系统中包含两个或多个微处理器，其中一个主处理器就是 8088/8086，其它处理器为协处理器，用于协助主处理器工作。它用在中等规模或大型的 8088/8086 系统中。一般情况下和 8088/8086配合的协处理器有两个：一个是数值运算协处理器 8087，一个是输入/输出协处理器 8089。\n\t（3）将 8088/8086 CPU 的第 33 脚接地，系统处于最大模式，当第 33 脚接+5V 时，系统为最小模式。\n\n\n1\n2\n3\n\n\n\n# 内存、存储器\n\n简述触发器、寄存器与存储器之间的关系：\n\n答：触发器是计算机记忆装置的基本单元，一个触发器能存储一位二进制数也为一个一位寄存器；\n\t多个出触发器就可以构成一个多位寄存器，而一个寄存器为为一个存储单元；\n\t多个寄存器组成一个存储器。\n\n\n1\n2\n3\n\n\nROM、PROM、EPROM和EEPROM在使用上各有什么特点？\n\n答：ROM：掩膜ROM，信息制作在芯片中，不可更改\n\tPROM：允许一次编程，此后不可更改\n\tEPROM：紫外线照射擦除，可多次擦除和编程，未编程前所有单元格信息都为1，写入后的部分为0\n\tEEPROM：加电在线擦除和编写，可多次擦写\n\n\n1\n2\n3\n4\n\n\n寄存器、cache、内存和外存的区别：\n\n答：寄存器：是CUP内部暂存数据单元，如：AX、BX等；\ncache：位于CPU和内存之间，可直接与CPU进行数据交换，解决内存速度不足的问题；\n内存：也叫主存，可直接与CPU进行数据交换；\n外存：主要用来长久保存数据，如：硬盘、光盘、U盘等。外存的数据只能通过主存间接地与CPU交换数据。\n\n\n1\n2\n3\n4\n\n\n简述缓冲器、锁存器和触发器的作用。\n\n答：\n（1）缓冲器：又称缓冲寄存器。\n\t①完成速度的匹配，在高速工作的 CPU 与慢速工作的外设间起协调和缓冲作用，实现数据传送的同步。（1 分）\n\t②提供一个暂存的空间。它分输入缓冲器和输出缓冲器两种。输入缓冲器是将外设送来的数据暂时存放，以便处理器将它取走；输出缓冲器是用来暂时存放处理器送往外设的数据。（1 分）\n\t③提高驱动能力。（1 分）\n\t④信号隔离的作用，消除负载对信号源的影响。（1 分）\n（2）锁存器（latch）：利用电平控制数据的传输。（1 分）\n\t①缓存。（1 分）\n\t②完成高速的控制器与慢速的外设的不同步问题。（1 分）\n\t③解决驱动的问题。（1 分）\n（3）触发器：是最小的记忆单元,能记忆二进制数的一个数位，是寄存器、存储器基本元件。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简述半导体存储器的主要技术指标。\n\n答：（1）存储容量。存储器可以存储的二进制信息总量称为存储容量。存储容量有两种表示方法：\n\t\t①位表示方法。以存储器中的存储地址总数与存储字位的乘积表示。如 1K×4 位，表示该芯片有 1K 个单元（1K＝1024），每个存储单元的长度为 4 个二进制位。\n\t\t②字节表示方法。以存储器中的单元总数表示（一个存储单元由 8 个二进制位组成，称为一个字节，用 B 表示）。如 128B，表示该芯片有 128 个单元。\n\t（2）存取速度。存储器的存储速度可以用两个时间参数表示，一个是存取时间：从启动一次存储器操作到完成该操作所经历的时间；另一个是存储周期：启动两次独立的存储器操作之间所需的最小时间间隔。\n\t（3）可靠性。存储器的可靠性用平均故障间隔时间 MTBF 来衡量。MTBF 越长，可靠性越高。\n\t（4）存储带宽。单位时间传输的信息量。\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 总线、接口（总线周期）\n\n什么是总线，简述各类总线的应用场合？\n\n答：（1）总线（Bus）是计算机各种功能部件之间传送信息的公共通信线，\n\t\t它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，\n\t\t外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。\n\t（2）按总线功能或信号类型来分，有数据总线、地址总线和控制总线。 按总线的层次结构分来为，有：\n\t\t① CPU 片内总线：微机系统中速度最快的总线，主要在 CPU 内部，连接 CPU 内部部件，提供系统原始的控制和命令。\n\t\t②系统总线：在系统总线和 CPU 总线之间的一级总线，提供 CPU 和主板器件之间以及CPU到高速外设之间的快速信息通道。\n\t\t③通信总线：也称为外部总线，是微机与微机、微机与外设之间进行通信的总线。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述在最小工作模式下，8086如何响应一个总线请求？\n\n答：外部总线主控模块经 HOLD 引线向 8086 发出总线请求信号；\n\t8086 在每个时钟周期的上升沿采样HOLD 引线；\n\t若发现 HOLD=1 则在当前总线周期结束时(T4 结束)发出总线请求的响应信号HLDA；\n\t8086使地址、数据及控制总线进入高阻状态，让出总线控制权，完成响应过程。\n\n\n1\n2\n3\n4\n\n\n简述CPU与外设进行数据交换的方式，并说明每种方式的特点。\n\n答：CPU 与外设进行数据交换的方式有：无条件传送方式、查询传送方式、中断控制方式、直接存储器存取控制方式（DMA）和通道方式。\n\t（1）程序控制方式: 特点是依靠程序的控制来实现主机和外设的数据传送，可分为无条件传送方式、查询方式和中断方式。\n\t\t三种方式都是以 CPU 为中心的控制方式，都需要 CPU 执行程序来进行I/O数据传送。\n\t\t①无条件传送方式：程序简单，所需的硬件和软件都比较少、传送速度快，但必须在确信外设已准备好的情况下才能使用。\n\t\t②查询传送方式：CPU 通过程序不断查询相应设备的状态，状态不符合要求，则CPU 需要等待；只有当状态信号符合要求时，\n\t\t\tCPU 才能进行相应的操作。硬件线路简单，程序易于实现；缺点是CPU利用率低下，实时性差。\n\t\t③中断控制方式: 外设在准备就绪的条件下通过请求引脚信号，主动向处理器提出交换数据的请求。CPU与外设、外设与外设之间能并行工作。\n\t\t\t一般适合于传送数据量少的中低速外部设备，尤其适合实时控制中的紧急事件处理，对于高速外部设备的大批量数据传送不适合。\n\t（2）直接存储器存取控制方式（DMA）：CPU 不参加数据传送，而是由 DMA 控制器来实现内存与外设，外设与外设之间的直接传递。\n\t\t此种方式适用于需要大量数据高速传送的场合。CPU 与外设可以并行工作，提高了 CPU 的效率。\n\t（3）通道方式：可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简述总线的定义：\n\n答：在计算机系统中，各个部件之间传送信息的公共通道叫做总线（BUS），\n\t按照所传输的信息种类可划分为数据总线、地址总线、控制总线。\n\n\n1\n2\n\n\n简述IDE、SCSI、SATA接口总线：\n\n答：是硬盘和光驱接口标准。\n\tIDE：Intergrated Drive Electronics；【电子集成驱动器】16/32位\n\tSCSI：Small Computer System Interface；【小型计算机系统接口】32位\n\tSATA：串行ATA（Serial ATA），SATA3.0接口。【目前硬盘和光驱的主要接口】\n\n\n1\n2\n3\n4\n\n\n简述IEEE394总线、AGP总线、PCI总线功能：\n\n答：IEEE394总线：是高性能串行总线标准；视频采集、数码影像设备的传输标准。\n\tAGP总线：图形加速口：提高视频带宽。\n\tPCI总线：（Peripheral Component Interconnect）外设部件互联标准；\n\t\t可以通过桥连接多条PCI总线；PCI总线上的设备可以与CPU并行工作。\n\n\n1\n2\n3\n4\n\n\n总线的性能指标：\n\n答：1、总线贷款：数据传输率，单位：bps\n\t2、总线位宽：同时传输的二进制位数；\n\t一次所能并行传送信息的位数，亦称为数据路宽度。\n\t3、总线工作频率：Mhz\n\n\n1\n2\n3\n4\n\n\n什么叫总线周期？8086CPU的一个总线周期包括多少时钟周期，什么情况下要插入Tw等待周期？插入多少个Tw取决于什么因素？\n\n答：8086/8088CPU 把 BIU 完成一次访问主存储器或外设操作所需的时间称为一个总线周期。一个总线周期最少包含 4 个时钟周期（T1~T4）。\n\t当访问存储器（读/写）或外设时，存储器或外设不能及时地配合 CPU 传送数据，T3 之后插入一个或多个等待等待周期 Tw。\n\t当存储器或外设准备好数据，通过“READY”发“准备好”信号，CPU 接收到这个信号后，会自动完成Tw 状态进人 T4 状态，因此插入多少个 Tw 取决于“READY"信号，即取决于主存或外设的速度。\n\n\n1\n2\n3\n\n\n一般接口电路中具有哪些电路器件？\n\n答：（1）输入/输出数据锁存器和缓冲器，用于解决 CPU 与外设之间速度不匹配的矛盾，以及起隔离和缓冲的作用。\n\t（2）控制命令和状态寄存器，以存放 CPU 对外设的控制命令以及外设的状态信息。\n\t（3）地址译码器，用于选择接口电路中的不同端口（寄存器）。\n\t（4）读写控制逻辑。\n\t（5）中断控制逻辑。\n\n\n1\n2\n3\n4\n5\n\n\n论指令周期、总线周期和时钟周期的关系。\n\n答：（1）执行一条指令所需要的时间称为指令周期；\n\t（2）CPU 同外部设备或内存储器之间进行信息交换过程所需要的时间称为总线周期，即启用一次总线进行读或写的时间；\n\t（3）时钟脉冲的重复周期称为时钟周期，它是 CPU 主频的倒数；\n\t（4）一个指令周期由若干个总线周期组成，一个总线周期又由若干个时钟周期组成；\n\t（5）8086CPU 的总线周期至少由 4 个时钟周期组成，当外设不能在 CPU 规定时间内准备好数据时，要在总线周期中插入等待周期。\n\n\n1\n2\n3\n4\n5\n\n\n\n# 中断\n\n什么是中断？计算机使用中断的好处？\n\n答：\n（1）中断是指当处理器执行主程序时，由于内外部事件转而去执行子程序，当子程序执行完成后返回主程序的过程。（2 分）\n(2) 中断的优点：\n\t① 解决快速 CPU 与慢速外设之间的矛盾，使 CPU 可以与外设同时工作，不交换信息时，处理器和外围设备处于各自独立的并行工作状态。提高计算机系统效率。（2 分）\n\t② 维持系统可靠正常工作。在程序运行过程中，如出现异常，向处理器发出中断请求，处理器立即采取保护措施。（2 分）\n\t③ 计算机实现对控制对象的实时处理，处理器随时响应外设请求并处理。（2 分）\n\t④ 计算机可以对故障自行处理。处理器中设有各种故障检测和错误诊断的部件，一旦发现故障或错误，立即发出中断请求，进行故障现场记录和隔离。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述中断的概念：\n\n答：当CPU执行主程序时，由于内外部事件使得CPU暂时中断当前主程序转而去执行子程序，\n\t当子程序执行完之后返回主程序的过程叫做中断。\n\n\n1\n2\n\n\n简述中断嵌套：\n\n答：中断嵌套是指中断系统正在执行一个中断服务子程序时，有另一个优先级更高的中断提出中断请求，\n这时会暂停终止当前正在执行的级别较低的中断源的服务程序，去处理级别更高的中断源，待处理完毕，\n再返回到被中断了的中断服务子程序继续执行的过程。\n\n\n1\n2\n3\n\n\n中断响应过程中为什么要保护现场，如何保护？\n\n答：因为一般主程序和中断服务程序都可能会用到累加器，PSW寄存器及其他一些寄存器。\nCPU在进入中断服务程序后，用到上述寄存器时，就会破坏它原来存在寄存器中的内容；\n一旦中断返回，将会造成主程序的混乱。因而在进入中断服务程序后，一般要先保护现场，\n然后再执行中断处理程序，在返回主程序以前再恢复现场。\n\t保护方法一般是把累加器、PSW寄存器及其他一些与主程序有关的寄存器压入堆栈。\n在保护现场和恢复现场时，为了不使现场受到破坏或者造成混乱，一般规定此时CPU不响应新的中断请求。\n这就要求在编写中断服务程序时，注意在保护现场之前要关中断，在恢复现场之后开中断。\n如果在中断处理时允许有更高级的中断打断它，则在保护现场之后再开中断，恢复现场之前关中断。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断源的识别通常有哪两种方法，并简述其特点：\n\n答：查询中断和向量中断；\n\t前者的特点时多个中断源共用一个中断入口服务程序，通过执行一段查询程序，\n确定引起中断的中断源状态，然后做相应的中断处理。\n\t后者的特点是每个中断源对应一个中断服务入口地址，由中断向量来指示中断服务程序入口地址。\n\n\n1\n2\n3\n4\n\n\n什么是中断类型码、中断向量、中断向量表？在基于8088/8086的微机操作系统中中断类型码和中断向量之间有什么关系？\n\n答：处理机可处理的每种中断的编号为中断类型码。\n\t中断向量是指中断处理程序的入口地址，由处理机自动寻址。\n\t中断向量表是存放所有类型中断处理程序入口地址的一个默认的内存区域。\n\t在 8086 系统中，中断类型码乘以 4 得到向量表的地址指针，\n\t从此处读出4 字节内容即为中断向量。\n\n\n1\n2\n3\n4\n5\n\n\n8086如何响应一个INTR中断请求？\n\n答：在 INTR 中断请求响应条件满足的情况下，\n\t(1) 8086 在连续的两个总线周期中发出INTA中断请求响应信号；\n\t(2) 在第二个 INTA信号期间，中断源经数据总线向 8086 发出一字节的中断类型码，8086 收到中断类型码后放入暂存器；\n\t(3) 8086 保护现场：标志寄存器入栈，清除 IF、TF 标志位，断点 CS、IP 值入栈；\n\t(4) 8086 将中断类型码乘以 4 后得到中断向量表的入口地址，从此地址开始的4 个单元中读出中断服务程序的入口地址（IP，CS）；\n\t(5) 8086 从此地址取指令执行，使控制转向中断处理过程。\n\n\n1\n2\n3\n4\n5\n6\n\n\n8259A的主要功能是什么？三个寄存器IRR、IMR、ISR各有什么作用？\n\n答：（1）8259 的功能：\n\t\t①可以管理 8 级中断，通过级联的方式，用 9 片 8259 管理 64 级中断。\n\t\t②判断一个中断请求输入信号 IR 是否有效，是否符合信号的电器约定，是否被屏蔽。\n\t\t③有中断优先逻辑，并可对任一中断单独屏蔽或允许。8259A 的 8 个中断请求输入端 IR0~IR7，哪一个能使 INT 输出有效要由编程选定的优先级方式来判定。\n\t\t④CPU 响应中断后，进入中断响应周期INTA ，8259A 能将获得优先级的 IRi所对应的中断类型号送上数据总线提供给 CPU。\n\t\t⑤ 可通过编程选择工作方式。\n\t（2）三个寄存器 IRR、IMR 和 ISR 的作用：\n\t\t①中断请求寄存器 IRR：保存 8 条外界中断请求信号 IR0～IR7 的请求状态。Di 位为 1 表示 IRi 引脚有中断请求；为 0 表示该引脚无请求。\n\t\t②中断屏蔽寄存器 IMR：保存对中断请求信号 IR 的屏蔽状态。Di 位为 1 表示 IRi 中断被屏蔽（禁止）；为0 表示允许该中断。\n\t\t③中断服务寄存器 ISR：保存正在被 8259A 服务着的中断状态。Di 位为 1 表示 IRi 中断正在服务中；为 0表示没有被服务。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 传送方式及奇偶地址体\n\n8086为什么要采用分体结构：\n\n答：存储体以8位（1B）作为基本存储单位；\n访问一个字节时，只用16位数据线中的8位；\n访问一个字时，16位数据线的高8位和低8位同时访问两个存储单元，提高了CPU的效率。\n\n\n1\n2\n3\n\n\n如何划分奇偶体：\n\n答：在8086系统中，将总容量为1MB的存储器分为奇地址存储体和偶地址存储体，各为512K；\n\t奇体与高8位（D15——D8）相连；\n\t偶体与低8位（D7——D0）相连；\n\t选择奇体还是偶体由信号BHE！、A0决定。\n\n\n1\n2\n3\n4\n\n\n在8086微处理器构成的系统中，什么是存储器的规则字和非规则字？8086微处理器对一个规则字和一个非规则字读写时，有什么区别？\n\n答：规则字：从偶地址开始的字；\n\t读写规则字时：只需要一个总线周期，BHE!=0、A0=0\n\t非规则字：从奇地址开始的字；\n\t读写规则字时：需要两个个总线周期；\n\t\t读奇地址内容D8-D15（BHE!=0、A0=1）、读偶地址内容D0-D7（BHE!=1、A0=0）\n\n\n1\n2\n3\n4\n5\n\n\n简述CPU与外部设备采用中断控制方式传输数据的过程。\n\n答：\n（1）当外部设备需要与CPU进行数据交换时，由接口部件8259芯片发出一个中断请求信号；\n（2）CPU响应这一中断请求，便可在中断服务程序中完成一个字节或一个字的信息交换；\n（3）数据交换完成后，返回原程序。\n（4）CPU每执行一次中断传送数据，要打断原来执行的程序去执行中断服务子程序。\n（5）执行前要保护PSW和断点，执行后再恢复它们。\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述中断传送方式和DMA传送方式相比有什么不同。\n\n答：1、中断方式通过程序实现数据传送，而DMA方式直接靠硬件来实现，信息传输速度快。\n\t2、CPU对中断的响应是在执行完一条指令之后，而对DMA的响应则可以在指令执行过程中的任何总线周期之后，请求响应快。\n\t3、中断方式必须切换程序，要进行CPU现场的保护中恢复操作。DMA仅挪用了一个存储周期，不改变CPU现场，额外花销小。\n\t4、DMA请求的优先权比中断请求高。CPU优先响应DMA请求。\n\t5、中断方式不仅具有I/O数据传送能力，而且还能处理异常事件，DMA只能进行I/O数据传送。\n总而言之，在进行I/O控制时，DMA控制方式比程序中断控制方式速度快，但程序中断控制方式的应用范国比DMA控制方式广。\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么叫端口？通常有哪几类端口？计算机对I/O端口编址时采用哪两种方法？在8086/8088系统中，用哪种方法对I/O端口进行编址？\n\n答：\n（1）CPU 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。（2 分）\n（2）端口通常有 3 类：数据端口、状态端口、控制端口。（3 分）\n（3）计算机对端口编址的两种方法为：计算机对内存和 I/O 端口统一编址；计算机对内存和I/O端口独立编址。（4 分）\n（4）在 8086/8088 系统中用内存和 I/O 端口各自独立编址。（1 分）\n\n\n1\n2\n3\n4\n5\n\n\n比较串行通信与并行通信的优缺点。\n\n答：（1）从传送距离上看：并行通信适宜于近距离的数据传送，通常小于 30 米；而串行通信适宜于远距离的数据传送可以从几米到数千公里；\n\t（2）从传送速度上看：并行通信传送数据的速度比串行通信快得多；\n\t（3）从传送设备和费用上：在远距离传送中通信线路的费用占很大的比重，因而串行通信的费用由于传送线少，比并行通信的费用低得多。\n\n\n1\n2\n3\n\n\n\n# 指令周期、总线周期、时钟周期\n\nCPU响应中断时，为什么要执行两个连续的中断响应周期？\n\n答：CPU 响应中断时，执行两个连续的中断响应周期，每个响应周期都给出中断响应信号INTA。\n\t这是因为第一个总线周期通知中断请求设备，微处理器准备响应中断，中断控制器 8259A 应该准备好中断类型码，8259A 的 ISR 和 IRR 对应位分别置 1 清 0；\n\t第二个总线周期中，8259A 把中断类型号送上数据总线，微处理器接收中断类型码，以便得到中断向量，即得到中断服务程序的入口地址。\n\n\n1\n2\n3\n\n\n“8086执行了一个总线周期”是指8086做了哪些可能的操作？基本总线周期如何组成？在一个典型的都存储周期中，地址信号、ALE信号 ， RD 信号、数据信号分别在何时产生？\n\n答：（1）“8086执行了一个总线周期”是指：\n\t\t1、8086可能从片外的存储器取指令；\n\t\t2、8086可能对片外的存储器或I/O接口进行了一次读/写数据的操作。\n\t（2）基本总线周期由T1至T4四个时钟周期组成。\n\t（3）在一个典型的读存储器总线周期中，地址信号在 T1 周期内产生，ALE 信号在T1 周期内产生，\n\t\tRD信号在 T2 周期内产生，数据信号一般在 T3 周期内产生，若存储器在 T3 内来不及提供数据，\n\t\t8086 会在总线周期中的 T3 后插入等待状态 Tw，存储器将在某 Tw 中给出数据。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在8086中，逻辑地址、偏移地址、物理地址分别指的是什么？具体说明。\n\n答：逻辑地址是在程序中对存储器地址的一种表示方法，由段地址和段内偏移地址两部分组成，\n\t如 1234H：0088H。\n\t偏移地址是指段内某个存储单元相对该段首地址的差值，是一个 16 位的二进制代码。物理地址是 8086 芯片引线送出的 20 位地址码，用来指出一个特定的存储单元。\n\n\n1\n2\n3\n\n\n简述流水线技术，8086怎样实现了最简单的流水线？\n\n答：流水线是指在程序执行时多条指令重叠进行操作的一种并行处理实现技术。流水线的并行处理是指完成一条指令的各个部件在时间上是可以同时重叠工作，分别同时为多条指令的不同部分进行工作，以提高各部件的利用率来提高指令的平均执行速度。流水线技术是把一个重复的过程分解为若干子过程，每个子过程由专门的功能部件来\n实现，将多个处理过程在时间上错开，依次通过个功能段，这样，每个子过程就可以与其他子过程并行进行。\n\t8086 中，指令的读取是在 BIU 单元，而指令的执行是在 EU 单元。因为 BIU 和 EU 两个单元相互独立、分别完成各自操作，所以可以并行操作。也就是说，在 EU 单元对一个指令进行译码执行时，BIU 单元可以同时对后续指令进行读取；这就是最简单的指令流水线技术。\n\n\n1\n2\n3\n\n\n比较8255A三种工作方式的应用场合有何区别？\n\n答：方式 0 适用于同步传送和查询传送方式，\n\t方式 1 适用于外设在能提供选通信号或数据接收信号的场合，且采用中断传送方式比较方便；\n\t方式 2 适用于一个并行外设既可以作为输入设备，又可以作为输出设备，并且输入和输出不会同时进行的场合。\n\n\n1\n2\n3\n',normalizedContent:'# 微机原理简答题（分类）\n\n\n# 计算机的部件及编程语言\n\n计算机硬件组成的五个部件是什么：？\n\n答：输入设备、输出设备、运算器、存储器、控制器\n\n\n1\n\n\n计算器系统由什么组成？\n\n答：硬件系统和软件系统两部分组成。\n\n\n1\n\n\n简述risc（精简指令集）的特点：\n\n答：1、cpu处理指令是由硬件完成、运行速度快；\n    2、指令长度固定、指令格式种类少、寻址方式种类少；\n    3、只有取数/存数指令访问存储器，其余指令的操作都在寄存器内完成；\n    4、采用流水线技术，大部分指令在一个时钟周期内完成；\n    5、控制器采用组合逻辑控制，不用微程序控制。\n    6、采用优化的编译程序。\n\n\n1\n2\n3\n4\n5\n6\n\n\n寄存器按功能可分为几大类，分别说明包含什么寄存器？\n\n答：可分为3大类8个通用寄存器、4个段寄存器、2个控制寄存器；\n    分别是：通用寄存器又分为4个数据寄存器、2个地址寄存器、2个变址寄存器；\n            数据寄存器：ax（累加器）、bx（基址寄存器）、cx（计数寄存器）、dx（数据寄存器）\n            地址寄存器：bp（基址指针寄存器）、sp（堆栈指针寄存器）\n            变址寄存器：si（源变址寄存器）、di（目标变址寄存器）\n            段寄存器：cs（代码段寄存器）、ds（数据段寄存器）、es（附加段寄存器）、ss（堆栈段寄存器）\n            控制寄存器：ip（指令寄存器）、flags（状态标志寄存器）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述8086和8088的区别：\n\n答：1.8086：是完全16位机，外部总线和内部总线是16根；\n      8088：内部总线是16根，外部总线是8根；\n    2.8086：有6字节的指令队列；\n      8088：有4字节的指令队列；\n    3.8086：使用m/io非（io非，低电平）引脚；\n      8088：使用io/m非（m非，低电平）引脚；\n\n\n1\n2\n3\n4\n5\n6\n\n\n88/86两个单元的功能：\n\n答：1、biu：负责cup对主存和外设接口进行访问\n\t\t①取指令：从内存取指令，送指令队列\n\t\t④取操作数：从内存或接口取操作数\n\t\t⑦送结果：从biu送内存或接口外设\n\t2、eu：负责指令译码、执行和数据的运算\n\t\t②取指令：从指令队列取指令送控制器\n\t\t③分析译码：识别指令功能\n\t\t⑤执行指令：在alu中运算加工\n\t\t⑥送结果：由eu送biu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n写出cpu中主要寄存器：\n\n答：ax、bx、cx、dx、si、di、bp、sp、ip、cs、ds、es、ss、fr\n\n\n1\n\n\n8086cpu中有哪些寄存器？分别有什么用途。哪些寄存器用来指示存储器单元的偏移地址。\n\n答：8086 cpu 中有 8 个通用寄存器 ax、bx、cx、dx、sp、bp、si、di；\n\t两个控制寄存器 ip、fr；\n\t四个段寄存器 cs、ds、ss、es。\n\t8 个通用寄存器都可以用来暂存参加运算的数据或中间结果，但又有各自的专门用途。\n\t例如：ax 专用做累加器，某些指令指定用它存放操作数和运算结果；cx 为计数寄存器，在某些指令中做计数器使用；dx 为数据寄存器；bx 为基址寄存器，bp 为基址指针，si 为源变址寄存器，di 为目的变址寄存器，这 4 个寄存器在数据寻址中用来存放段内偏移地址（有效地址）或段内偏移地址的一部分；sp 为堆栈指示器，用来存放栈顶有效地址。\n\t两个控制寄存器用来存放有关的状态信息和控制信息。\n\t例如：标志寄存器 fr 用来存放状态标志和控制标志；而指令指针用来存放下一条要取指令的有效地址。\n\t四个段寄存器用来存放段地址。\n\t例如：cs 寄存器用来存放代码段的段地址；ds 寄存器用来存放数据段的段地址；ss 寄存器用来存放堆栈段的段地址；es 寄存器用来存放扩展段的段地址。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n什么是地址锁存器？8088/8086为什么要用地址锁存器？锁存的是什么信息？举例说明。\n\n答：（1）地址锁存器是一个暂存器，它根据控制信号的状态将总线上的地址代码暂存起来。\n\t（2）8088/8086 的数据和地址总线采用分时复用操作方式，即用同一总线既传送地址又传送数据。\n\t\t当微处理器与存储器交换信号时，首先由 cpu 发送存储器的地址，同时发允许锁存信号ale给锁存器，\n\t\t当锁存器接到该信号后将地址/数据总线上的地址锁存在锁存器中，随后才能传送数据信息。\n\t（3）8088/8086 系统的地址锁存器采用 74ls373/273 或者 8282/8283，每片能够锁8 位地址。\n\n\n1\n2\n3\n4\n5\n\n\n8086cpu从接口上分为几部分？各部分由什么组成？各部分功能是什么？\n\n答：（1）8086cpu 从功能上分为两大部分：一是执行部件(eu)，二是总线接口部件(biu)。\n\t（2）执行部件(eu)是由以下 4 部分组成：\n\t\t①4 个通用寄存器：ax、bx、cx、dx。\n\t\t②4 个专用寄存器：基址指针寄存器 bp，堆栈指针寄存器 sp，源变址寄存器si，目的变址寄存器di。\n\t\t③标志寄存器 fr。\n\t\t④算术逻辑部件 alu。\n\t\t功能：负责执行所有的指令，向总线接口部件(biu)提供指令执行的结果数据和地址，并对通用寄存器和标志寄存器进行管理。\n\t（3）总线接口部件(biu)由以下部件组成:\n\t\t①4 个段寄存器：代码段寄存器 cs，数据段寄存器 ds，附加段寄存器 es，堆栈段寄存器ss。②指令指针寄存器。\n\t\t③地址加法器。\n\t\t④指令队列。\n\t\t功能：执行外部总线周期，负责 cpu 与主存储器和外设之间的信息交换。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n站在80x86，汇编语言程序员的角度，说明数据存储位置有哪些？访问这些数据可采用的寻址方式分别是什么？对这些位置对数据访问速度是否相同，为什么？\n\n答：（1）数据存储位置有 cpu 内部的寄存器、内存、io 端口\n\t（2）采用的寻址方式分别是：\n\t\t①寄存器操作数采用寄存器寻址\n\t\t②存储器操作数采用直接寻址，寄存器间接寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址 \n\t\t③io 端口的访问需专门的 io 指令，有直接寻址和间接寻址。\n\t（3）速度不同，寄存器位于 cpu 内部，因此速度最快，存储器操作数速度较慢，因为需要通过系统总线访问内存，\n\t\t端口的访问最慢，属于输入/输出操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 8086/8088最小/最大工作模式\n\n简述最小工作模式：\n\n答：mn/mx非=1，为最小工作模式；\n    在系统中只有8086/8088一个微处理器，所有的总线控制信号直接由8086/8088产生；\n    因此，系统中的总线控制逻辑电路被减到最少，最小模式是单处理器系统。\n\n\n1\n2\n3\n\n\n简述最大工作模式：\n\n答：mn/mx非=0，为最大工作模式；\n    系统中有两个或两个以上的微处理器；即除了主处理器8086/8088以外，\n还有协处理器（8087算数协处理器或8089输入输出协处理器），最大模式可构成多处理器系统，\n系统中所有的控制信号由总线控制器（8288）提供。\n\n\n1\n2\n3\n4\n\n\n最小工作模式与最大工作模式的区别：\n\n答：最大模式是相对最小模式而言的；\n    最大模式用在中等规模的或者大型8086/8088系统中；\n    在最大模式系统中，总是包含两个或多个微处理器其中一个主处理器就是8086/8088，\n其他的称为协处理器，它们是协助处理器工作的；\n    cpu工作模式的选择是由硬件决定的。\n\n\n1\n2\n3\n4\n5\n\n\n在8086/8088系统中，什么是最大模式？什么是最小模式？用什么方法将8086/8088置为最大模式或最小模式？\n\n答：（1）最小模式：在系统中只有 8086/8088 一个微处理器，所有的总线控制信号都直接由 8086/8088产生，因此，系统中总线控制电路被减到最少。\n\t（2）最大模式：在系统中包含两个或多个微处理器，其中一个主处理器就是 8088/8086，其它处理器为协处理器，用于协助主处理器工作。它用在中等规模或大型的 8088/8086 系统中。一般情况下和 8088/8086配合的协处理器有两个：一个是数值运算协处理器 8087，一个是输入/输出协处理器 8089。\n\t（3）将 8088/8086 cpu 的第 33 脚接地，系统处于最大模式，当第 33 脚接+5v 时，系统为最小模式。\n\n\n1\n2\n3\n\n\n\n# 内存、存储器\n\n简述触发器、寄存器与存储器之间的关系：\n\n答：触发器是计算机记忆装置的基本单元，一个触发器能存储一位二进制数也为一个一位寄存器；\n\t多个出触发器就可以构成一个多位寄存器，而一个寄存器为为一个存储单元；\n\t多个寄存器组成一个存储器。\n\n\n1\n2\n3\n\n\nrom、prom、eprom和eeprom在使用上各有什么特点？\n\n答：rom：掩膜rom，信息制作在芯片中，不可更改\n\tprom：允许一次编程，此后不可更改\n\teprom：紫外线照射擦除，可多次擦除和编程，未编程前所有单元格信息都为1，写入后的部分为0\n\teeprom：加电在线擦除和编写，可多次擦写\n\n\n1\n2\n3\n4\n\n\n寄存器、cache、内存和外存的区别：\n\n答：寄存器：是cup内部暂存数据单元，如：ax、bx等；\ncache：位于cpu和内存之间，可直接与cpu进行数据交换，解决内存速度不足的问题；\n内存：也叫主存，可直接与cpu进行数据交换；\n外存：主要用来长久保存数据，如：硬盘、光盘、u盘等。外存的数据只能通过主存间接地与cpu交换数据。\n\n\n1\n2\n3\n4\n\n\n简述缓冲器、锁存器和触发器的作用。\n\n答：\n（1）缓冲器：又称缓冲寄存器。\n\t①完成速度的匹配，在高速工作的 cpu 与慢速工作的外设间起协调和缓冲作用，实现数据传送的同步。（1 分）\n\t②提供一个暂存的空间。它分输入缓冲器和输出缓冲器两种。输入缓冲器是将外设送来的数据暂时存放，以便处理器将它取走；输出缓冲器是用来暂时存放处理器送往外设的数据。（1 分）\n\t③提高驱动能力。（1 分）\n\t④信号隔离的作用，消除负载对信号源的影响。（1 分）\n（2）锁存器（latch）：利用电平控制数据的传输。（1 分）\n\t①缓存。（1 分）\n\t②完成高速的控制器与慢速的外设的不同步问题。（1 分）\n\t③解决驱动的问题。（1 分）\n（3）触发器：是最小的记忆单元,能记忆二进制数的一个数位，是寄存器、存储器基本元件。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简述半导体存储器的主要技术指标。\n\n答：（1）存储容量。存储器可以存储的二进制信息总量称为存储容量。存储容量有两种表示方法：\n\t\t①位表示方法。以存储器中的存储地址总数与存储字位的乘积表示。如 1k×4 位，表示该芯片有 1k 个单元（1k＝1024），每个存储单元的长度为 4 个二进制位。\n\t\t②字节表示方法。以存储器中的单元总数表示（一个存储单元由 8 个二进制位组成，称为一个字节，用 b 表示）。如 128b，表示该芯片有 128 个单元。\n\t（2）存取速度。存储器的存储速度可以用两个时间参数表示，一个是存取时间：从启动一次存储器操作到完成该操作所经历的时间；另一个是存储周期：启动两次独立的存储器操作之间所需的最小时间间隔。\n\t（3）可靠性。存储器的可靠性用平均故障间隔时间 mtbf 来衡量。mtbf 越长，可靠性越高。\n\t（4）存储带宽。单位时间传输的信息量。\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 总线、接口（总线周期）\n\n什么是总线，简述各类总线的应用场合？\n\n答：（1）总线（bus）是计算机各种功能部件之间传送信息的公共通信线，\n\t\t它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，\n\t\t外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。\n\t（2）按总线功能或信号类型来分，有数据总线、地址总线和控制总线。 按总线的层次结构分来为，有：\n\t\t① cpu 片内总线：微机系统中速度最快的总线，主要在 cpu 内部，连接 cpu 内部部件，提供系统原始的控制和命令。\n\t\t②系统总线：在系统总线和 cpu 总线之间的一级总线，提供 cpu 和主板器件之间以及cpu到高速外设之间的快速信息通道。\n\t\t③通信总线：也称为外部总线，是微机与微机、微机与外设之间进行通信的总线。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述在最小工作模式下，8086如何响应一个总线请求？\n\n答：外部总线主控模块经 hold 引线向 8086 发出总线请求信号；\n\t8086 在每个时钟周期的上升沿采样hold 引线；\n\t若发现 hold=1 则在当前总线周期结束时(t4 结束)发出总线请求的响应信号hlda；\n\t8086使地址、数据及控制总线进入高阻状态，让出总线控制权，完成响应过程。\n\n\n1\n2\n3\n4\n\n\n简述cpu与外设进行数据交换的方式，并说明每种方式的特点。\n\n答：cpu 与外设进行数据交换的方式有：无条件传送方式、查询传送方式、中断控制方式、直接存储器存取控制方式（dma）和通道方式。\n\t（1）程序控制方式: 特点是依靠程序的控制来实现主机和外设的数据传送，可分为无条件传送方式、查询方式和中断方式。\n\t\t三种方式都是以 cpu 为中心的控制方式，都需要 cpu 执行程序来进行i/o数据传送。\n\t\t①无条件传送方式：程序简单，所需的硬件和软件都比较少、传送速度快，但必须在确信外设已准备好的情况下才能使用。\n\t\t②查询传送方式：cpu 通过程序不断查询相应设备的状态，状态不符合要求，则cpu 需要等待；只有当状态信号符合要求时，\n\t\t\tcpu 才能进行相应的操作。硬件线路简单，程序易于实现；缺点是cpu利用率低下，实时性差。\n\t\t③中断控制方式: 外设在准备就绪的条件下通过请求引脚信号，主动向处理器提出交换数据的请求。cpu与外设、外设与外设之间能并行工作。\n\t\t\t一般适合于传送数据量少的中低速外部设备，尤其适合实时控制中的紧急事件处理，对于高速外部设备的大批量数据传送不适合。\n\t（2）直接存储器存取控制方式（dma）：cpu 不参加数据传送，而是由 dma 控制器来实现内存与外设，外设与外设之间的直接传递。\n\t\t此种方式适用于需要大量数据高速传送的场合。cpu 与外设可以并行工作，提高了 cpu 的效率。\n\t（3）通道方式：可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简述总线的定义：\n\n答：在计算机系统中，各个部件之间传送信息的公共通道叫做总线（bus），\n\t按照所传输的信息种类可划分为数据总线、地址总线、控制总线。\n\n\n1\n2\n\n\n简述ide、scsi、sata接口总线：\n\n答：是硬盘和光驱接口标准。\n\tide：intergrated drive electronics；【电子集成驱动器】16/32位\n\tscsi：small computer system interface；【小型计算机系统接口】32位\n\tsata：串行ata（serial ata），sata3.0接口。【目前硬盘和光驱的主要接口】\n\n\n1\n2\n3\n4\n\n\n简述ieee394总线、agp总线、pci总线功能：\n\n答：ieee394总线：是高性能串行总线标准；视频采集、数码影像设备的传输标准。\n\tagp总线：图形加速口：提高视频带宽。\n\tpci总线：（peripheral component interconnect）外设部件互联标准；\n\t\t可以通过桥连接多条pci总线；pci总线上的设备可以与cpu并行工作。\n\n\n1\n2\n3\n4\n\n\n总线的性能指标：\n\n答：1、总线贷款：数据传输率，单位：bps\n\t2、总线位宽：同时传输的二进制位数；\n\t一次所能并行传送信息的位数，亦称为数据路宽度。\n\t3、总线工作频率：mhz\n\n\n1\n2\n3\n4\n\n\n什么叫总线周期？8086cpu的一个总线周期包括多少时钟周期，什么情况下要插入tw等待周期？插入多少个tw取决于什么因素？\n\n答：8086/8088cpu 把 biu 完成一次访问主存储器或外设操作所需的时间称为一个总线周期。一个总线周期最少包含 4 个时钟周期（t1~t4）。\n\t当访问存储器（读/写）或外设时，存储器或外设不能及时地配合 cpu 传送数据，t3 之后插入一个或多个等待等待周期 tw。\n\t当存储器或外设准备好数据，通过“ready”发“准备好”信号，cpu 接收到这个信号后，会自动完成tw 状态进人 t4 状态，因此插入多少个 tw 取决于“ready"信号，即取决于主存或外设的速度。\n\n\n1\n2\n3\n\n\n一般接口电路中具有哪些电路器件？\n\n答：（1）输入/输出数据锁存器和缓冲器，用于解决 cpu 与外设之间速度不匹配的矛盾，以及起隔离和缓冲的作用。\n\t（2）控制命令和状态寄存器，以存放 cpu 对外设的控制命令以及外设的状态信息。\n\t（3）地址译码器，用于选择接口电路中的不同端口（寄存器）。\n\t（4）读写控制逻辑。\n\t（5）中断控制逻辑。\n\n\n1\n2\n3\n4\n5\n\n\n论指令周期、总线周期和时钟周期的关系。\n\n答：（1）执行一条指令所需要的时间称为指令周期；\n\t（2）cpu 同外部设备或内存储器之间进行信息交换过程所需要的时间称为总线周期，即启用一次总线进行读或写的时间；\n\t（3）时钟脉冲的重复周期称为时钟周期，它是 cpu 主频的倒数；\n\t（4）一个指令周期由若干个总线周期组成，一个总线周期又由若干个时钟周期组成；\n\t（5）8086cpu 的总线周期至少由 4 个时钟周期组成，当外设不能在 cpu 规定时间内准备好数据时，要在总线周期中插入等待周期。\n\n\n1\n2\n3\n4\n5\n\n\n\n# 中断\n\n什么是中断？计算机使用中断的好处？\n\n答：\n（1）中断是指当处理器执行主程序时，由于内外部事件转而去执行子程序，当子程序执行完成后返回主程序的过程。（2 分）\n(2) 中断的优点：\n\t① 解决快速 cpu 与慢速外设之间的矛盾，使 cpu 可以与外设同时工作，不交换信息时，处理器和外围设备处于各自独立的并行工作状态。提高计算机系统效率。（2 分）\n\t② 维持系统可靠正常工作。在程序运行过程中，如出现异常，向处理器发出中断请求，处理器立即采取保护措施。（2 分）\n\t③ 计算机实现对控制对象的实时处理，处理器随时响应外设请求并处理。（2 分）\n\t④ 计算机可以对故障自行处理。处理器中设有各种故障检测和错误诊断的部件，一旦发现故障或错误，立即发出中断请求，进行故障现场记录和隔离。（2 分）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简述中断的概念：\n\n答：当cpu执行主程序时，由于内外部事件使得cpu暂时中断当前主程序转而去执行子程序，\n\t当子程序执行完之后返回主程序的过程叫做中断。\n\n\n1\n2\n\n\n简述中断嵌套：\n\n答：中断嵌套是指中断系统正在执行一个中断服务子程序时，有另一个优先级更高的中断提出中断请求，\n这时会暂停终止当前正在执行的级别较低的中断源的服务程序，去处理级别更高的中断源，待处理完毕，\n再返回到被中断了的中断服务子程序继续执行的过程。\n\n\n1\n2\n3\n\n\n中断响应过程中为什么要保护现场，如何保护？\n\n答：因为一般主程序和中断服务程序都可能会用到累加器，psw寄存器及其他一些寄存器。\ncpu在进入中断服务程序后，用到上述寄存器时，就会破坏它原来存在寄存器中的内容；\n一旦中断返回，将会造成主程序的混乱。因而在进入中断服务程序后，一般要先保护现场，\n然后再执行中断处理程序，在返回主程序以前再恢复现场。\n\t保护方法一般是把累加器、psw寄存器及其他一些与主程序有关的寄存器压入堆栈。\n在保护现场和恢复现场时，为了不使现场受到破坏或者造成混乱，一般规定此时cpu不响应新的中断请求。\n这就要求在编写中断服务程序时，注意在保护现场之前要关中断，在恢复现场之后开中断。\n如果在中断处理时允许有更高级的中断打断它，则在保护现场之后再开中断，恢复现场之前关中断。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断源的识别通常有哪两种方法，并简述其特点：\n\n答：查询中断和向量中断；\n\t前者的特点时多个中断源共用一个中断入口服务程序，通过执行一段查询程序，\n确定引起中断的中断源状态，然后做相应的中断处理。\n\t后者的特点是每个中断源对应一个中断服务入口地址，由中断向量来指示中断服务程序入口地址。\n\n\n1\n2\n3\n4\n\n\n什么是中断类型码、中断向量、中断向量表？在基于8088/8086的微机操作系统中中断类型码和中断向量之间有什么关系？\n\n答：处理机可处理的每种中断的编号为中断类型码。\n\t中断向量是指中断处理程序的入口地址，由处理机自动寻址。\n\t中断向量表是存放所有类型中断处理程序入口地址的一个默认的内存区域。\n\t在 8086 系统中，中断类型码乘以 4 得到向量表的地址指针，\n\t从此处读出4 字节内容即为中断向量。\n\n\n1\n2\n3\n4\n5\n\n\n8086如何响应一个intr中断请求？\n\n答：在 intr 中断请求响应条件满足的情况下，\n\t(1) 8086 在连续的两个总线周期中发出inta中断请求响应信号；\n\t(2) 在第二个 inta信号期间，中断源经数据总线向 8086 发出一字节的中断类型码，8086 收到中断类型码后放入暂存器；\n\t(3) 8086 保护现场：标志寄存器入栈，清除 if、tf 标志位，断点 cs、ip 值入栈；\n\t(4) 8086 将中断类型码乘以 4 后得到中断向量表的入口地址，从此地址开始的4 个单元中读出中断服务程序的入口地址（ip，cs）；\n\t(5) 8086 从此地址取指令执行，使控制转向中断处理过程。\n\n\n1\n2\n3\n4\n5\n6\n\n\n8259a的主要功能是什么？三个寄存器irr、imr、isr各有什么作用？\n\n答：（1）8259 的功能：\n\t\t①可以管理 8 级中断，通过级联的方式，用 9 片 8259 管理 64 级中断。\n\t\t②判断一个中断请求输入信号 ir 是否有效，是否符合信号的电器约定，是否被屏蔽。\n\t\t③有中断优先逻辑，并可对任一中断单独屏蔽或允许。8259a 的 8 个中断请求输入端 ir0~ir7，哪一个能使 int 输出有效要由编程选定的优先级方式来判定。\n\t\t④cpu 响应中断后，进入中断响应周期inta ，8259a 能将获得优先级的 iri所对应的中断类型号送上数据总线提供给 cpu。\n\t\t⑤ 可通过编程选择工作方式。\n\t（2）三个寄存器 irr、imr 和 isr 的作用：\n\t\t①中断请求寄存器 irr：保存 8 条外界中断请求信号 ir0～ir7 的请求状态。di 位为 1 表示 iri 引脚有中断请求；为 0 表示该引脚无请求。\n\t\t②中断屏蔽寄存器 imr：保存对中断请求信号 ir 的屏蔽状态。di 位为 1 表示 iri 中断被屏蔽（禁止）；为0 表示允许该中断。\n\t\t③中断服务寄存器 isr：保存正在被 8259a 服务着的中断状态。di 位为 1 表示 iri 中断正在服务中；为 0表示没有被服务。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 传送方式及奇偶地址体\n\n8086为什么要采用分体结构：\n\n答：存储体以8位（1b）作为基本存储单位；\n访问一个字节时，只用16位数据线中的8位；\n访问一个字时，16位数据线的高8位和低8位同时访问两个存储单元，提高了cpu的效率。\n\n\n1\n2\n3\n\n\n如何划分奇偶体：\n\n答：在8086系统中，将总容量为1mb的存储器分为奇地址存储体和偶地址存储体，各为512k；\n\t奇体与高8位（d15——d8）相连；\n\t偶体与低8位（d7——d0）相连；\n\t选择奇体还是偶体由信号bhe！、a0决定。\n\n\n1\n2\n3\n4\n\n\n在8086微处理器构成的系统中，什么是存储器的规则字和非规则字？8086微处理器对一个规则字和一个非规则字读写时，有什么区别？\n\n答：规则字：从偶地址开始的字；\n\t读写规则字时：只需要一个总线周期，bhe!=0、a0=0\n\t非规则字：从奇地址开始的字；\n\t读写规则字时：需要两个个总线周期；\n\t\t读奇地址内容d8-d15（bhe!=0、a0=1）、读偶地址内容d0-d7（bhe!=1、a0=0）\n\n\n1\n2\n3\n4\n5\n\n\n简述cpu与外部设备采用中断控制方式传输数据的过程。\n\n答：\n（1）当外部设备需要与cpu进行数据交换时，由接口部件8259芯片发出一个中断请求信号；\n（2）cpu响应这一中断请求，便可在中断服务程序中完成一个字节或一个字的信息交换；\n（3）数据交换完成后，返回原程序。\n（4）cpu每执行一次中断传送数据，要打断原来执行的程序去执行中断服务子程序。\n（5）执行前要保护psw和断点，执行后再恢复它们。\n\n\n1\n2\n3\n4\n5\n6\n\n\n简述中断传送方式和dma传送方式相比有什么不同。\n\n答：1、中断方式通过程序实现数据传送，而dma方式直接靠硬件来实现，信息传输速度快。\n\t2、cpu对中断的响应是在执行完一条指令之后，而对dma的响应则可以在指令执行过程中的任何总线周期之后，请求响应快。\n\t3、中断方式必须切换程序，要进行cpu现场的保护中恢复操作。dma仅挪用了一个存储周期，不改变cpu现场，额外花销小。\n\t4、dma请求的优先权比中断请求高。cpu优先响应dma请求。\n\t5、中断方式不仅具有i/o数据传送能力，而且还能处理异常事件，dma只能进行i/o数据传送。\n总而言之，在进行i/o控制时，dma控制方式比程序中断控制方式速度快，但程序中断控制方式的应用范国比dma控制方式广。\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n什么叫端口？通常有哪几类端口？计算机对i/o端口编址时采用哪两种方法？在8086/8088系统中，用哪种方法对i/o端口进行编址？\n\n答：\n（1）cpu 和外设进行数据传输时，各类信息在接口中进入不同的寄存器，一般称这些寄存器为端口。（2 分）\n（2）端口通常有 3 类：数据端口、状态端口、控制端口。（3 分）\n（3）计算机对端口编址的两种方法为：计算机对内存和 i/o 端口统一编址；计算机对内存和i/o端口独立编址。（4 分）\n（4）在 8086/8088 系统中用内存和 i/o 端口各自独立编址。（1 分）\n\n\n1\n2\n3\n4\n5\n\n\n比较串行通信与并行通信的优缺点。\n\n答：（1）从传送距离上看：并行通信适宜于近距离的数据传送，通常小于 30 米；而串行通信适宜于远距离的数据传送可以从几米到数千公里；\n\t（2）从传送速度上看：并行通信传送数据的速度比串行通信快得多；\n\t（3）从传送设备和费用上：在远距离传送中通信线路的费用占很大的比重，因而串行通信的费用由于传送线少，比并行通信的费用低得多。\n\n\n1\n2\n3\n\n\n\n# 指令周期、总线周期、时钟周期\n\ncpu响应中断时，为什么要执行两个连续的中断响应周期？\n\n答：cpu 响应中断时，执行两个连续的中断响应周期，每个响应周期都给出中断响应信号inta。\n\t这是因为第一个总线周期通知中断请求设备，微处理器准备响应中断，中断控制器 8259a 应该准备好中断类型码，8259a 的 isr 和 irr 对应位分别置 1 清 0；\n\t第二个总线周期中，8259a 把中断类型号送上数据总线，微处理器接收中断类型码，以便得到中断向量，即得到中断服务程序的入口地址。\n\n\n1\n2\n3\n\n\n“8086执行了一个总线周期”是指8086做了哪些可能的操作？基本总线周期如何组成？在一个典型的都存储周期中，地址信号、ale信号 ， rd 信号、数据信号分别在何时产生？\n\n答：（1）“8086执行了一个总线周期”是指：\n\t\t1、8086可能从片外的存储器取指令；\n\t\t2、8086可能对片外的存储器或i/o接口进行了一次读/写数据的操作。\n\t（2）基本总线周期由t1至t4四个时钟周期组成。\n\t（3）在一个典型的读存储器总线周期中，地址信号在 t1 周期内产生，ale 信号在t1 周期内产生，\n\t\trd信号在 t2 周期内产生，数据信号一般在 t3 周期内产生，若存储器在 t3 内来不及提供数据，\n\t\t8086 会在总线周期中的 t3 后插入等待状态 tw，存储器将在某 tw 中给出数据。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在8086中，逻辑地址、偏移地址、物理地址分别指的是什么？具体说明。\n\n答：逻辑地址是在程序中对存储器地址的一种表示方法，由段地址和段内偏移地址两部分组成，\n\t如 1234h：0088h。\n\t偏移地址是指段内某个存储单元相对该段首地址的差值，是一个 16 位的二进制代码。物理地址是 8086 芯片引线送出的 20 位地址码，用来指出一个特定的存储单元。\n\n\n1\n2\n3\n\n\n简述流水线技术，8086怎样实现了最简单的流水线？\n\n答：流水线是指在程序执行时多条指令重叠进行操作的一种并行处理实现技术。流水线的并行处理是指完成一条指令的各个部件在时间上是可以同时重叠工作，分别同时为多条指令的不同部分进行工作，以提高各部件的利用率来提高指令的平均执行速度。流水线技术是把一个重复的过程分解为若干子过程，每个子过程由专门的功能部件来\n实现，将多个处理过程在时间上错开，依次通过个功能段，这样，每个子过程就可以与其他子过程并行进行。\n\t8086 中，指令的读取是在 biu 单元，而指令的执行是在 eu 单元。因为 biu 和 eu 两个单元相互独立、分别完成各自操作，所以可以并行操作。也就是说，在 eu 单元对一个指令进行译码执行时，biu 单元可以同时对后续指令进行读取；这就是最简单的指令流水线技术。\n\n\n1\n2\n3\n\n\n比较8255a三种工作方式的应用场合有何区别？\n\n答：方式 0 适用于同步传送和查询传送方式，\n\t方式 1 适用于外设在能提供选通信号或数据接收信号的场合，且采用中断传送方式比较方便；\n\t方式 2 适用于一个并行外设既可以作为输入设备，又可以作为输出设备，并且输入和输出不会同时进行的场合。\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/06/26, 10:06:00",lastUpdatedTimestamp:165621188e4},{title:"关于 - 我",frontmatter:{title:"关于 - 我",date:"2021-05-16T22:53:19.000Z",permalink:"/pages/038c37/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E%20-%20%E6%88%91/01.%E5%85%B3%E4%BA%8E%20-%20%E6%88%91.html",relativePath:"10.关于/01.关于 - 我/01.关于 - 我.md",key:"v-4bb22690",path:"/pages/038c37/",headers:[{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:3},{level:2,title:"网站初衷",slug:"网站初衷",normalizedTitle:"网站初衷",charIndex:10},{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:18}],headersStr:"关于我 网站初衷 学习资料",content:" * 关于我\n * 网站初衷\n * 学习资料\n\n\n# 关于我\n\n一个在校的垃圾大二学生\n\n和我同学 李祖泽 一起写此网站笔记\n\n\n# 网站初衷\n\n * 构建自己的知识体系\n\n * 监督自己的学习\n\n * 帮助其他初学者\n   \n   笔记内容不深，希望能帮到一些初学者\n\n推荐阅读：如何构建自己的笔记系统？\n\n\n# 学习资料\n\n本人学习 java 也没多长时间，还没硬实力写出完好的自己的知识体系。\n\n大部分java笔记借助于狂神和尚硅谷课堂笔记，在文章结尾或开头有视频教程链接地址传送\n\n笔记加了点自己的理解，和其他站点的讲解。\n\n内容难免会有问题，如有任何问题，请各位大佬斧正！\n\n在本项目地址创建 “issues”",normalizedContent:" * 关于我\n * 网站初衷\n * 学习资料\n\n\n# 关于我\n\n一个在校的垃圾大二学生\n\n和我同学 李祖泽 一起写此网站笔记\n\n\n# 网站初衷\n\n * 构建自己的知识体系\n\n * 监督自己的学习\n\n * 帮助其他初学者\n   \n   笔记内容不深，希望能帮到一些初学者\n\n推荐阅读：如何构建自己的笔记系统？\n\n\n# 学习资料\n\n本人学习 java 也没多长时间，还没硬实力写出完好的自己的知识体系。\n\n大部分java笔记借助于狂神和尚硅谷课堂笔记，在文章结尾或开头有视频教程链接地址传送\n\n笔记加了点自己的理解，和其他站点的讲解。\n\n内容难免会有问题，如有任何问题，请各位大佬斧正！\n\n在本项目地址创建 “issues”",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"微机原理指令集",frontmatter:{title:"微机原理指令集",date:"2022-04-11T02:30:00.000Z",permalink:"/c1/4",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/03.%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E6%8C%87%E4%BB%A4%E9%9B%86.html",relativePath:"02.练习题/03.微机原理指令集.md",key:"v-557938bc",path:"/c1/4/",headers:[{level:2,title:"立即数（imm）寻址方式：",slug:"立即数-imm-寻址方式",normalizedTitle:"立即数（imm）寻址方式：",charIndex:13},{level:2,title:"寄存器寻址：",slug:"寄存器寻址",normalizedTitle:"寄存器寻址：",charIndex:95},{level:2,title:"存储器寻址：",slug:"存储器寻址",normalizedTitle:"存储器寻址：",charIndex:278},{level:2,title:"堆栈操作指令",slug:"堆栈操作指令",normalizedTitle:"堆栈操作指令",charIndex:1449},{level:2,title:"标志操作指令",slug:"标志操作指令",normalizedTitle:"标志操作指令",charIndex:1718},{level:2,title:"加减乘除",slug:"加减乘除",normalizedTitle:"加减乘除",charIndex:1967},{level:2,title:"符号扩展指令",slug:"符号扩展指令",normalizedTitle:"符号扩展指令",charIndex:2400},{level:2,title:"乘法和除法指令",slug:"乘法和除法指令",normalizedTitle:"乘法和除法指令",charIndex:2499},{level:3,title:"乘法指令",slug:"乘法指令",normalizedTitle:"乘法指令",charIndex:2511},{level:3,title:"除法指令",slug:"除法指令",normalizedTitle:"除法指令",charIndex:2502},{level:2,title:"1、逻辑运算指令",slug:"_1、逻辑运算指令",normalizedTitle:"1、逻辑运算指令",charIndex:3004},{level:2,title:"2、移位指令",slug:"_2、移位指令",normalizedTitle:"2、移位指令",charIndex:3525},{level:2,title:"3、循环移位指令",slug:"_3、循环移位指令",normalizedTitle:"3、循环移位指令",charIndex:3791},{level:2,title:"1、无条件转移指令",slug:"_1、无条件转移指令",normalizedTitle:"1、无条件转移指令",charIndex:4213},{level:2,title:"2、条件转移指令",slug:"_2、条件转移指令",normalizedTitle:"2、条件转移指令",charIndex:4248},{level:2,title:"3、循环指令",slug:"_3、循环指令",normalizedTitle:"3、循环指令",charIndex:4771},{level:2,title:"4、子程序指令",slug:"_4、子程序指令",normalizedTitle:"4、子程序指令",charIndex:4869},{level:2,title:"5、中断指令和系统功能调用",slug:"_5、中断指令和系统功能调用",normalizedTitle:"5、中断指令和系统功能调用",charIndex:4961},{level:3,title:"中断指令",slug:"中断指令",normalizedTitle:"中断指令",charIndex:4963},{level:2,title:"1、传送：从源存储区到目的区",slug:"_1、传送-从源存储区到目的区",normalizedTitle:"1、传送：从源存储区到目的区",charIndex:5467},{level:2,title:"2、存入串：将AX的内容存入目的存储区",slug:"_2、存入串-将ax的内容存入目的存储区",normalizedTitle:"2、存入串：将ax的内容存入目的存储区",charIndex:5882},{level:2,title:"3、从串取：从源存储区的内容送AX",slug:"_3、从串取-从源存储区的内容送ax",normalizedTitle:"3、从串取：从源存储区的内容送ax",charIndex:6012},{level:2,title:"4、比较源和目的串",slug:"_4、比较源和目的串",normalizedTitle:"4、比较源和目的串",charIndex:6318},{level:2,title:"5、串扫描：将AX的内容与目的串的一个数据比较",slug:"_5、串扫描-将ax的内容与目的串的一个数据比较",normalizedTitle:"5、串扫描：将ax的内容与目的串的一个数据比较",charIndex:6351},{level:2,title:"6、三种控制次数的指令（配合上面指令使用）",slug:"_6、三种控制次数的指令-配合上面指令使用",normalizedTitle:"6、三种控制次数的指令（配合上面指令使用）",charIndex:6398},{level:2,title:"变量的定义",slug:"变量的定义",normalizedTitle:"变量的定义",charIndex:7088},{level:2,title:"段定义",slug:"段定义",normalizedTitle:"段定义",charIndex:7505},{level:2,title:"过程定义（子程序）",slug:"过程定义-子程序",normalizedTitle:"过程定义（子程序）",charIndex:7760}],headersStr:"立即数（imm）寻址方式： 寄存器寻址： 存储器寻址： 堆栈操作指令 标志操作指令 加减乘除 符号扩展指令 乘法和除法指令 乘法指令 除法指令 1、逻辑运算指令 2、移位指令 3、循环移位指令 1、无条件转移指令 2、条件转移指令 3、循环指令 4、子程序指令 5、中断指令和系统功能调用 中断指令 1、传送：从源存储区到目的区 2、存入串：将AX的内容存入目的存储区 3、从串取：从源存储区的内容送AX 4、比较源和目的串 5、串扫描：将AX的内容与目的串的一个数据比较 6、三种控制次数的指令（配合上面指令使用） 变量的定义 段定义 过程定义（子程序）",content:"# 一、寻址方式\n\n\n# 立即数（imm）寻址方式：\n\n * 8位数值（00H-FFH）\n * 16位数值（0000H-FFFFH）\n * 字符常量\n * 只能在源（src）的位置\n\n\n# 寄存器寻址：\n\n * 操作数存放在cup的内部寄存器reg中：\n   * 8位寄存器r8：AH、AL、BH、BL、CH、CL、DH、DL\n   * 16位寄存器r16：AX、BX、CX、DX、SI、DI、SP、BP\n   * 4个段寄存器：CS、DS、ES、SS\n * 寄存器名表示其内容（操作数）\n * CS不能在目（dst）位置，只能在源（src）位置\n\n\n# 存储器寻址：\n\n * 操作数在主存储器中，用主存有效地址（EA）表示\n * 8086设计了5种存储器寻址方式\n   * 1、直接寻址方式\n   * 2、寄存器间接寻址方式\n   * 3、寄存器相对寻址方式\n   * 4、基址变址寻址方式\n   * 5、相对基址变址寻址方式\n\n1、直接寻址方式\n\n * 有效地址（EA）在指令种直接给出；MOV AX,[2000H]\n * 在中括号内表示有效地址（EA）\n * 默认的段地址DS，可用段超越前缀改变；MOV AX,ES:[2000H]\n\n2、寄存器间接寻址方式\n\n * EA存放在BX、SI、DI或BP中；\n * EA为BX/SI/DI时，默认是DS；\n * BP默认是SS；\n * 可以使用段超越前缀改变\n\n3、寄存器相对寻址方式\n\n * EA=BX/BP/DI/SI+8/16位位移量；、MOV AX,06H[SI]=MOV AX,[SI+06H]\n * EA为BX/SI/DI时，默认是DS；\n * BP默认是SS；\n * 可以使用段超越前缀改变\n\n4、基址变址寻址方式\n\n * EA=BX/BP（基址）+SI/DI（变址）、MOV AX,[BX+SI]、MOV AX,[BP][SI]\n * EA为BX/SI/DI时，默认是DS；\n * BP默认是SS；\n * 可以使用段超越前缀改变\n\n5、相对基址变址寻址方式\n\n * EA=BX/BP（基址）+SI/DI（变址）+8/16位位移量、MOV AX,[BX+SI+6]、MOV AX,6[BP+DI]\n * EA为BX/SI/DI时，默认是DS；\n * BP默认是SS；\n * 可以使用段超越前缀改变\n\n\n# 二、数据传送类指令\n\n除标志寄存器传送指令外，均不影响标志位。\n\n重点：MOV、XCHG、PUSH、POP、LEA\n\n了解：XLAT、LDS、LES\n\n1、传送指令：MOV 目(dst),源(src)\n\n * 立即数传送：\n   * 立即数一定在src位置；\n   * 源长度与目的操作数需长度一致\n * 寄存器传送：\n   * 速度块\n   * 目与源需长度一致\n * 存储器传送：\n   * 不存在存储器向存储器的传送指令\n   * 目和源不能同时是存储器寻址\n * 段寄存器传送\n\n2、交换指令：XCHG reg目(dst),reg/mem源(src)\n\n * 目与源的值交换\n * 双操作数长度一致\n * 立即数不可以使用\n\n3、换码指令：XLAT（了解）\n\n * AL<—DS:[BX+AL]\n * 将BX指定的缓冲区中，AL指定的位移处的一个字节数取出赋给AL\n * 隐含寻址（零地址指令，不带操作数）\n\n4、 取有效地址：LEA r16目(dst),mem源(src)\n\n * 取源的有效地址给目操作数\n\n\n# 堆栈操作指令\n\n * 堆栈占用主存区域;\n * 采用“先进后出”或“后进先出”原则；\n * 位于堆栈段中，段地址保存在SS段寄存器；\n * 堆栈只有一个出口，栈顶；\n * 用堆栈指针寄存器SP指定栈顶位置；\n * 堆栈只有两种基本操作：进栈PUSH和出栈POP。\n\n进栈指令：PUSH r16/m16/seg\n\n * SP<—SP-2\n * SS:[SP]<—r16/m16/seg\n * 字操作\n\n出栈指令：POP r16/m16/seg\n\n * r16/m16/seg<—SS:[SP]\n * SP<—SP+2\n * 字操作\n\n\n# 标志操作指令\n\n1、标志位操作指令（串操作）\n\n * CLC ;复位进位标志位：CF=0\n * STC ;置位进位标志位：CF=1\n * CMC ;求反进位标志位：CF=-CF\n * CLD ;复位方向标志位：DF=0\n * STD ;置位方向标志位：DF=1\n * CLI ;复位中断标志位：IF=0（关中断）\n * STI ;置位中断标志位：IF=1（开中断）\n\n2、标志寄存器低字节传送AH的指令：LAHF\n\n3、标志寄存器出入堆栈指令：PUSHF、POPF\n\n\n# 三、算数运算类\n\n\n# 加减乘除\n\n运算结果对状态标志位影响\n\n加法：ADD、ADC、INC\n\n减法：SUB、SBB、DEC、CMP、NEG(求补)\n\n1、加和减指令\n\nADD 目(dst),源(src) ;dst<—dst+src\n\nSUB 目(dst),源(src) ;dst<—dst-src\n\n2、带进位的加和减指令\n\nADC 目(dst),源(src) ;dst<—dst+src+CF\n\nSBB 目(dst),源(src) ;dst<—dst-src-CF\n\n3、比较指令CMP（compare）\n\nCMP 目(dst),源(src) ;dst-src\n\n * 差值不回送目的操作数\n * 影响状态标志\n\n4、增量和减量指令\n\nINC reg/mem\n\nDEC reg/mem\n\n * 均为单操作数指令\n * 不影响标志位CF\n\n5、求补指令\n\nNEG reg/mem ;reg/mem<—0-reg/mem\n\n * 单操作数指令\n * 不能用立即数\n * 影响标志位\n\n\n# 符号扩展指令\n\nCBW ;AL符号扩展成AX\n\nCWD ;AX符号扩展成DX\n\n * 零地址指令\n * 隐含的\n   * CBW：AL—>AX\n   * CWD：AX—>DX,AX(双字)\n\n\n# 乘法和除法指令\n\n\n# 乘法指令\n\n * 分无符号和有符号指令\n * 单操作数指令（隐含使用AL和AX）\n\nMUL opr ;无符号指令\n\nIMUL opr ;有符号指令\n\n格式：\n\nAL*opr（字节）—> AX\n\nAX*opr（字）—>DX,AX\n\n * opr不能是立即数，可以是reg/mem\n * 隐含被乘数\n * 对标志位影响\n   * 字节*字节=字节：CF=OF=0\n   * 字节*字节=字 ：CF=OF=1\n   * 字 *字 =字 ：CF=OF=0\n   * 字 *字 =双字：CF=OF=1\n * 其他标志位无定义\n\n\n# 除法指令\n\n * 分无符号和有符号指令\n * 单操作数指令（被除数隐含使用AX和DX,AX）\n\nDIV opr ;无符号指令\n\nIDIV opr ;有符号指令\n\n * opr不能是立即数，可以是reg/mem\n * 除数为0或商出范围，OF=1溢出\n * 对其他标志位无定义\n\nAX/opr(字节)—>商(AL),余(AH)\n\nDX,AX/opr(字)—>商(AX),余(DX)\n\n\n# 四、位操作指令\n\n以二进制进行数据的操作\n\n注意：对标志位的影响\n\n\n# 1、逻辑运算指令\n\nAND、OR、XOR、NOT、TEST\n\n * 设置：CF=OF=0\n * 结果影响SF、ZF和PF状态，对AF未定义\n * 单操作数：NOT 不影响任何标志位\n\n逻辑与：AND（有0出0）\n\nAND 目(dst),源(src) ;dst<—dst与src\n\n * 清零\n   * AND AX,0\n   * AND AL,0FH\n   * AND AX,AX\n\n逻辑或：OR（有1出1）\n\nOR 目(dst),源(src) ;dst<—dst 或src\n\n * 置位：\n   * OR AX,AX ;AX不变\n   * OR AL,OFH ；\n\n逻辑异或：XOR（相同为0，不同为1）\n\nXOR 目(dst),源(src) ;dst<—dst异或src\n\n * 取反、清零：\n   * XOR AX,AX\n   * XOR AL,03H\n\n测试指令：TEST\n\nTEST 目(dst),源(src) ;dst与src\n\n * 不保留结果\n * test AL,01H ;测试D0是否为1。\n * 测试某一位\n\n取反指令：NOT\n\nNOT reg/mem\n\n * 取反\n * 单操作数指令\n * 不影响任何标志位\n\n\n# 2、移位指令\n\n无符号（逻辑）：SHL、SHR；有符号（算数）：SAL、SAR\n\nL：左，R：右\n\n * 移出的位进入CF\n * 移位后的结果影响SF、ZF、PF\n\n逻辑左移指令：SHL\n\nSHL reg/mem,1/CL ;最低位补0，最高位进入CF\n\n逻辑右移指令：SHR\n\nSHR reg/mem,1/CL ;最高位补0，最低位进入CF\n\n算数左移指令：SAL\n\nSAL reg/mem,1/CL ;最低位补0，最高位进入CF\n\n算数右移指令：SAR\n\nSAR reg/mem,1/CL ;最高位不变，最低位进入CF\n\n\n# 3、循环移位指令\n\n不带进位：ROL、ROR；带进位：RCL、RCR\n\n * 设置进位标志CF，但不影响SF、ZF、PF、AF标志\n\n循环左移：ROL\n\nROL reg/mem,1/CL ;最高位移入CF和最低位\n\n循环左右移：ROR\n\nROR reg/mem,1/CL ;最低位移入CF和最高位\n\n进位循环左移：RCL\n\nRCL reg/mem,1/CL ;先将CF的值移入最低位，再将最高位的值移入CF\n\n进位循环右移：RCL\n\nRCR reg/mem,1/CL ;先将CF的值移入最高位，再将最低位的值移入CF\n\n\n# 五、控制转移类\n\n * 用于实现分支、循环、子程序等结构\n * 通过改变IP（和CS）值，实现程序执行顺序的改变。\n * 重点掌握：\n   * JMP（无条件转移指令）、JCC（条件转移指令）\n   * LOOP（循环）\n   * CALLL/RET（了解）\n   * INT n、IRET 常用系统功能调用\n\n\n# 1、无条件转移指令\n\nJMP 标号 ；程序转向标号指定的地址\n\n\n# 2、条件转移指令\n\nJCC 标号 ；条件满足，转移到标号的位置\n\n；否则，顺序执行\n\n不影响标志位，但要利用标志\n\n根据标志位不同，分成三种情况：\n\n * 对无符号数\n\nJA/JNBE\t\t\t大于/不小于等于\nJAE/JNB\t\t\t大于等于/不小于\nJB/JNAE\t\t\t小于/不大于等于\nJBE/JNA\t\t\t小于等于/不大于\n\n\n1\n2\n3\n4\n\n * 对有符号数\n\nJG/JNLE\t\t\t大于/不小于等于\nJGE/JNL\t\t\t大于等于/不小于\nJL/JNGE\t\t\t小于/不大于等于\nJLE/JNG\t\t\t小于等于/不大于\n\n\n1\n2\n3\n4\n\n * 对单个条件标志\n\nJE/JZ\t\t等于/结果为零\t\t  ZF=1\nJNE/JNZ\t\t不等于/结果不为零\tZF=0\nJC\t\t\t有进位/有借位\t\t  CF=1\nJNC\t\t\t无进位/无借位     CF=0\nJO\t\t\t溢出\t\t\t\t  OF=1\nJNO\t\t\t不溢出\t\t\t\t OF=0\nJP/JPE\t\t奇偶性为1（偶状态） PF=1\nJNP/JPO\t\t奇偶性为0（奇状态） PF=0\nJS\t\t\t符号位为1\t\t\tSF=1\nJNS\t\t\t符号位为0\t\t\tSF=0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3、循环指令\n\n * 88/86有针对CX计数器的计数循环指令\n * LOOP label（标号）执行分为两步：\n   * DEC CX ;CX<—CX-1\n   * JNZ label\n\n\n# 4、子程序指令\n\n * 子程序是完成特定功能的一段程序;\n * 主程序采用CALL调用指令转移到子程序的起始处执行;\n * 运行完子程序后，采用RET指令回到主程序继续执行。\n\n\n# 5、中断指令和系统功能调用\n\n\n# 中断指令\n\nINT i8\n\nIRET\n\n系统功能调用 （DOS功能调用）\n\nINT 21H\n\n重点掌握：\n\n * 键盘接收一个字符：01H号\n   \n   * 功能调用号：AH=01H\n   * 出口参数：AL=键盘接收的字符的ASCII码\n   * 功能调用：INT 21H\n\n * 输出到屏幕一个字符：02H号\n\n * 输出到屏幕一个字符串：09H号\n   \n   * 功能调用号：AH=09H\n   * 出口参数：DS:DX=欲显示字符串在内存中的首地址；最后必须以“$”结束（并不显示）\n   * 功能调用：INT 21H\n\n * 返回DOS：4CH号\n\n\n# 六、输入、输出类\n\n * IN\n * OUT\n\n\n# 七、串操作类\n\n * 零地址指令，操作数（隐含）\n * 源串DS:[SI]，目的串ES:[DI]，程序框架中需要定义数据段和附加段\n * 源串首/末地址—>SI，目的串/末首地址—>DI\n * 指令执行后，SI/DI（+-）1(B)/2(W)\n   * 地址增量（CLD/DF=0），上式为+\n   * 地址减量（STD/DF=1），上式为-\n\n\n# 1、传送：从源存储区到目的区\n\n * MOVSB\n\n> 意思是搬移一个字节，它是把 DS:SI 所指地址的一个字节搬移到 ES:DI 所指的地址上，搬移后原来的内容不变，但是原来 ES:DI 所指的内容会被覆盖而且在搬移之后 SI 和 DI 会自动地指向下一个要搬移的地址。\n\n * MOVSW\n\nMOVSB、MOVSW 和 MOVSD 指令将数据从 ESI 指向的内存位置复制到 EDI 指向的内存位置。（根据方向标志位的值）这两个寄存器自动地增加或减少：\n\nMOVSB   传送（复制）字节\nMOVSW   传送（复制）字\nMOVSD   传送（复制）双字\n\nMOVSB、MOVSW 和 MOVSD 可以使用重复前缀。方向标志位决定 ESI 和 EDI 是否增加或减少。增加 / 减少的量如下表所示：\n\n指令      ESI 和 EDI 增加或减少的数值\nMOVSB   1\nMOVSW   2\nMOVSD   4\n\n\n# 2、存入串：将AX的内容存入目的存储区\n\n * STOSB\n\n> 该指令为单字符输出指令，调用该指令后，可以将累加器AL中的值传递到当前ES段的DI地址处，并且根据DF的值来影响DI的值，如果DF为0，则调用该指令后，DI自增1。\n\n * STOSW\n\n\n# 3、从串取：从源存储区的内容送AX\n\n * LODSB\n * LODSW\n\n> 串操作指令LODSB/LODSW是块读出指令，其具体操作是把SI指向的存储单元读入累加器,其中LODSB是读入AL,LODSW是读入AX中,然后SI自动增加或减小1或2位.当方向标志位DF=0时，则SI自动增加；DF=1时，SI自动减小。\n> \n> 与LODSB/LODSW类似的，STOSB/STOSW是块写入指令，其具体操作是把累加器的内容写入到指向的存储单元中。其中STOSB是从AL中读入,STOSW是从AX中读入,然后DI自动增加或减小1或2位.当方向标志位DF=0时，则DI自动增加；DF=1时，DI自动减小。\n\n\n# 4、比较源和目的串\n\n * CMPSB\n * CMPSW\n\n\n# 5、串扫描：将AX的内容与目的串的一个数据比较\n\n * SCASB\n * SCASW\n\n\n# 6、三种控制次数的指令（配合上面指令使用）\n\n * REP\n   \n   * CX<—CX-1\n   \n   * 判断CX=0？若CX=0，退出\n   \n   * REP STOS m8 ：使用 AL 填写位于 ES:[(E)DI] 的 (E)CX 个字节\n\n * REPE/REPZ ；找不相等的字符\n   * CX<—CX-1\n   * 判断CX=0或ZF=0，则退出\n   * REPE CMPS m8,m8 ：在 ES:[(E)DI] 与 DS:[(E)SI] 中查找不匹配的字节\n * 串重复前缀REPNE/REPNZ；找相等的字符\n   * CX<—CX-1\n   * 判断CX=0或ZF=1，则退出\n   * REPNE CMPS m8,m8 ：在 ES:[(E)DI] 与 DS:[(E)SI] 中查找匹配字节\n\n\n# 八、处理器控制类、\n\n * NOP ；空操作指令，延时\n * HLT ；暂停指令:CPU进入暂停状态\n\n\n# 九、伪指令\n\n * 不参与程序执行，起到指示说明的作用\n\n类型名 PTR 名字/标号：当无法通过任一个操作数去确定操作类型时，需要显示指明长度时使用。\n\n * Byte PTR、Word PTR等；\n\nOFFSET 名字/标号：返回EA（偏移地址地址）\n\nSEG 名字/标号：返回段地址\n\nEND：表示源程序到此结束\n\nEQU：符号定义伪指令\n\n * EQU和“=”\n * 符号名 EQU 常数/数值表达式\n * 符号名 = 常数/数值表达式\n * EQU定义不占内存\n * EQU不能重复定义符号名，但“=”允许有重复赋值\n\n\n# 变量的定义\n\n汇编语言指令格式：\n\n变量名 伪指令 初值表\n\n变量名：表示初值表首元素的逻辑地址；\n\n伪指令：DB(字节8位)、DW(字16位)、DD(双字32位)\n\n初值表：用逗号分隔的参数\n\n复制操作符DUP定义多个相同元素：\n\n格式：重复次数 DUP (重复参数1、重复参数2、……)\n\nDB：\n\n * 无符号数：0——255\n * 有符号数：-128——+127\n * 字符串常数\n\n变量的定位：\n\n * 段中定义的第一变量从0地址开始；\n * 按照定义的先后顺序依次分配存储空间；\n * ORG控制数据或代码所在的偏移地址：ORG 参数\n\n名字和标号的属性：\n\n * 名字指向一条伪指令，标号指向一条硬指令。\n * 具有两类属性：\n   * 地址：段地址和偏移地址；\n   * 类型：\n     * 变量类型：BYTE、WORD和DWORD；\n     * 标号、段名、子程序名的类型：NEAR(近)和FAR(远)\n\n\n# 段定义\n\nPROC 定义过程.\n\nENDP 过程结束.\n\nSEGMENT 定义段.\n\nASSUME 建立段寄存器寻址.\n\nENDS 段结束.\n\nEND 程序结束.\n\nret 返回主程序\n\nIRET 子程序返回\n\n1、格式：\n\n段名 SEGMENT\n……\n段名 ENDS\n\n\n1\n2\n3\n\n\n2、ASSUME DS:数据段名,CS:代码段名,SS:堆栈段名,ES:附加段名:\n\n * 指定逻辑地址与物理地址之间的对应关系\n * 用指令MOV实现：\n\nMOV AX,段名\nMOV DS,AX\n\n\n1\n2\n\n\n\n# 过程定义（子程序）\n\n1、格式：\n\n过程名 PROC [属性NEAR或FAR]\n……\n过程名 ENDP\n\n\n1\n2\n3\n\n * NEAR：段内调用，同一代码段\n * FAR：段间调用，不同代码段\n\n2、举例：\n\nDpchar porc\n\tPUSH AX\n\tPUSH BX\n\t……\n\tPOP BX\n\tPOP AX\n\tRET\t\t；子程序返回\nDpchar endp ；过程结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断服务子程序的一般构成：\n\n * 开中断、保护现场、中断服务、恢复现场、中断返回\n\nintp porc\n\tSTI\t\t\t；开中断\n\tPUSH AX\n\tPUSH BX\n\t……\t\t  ；中断服务过程\n\tPOP BX\n\tPOP AX\n\tIRET\t\t；子程序返回\nintp endp ；过程结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 十、分支程序设计\n\n * 根据条件是真或假决定执行与否\n * 判断的条件指令，如cmp，test，执行后形成的状态标志\n\n\n# 十一、循环程序设计\n\n3个组成部分：\n\n * 循环初始部分：为开始循环准备必要的条件，如循环次数、循环体需要的数值等。\n * 循环体部分：指重复执行的程序部分，其中包括对循环条件等的修改程序段\n * 循环控制部分：判断循环条件是否成立，决定是否继续循环",normalizedContent:"# 一、寻址方式\n\n\n# 立即数（imm）寻址方式：\n\n * 8位数值（00h-ffh）\n * 16位数值（0000h-ffffh）\n * 字符常量\n * 只能在源（src）的位置\n\n\n# 寄存器寻址：\n\n * 操作数存放在cup的内部寄存器reg中：\n   * 8位寄存器r8：ah、al、bh、bl、ch、cl、dh、dl\n   * 16位寄存器r16：ax、bx、cx、dx、si、di、sp、bp\n   * 4个段寄存器：cs、ds、es、ss\n * 寄存器名表示其内容（操作数）\n * cs不能在目（dst）位置，只能在源（src）位置\n\n\n# 存储器寻址：\n\n * 操作数在主存储器中，用主存有效地址（ea）表示\n * 8086设计了5种存储器寻址方式\n   * 1、直接寻址方式\n   * 2、寄存器间接寻址方式\n   * 3、寄存器相对寻址方式\n   * 4、基址变址寻址方式\n   * 5、相对基址变址寻址方式\n\n1、直接寻址方式\n\n * 有效地址（ea）在指令种直接给出；mov ax,[2000h]\n * 在中括号内表示有效地址（ea）\n * 默认的段地址ds，可用段超越前缀改变；mov ax,es:[2000h]\n\n2、寄存器间接寻址方式\n\n * ea存放在bx、si、di或bp中；\n * ea为bx/si/di时，默认是ds；\n * bp默认是ss；\n * 可以使用段超越前缀改变\n\n3、寄存器相对寻址方式\n\n * ea=bx/bp/di/si+8/16位位移量；、mov ax,06h[si]=mov ax,[si+06h]\n * ea为bx/si/di时，默认是ds；\n * bp默认是ss；\n * 可以使用段超越前缀改变\n\n4、基址变址寻址方式\n\n * ea=bx/bp（基址）+si/di（变址）、mov ax,[bx+si]、mov ax,[bp][si]\n * ea为bx/si/di时，默认是ds；\n * bp默认是ss；\n * 可以使用段超越前缀改变\n\n5、相对基址变址寻址方式\n\n * ea=bx/bp（基址）+si/di（变址）+8/16位位移量、mov ax,[bx+si+6]、mov ax,6[bp+di]\n * ea为bx/si/di时，默认是ds；\n * bp默认是ss；\n * 可以使用段超越前缀改变\n\n\n# 二、数据传送类指令\n\n除标志寄存器传送指令外，均不影响标志位。\n\n重点：mov、xchg、push、pop、lea\n\n了解：xlat、lds、les\n\n1、传送指令：mov 目(dst),源(src)\n\n * 立即数传送：\n   * 立即数一定在src位置；\n   * 源长度与目的操作数需长度一致\n * 寄存器传送：\n   * 速度块\n   * 目与源需长度一致\n * 存储器传送：\n   * 不存在存储器向存储器的传送指令\n   * 目和源不能同时是存储器寻址\n * 段寄存器传送\n\n2、交换指令：xchg reg目(dst),reg/mem源(src)\n\n * 目与源的值交换\n * 双操作数长度一致\n * 立即数不可以使用\n\n3、换码指令：xlat（了解）\n\n * al<—ds:[bx+al]\n * 将bx指定的缓冲区中，al指定的位移处的一个字节数取出赋给al\n * 隐含寻址（零地址指令，不带操作数）\n\n4、 取有效地址：lea r16目(dst),mem源(src)\n\n * 取源的有效地址给目操作数\n\n\n# 堆栈操作指令\n\n * 堆栈占用主存区域;\n * 采用“先进后出”或“后进先出”原则；\n * 位于堆栈段中，段地址保存在ss段寄存器；\n * 堆栈只有一个出口，栈顶；\n * 用堆栈指针寄存器sp指定栈顶位置；\n * 堆栈只有两种基本操作：进栈push和出栈pop。\n\n进栈指令：push r16/m16/seg\n\n * sp<—sp-2\n * ss:[sp]<—r16/m16/seg\n * 字操作\n\n出栈指令：pop r16/m16/seg\n\n * r16/m16/seg<—ss:[sp]\n * sp<—sp+2\n * 字操作\n\n\n# 标志操作指令\n\n1、标志位操作指令（串操作）\n\n * clc ;复位进位标志位：cf=0\n * stc ;置位进位标志位：cf=1\n * cmc ;求反进位标志位：cf=-cf\n * cld ;复位方向标志位：df=0\n * std ;置位方向标志位：df=1\n * cli ;复位中断标志位：if=0（关中断）\n * sti ;置位中断标志位：if=1（开中断）\n\n2、标志寄存器低字节传送ah的指令：lahf\n\n3、标志寄存器出入堆栈指令：pushf、popf\n\n\n# 三、算数运算类\n\n\n# 加减乘除\n\n运算结果对状态标志位影响\n\n加法：add、adc、inc\n\n减法：sub、sbb、dec、cmp、neg(求补)\n\n1、加和减指令\n\nadd 目(dst),源(src) ;dst<—dst+src\n\nsub 目(dst),源(src) ;dst<—dst-src\n\n2、带进位的加和减指令\n\nadc 目(dst),源(src) ;dst<—dst+src+cf\n\nsbb 目(dst),源(src) ;dst<—dst-src-cf\n\n3、比较指令cmp（compare）\n\ncmp 目(dst),源(src) ;dst-src\n\n * 差值不回送目的操作数\n * 影响状态标志\n\n4、增量和减量指令\n\ninc reg/mem\n\ndec reg/mem\n\n * 均为单操作数指令\n * 不影响标志位cf\n\n5、求补指令\n\nneg reg/mem ;reg/mem<—0-reg/mem\n\n * 单操作数指令\n * 不能用立即数\n * 影响标志位\n\n\n# 符号扩展指令\n\ncbw ;al符号扩展成ax\n\ncwd ;ax符号扩展成dx\n\n * 零地址指令\n * 隐含的\n   * cbw：al—>ax\n   * cwd：ax—>dx,ax(双字)\n\n\n# 乘法和除法指令\n\n\n# 乘法指令\n\n * 分无符号和有符号指令\n * 单操作数指令（隐含使用al和ax）\n\nmul opr ;无符号指令\n\nimul opr ;有符号指令\n\n格式：\n\nal*opr（字节）—> ax\n\nax*opr（字）—>dx,ax\n\n * opr不能是立即数，可以是reg/mem\n * 隐含被乘数\n * 对标志位影响\n   * 字节*字节=字节：cf=of=0\n   * 字节*字节=字 ：cf=of=1\n   * 字 *字 =字 ：cf=of=0\n   * 字 *字 =双字：cf=of=1\n * 其他标志位无定义\n\n\n# 除法指令\n\n * 分无符号和有符号指令\n * 单操作数指令（被除数隐含使用ax和dx,ax）\n\ndiv opr ;无符号指令\n\nidiv opr ;有符号指令\n\n * opr不能是立即数，可以是reg/mem\n * 除数为0或商出范围，of=1溢出\n * 对其他标志位无定义\n\nax/opr(字节)—>商(al),余(ah)\n\ndx,ax/opr(字)—>商(ax),余(dx)\n\n\n# 四、位操作指令\n\n以二进制进行数据的操作\n\n注意：对标志位的影响\n\n\n# 1、逻辑运算指令\n\nand、or、xor、not、test\n\n * 设置：cf=of=0\n * 结果影响sf、zf和pf状态，对af未定义\n * 单操作数：not 不影响任何标志位\n\n逻辑与：and（有0出0）\n\nand 目(dst),源(src) ;dst<—dst与src\n\n * 清零\n   * and ax,0\n   * and al,0fh\n   * and ax,ax\n\n逻辑或：or（有1出1）\n\nor 目(dst),源(src) ;dst<—dst 或src\n\n * 置位：\n   * or ax,ax ;ax不变\n   * or al,ofh ；\n\n逻辑异或：xor（相同为0，不同为1）\n\nxor 目(dst),源(src) ;dst<—dst异或src\n\n * 取反、清零：\n   * xor ax,ax\n   * xor al,03h\n\n测试指令：test\n\ntest 目(dst),源(src) ;dst与src\n\n * 不保留结果\n * test al,01h ;测试d0是否为1。\n * 测试某一位\n\n取反指令：not\n\nnot reg/mem\n\n * 取反\n * 单操作数指令\n * 不影响任何标志位\n\n\n# 2、移位指令\n\n无符号（逻辑）：shl、shr；有符号（算数）：sal、sar\n\nl：左，r：右\n\n * 移出的位进入cf\n * 移位后的结果影响sf、zf、pf\n\n逻辑左移指令：shl\n\nshl reg/mem,1/cl ;最低位补0，最高位进入cf\n\n逻辑右移指令：shr\n\nshr reg/mem,1/cl ;最高位补0，最低位进入cf\n\n算数左移指令：sal\n\nsal reg/mem,1/cl ;最低位补0，最高位进入cf\n\n算数右移指令：sar\n\nsar reg/mem,1/cl ;最高位不变，最低位进入cf\n\n\n# 3、循环移位指令\n\n不带进位：rol、ror；带进位：rcl、rcr\n\n * 设置进位标志cf，但不影响sf、zf、pf、af标志\n\n循环左移：rol\n\nrol reg/mem,1/cl ;最高位移入cf和最低位\n\n循环左右移：ror\n\nror reg/mem,1/cl ;最低位移入cf和最高位\n\n进位循环左移：rcl\n\nrcl reg/mem,1/cl ;先将cf的值移入最低位，再将最高位的值移入cf\n\n进位循环右移：rcl\n\nrcr reg/mem,1/cl ;先将cf的值移入最高位，再将最低位的值移入cf\n\n\n# 五、控制转移类\n\n * 用于实现分支、循环、子程序等结构\n * 通过改变ip（和cs）值，实现程序执行顺序的改变。\n * 重点掌握：\n   * jmp（无条件转移指令）、jcc（条件转移指令）\n   * loop（循环）\n   * calll/ret（了解）\n   * int n、iret 常用系统功能调用\n\n\n# 1、无条件转移指令\n\njmp 标号 ；程序转向标号指定的地址\n\n\n# 2、条件转移指令\n\njcc 标号 ；条件满足，转移到标号的位置\n\n；否则，顺序执行\n\n不影响标志位，但要利用标志\n\n根据标志位不同，分成三种情况：\n\n * 对无符号数\n\nja/jnbe\t\t\t大于/不小于等于\njae/jnb\t\t\t大于等于/不小于\njb/jnae\t\t\t小于/不大于等于\njbe/jna\t\t\t小于等于/不大于\n\n\n1\n2\n3\n4\n\n * 对有符号数\n\njg/jnle\t\t\t大于/不小于等于\njge/jnl\t\t\t大于等于/不小于\njl/jnge\t\t\t小于/不大于等于\njle/jng\t\t\t小于等于/不大于\n\n\n1\n2\n3\n4\n\n * 对单个条件标志\n\nje/jz\t\t等于/结果为零\t\t  zf=1\njne/jnz\t\t不等于/结果不为零\tzf=0\njc\t\t\t有进位/有借位\t\t  cf=1\njnc\t\t\t无进位/无借位     cf=0\njo\t\t\t溢出\t\t\t\t  of=1\njno\t\t\t不溢出\t\t\t\t of=0\njp/jpe\t\t奇偶性为1（偶状态） pf=1\njnp/jpo\t\t奇偶性为0（奇状态） pf=0\njs\t\t\t符号位为1\t\t\tsf=1\njns\t\t\t符号位为0\t\t\tsf=0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3、循环指令\n\n * 88/86有针对cx计数器的计数循环指令\n * loop label（标号）执行分为两步：\n   * dec cx ;cx<—cx-1\n   * jnz label\n\n\n# 4、子程序指令\n\n * 子程序是完成特定功能的一段程序;\n * 主程序采用call调用指令转移到子程序的起始处执行;\n * 运行完子程序后，采用ret指令回到主程序继续执行。\n\n\n# 5、中断指令和系统功能调用\n\n\n# 中断指令\n\nint i8\n\niret\n\n系统功能调用 （dos功能调用）\n\nint 21h\n\n重点掌握：\n\n * 键盘接收一个字符：01h号\n   \n   * 功能调用号：ah=01h\n   * 出口参数：al=键盘接收的字符的ascii码\n   * 功能调用：int 21h\n\n * 输出到屏幕一个字符：02h号\n\n * 输出到屏幕一个字符串：09h号\n   \n   * 功能调用号：ah=09h\n   * 出口参数：ds:dx=欲显示字符串在内存中的首地址；最后必须以“$”结束（并不显示）\n   * 功能调用：int 21h\n\n * 返回dos：4ch号\n\n\n# 六、输入、输出类\n\n * in\n * out\n\n\n# 七、串操作类\n\n * 零地址指令，操作数（隐含）\n * 源串ds:[si]，目的串es:[di]，程序框架中需要定义数据段和附加段\n * 源串首/末地址—>si，目的串/末首地址—>di\n * 指令执行后，si/di（+-）1(b)/2(w)\n   * 地址增量（cld/df=0），上式为+\n   * 地址减量（std/df=1），上式为-\n\n\n# 1、传送：从源存储区到目的区\n\n * movsb\n\n> 意思是搬移一个字节，它是把 ds:si 所指地址的一个字节搬移到 es:di 所指的地址上，搬移后原来的内容不变，但是原来 es:di 所指的内容会被覆盖而且在搬移之后 si 和 di 会自动地指向下一个要搬移的地址。\n\n * movsw\n\nmovsb、movsw 和 movsd 指令将数据从 esi 指向的内存位置复制到 edi 指向的内存位置。（根据方向标志位的值）这两个寄存器自动地增加或减少：\n\nmovsb   传送（复制）字节\nmovsw   传送（复制）字\nmovsd   传送（复制）双字\n\nmovsb、movsw 和 movsd 可以使用重复前缀。方向标志位决定 esi 和 edi 是否增加或减少。增加 / 减少的量如下表所示：\n\n指令      esi 和 edi 增加或减少的数值\nmovsb   1\nmovsw   2\nmovsd   4\n\n\n# 2、存入串：将ax的内容存入目的存储区\n\n * stosb\n\n> 该指令为单字符输出指令，调用该指令后，可以将累加器al中的值传递到当前es段的di地址处，并且根据df的值来影响di的值，如果df为0，则调用该指令后，di自增1。\n\n * stosw\n\n\n# 3、从串取：从源存储区的内容送ax\n\n * lodsb\n * lodsw\n\n> 串操作指令lodsb/lodsw是块读出指令，其具体操作是把si指向的存储单元读入累加器,其中lodsb是读入al,lodsw是读入ax中,然后si自动增加或减小1或2位.当方向标志位df=0时，则si自动增加；df=1时，si自动减小。\n> \n> 与lodsb/lodsw类似的，stosb/stosw是块写入指令，其具体操作是把累加器的内容写入到指向的存储单元中。其中stosb是从al中读入,stosw是从ax中读入,然后di自动增加或减小1或2位.当方向标志位df=0时，则di自动增加；df=1时，di自动减小。\n\n\n# 4、比较源和目的串\n\n * cmpsb\n * cmpsw\n\n\n# 5、串扫描：将ax的内容与目的串的一个数据比较\n\n * scasb\n * scasw\n\n\n# 6、三种控制次数的指令（配合上面指令使用）\n\n * rep\n   \n   * cx<—cx-1\n   \n   * 判断cx=0？若cx=0，退出\n   \n   * rep stos m8 ：使用 al 填写位于 es:[(e)di] 的 (e)cx 个字节\n\n * repe/repz ；找不相等的字符\n   * cx<—cx-1\n   * 判断cx=0或zf=0，则退出\n   * repe cmps m8,m8 ：在 es:[(e)di] 与 ds:[(e)si] 中查找不匹配的字节\n * 串重复前缀repne/repnz；找相等的字符\n   * cx<—cx-1\n   * 判断cx=0或zf=1，则退出\n   * repne cmps m8,m8 ：在 es:[(e)di] 与 ds:[(e)si] 中查找匹配字节\n\n\n# 八、处理器控制类、\n\n * nop ；空操作指令，延时\n * hlt ；暂停指令:cpu进入暂停状态\n\n\n# 九、伪指令\n\n * 不参与程序执行，起到指示说明的作用\n\n类型名 ptr 名字/标号：当无法通过任一个操作数去确定操作类型时，需要显示指明长度时使用。\n\n * byte ptr、word ptr等；\n\noffset 名字/标号：返回ea（偏移地址地址）\n\nseg 名字/标号：返回段地址\n\nend：表示源程序到此结束\n\nequ：符号定义伪指令\n\n * equ和“=”\n * 符号名 equ 常数/数值表达式\n * 符号名 = 常数/数值表达式\n * equ定义不占内存\n * equ不能重复定义符号名，但“=”允许有重复赋值\n\n\n# 变量的定义\n\n汇编语言指令格式：\n\n变量名 伪指令 初值表\n\n变量名：表示初值表首元素的逻辑地址；\n\n伪指令：db(字节8位)、dw(字16位)、dd(双字32位)\n\n初值表：用逗号分隔的参数\n\n复制操作符dup定义多个相同元素：\n\n格式：重复次数 dup (重复参数1、重复参数2、……)\n\ndb：\n\n * 无符号数：0——255\n * 有符号数：-128——+127\n * 字符串常数\n\n变量的定位：\n\n * 段中定义的第一变量从0地址开始；\n * 按照定义的先后顺序依次分配存储空间；\n * org控制数据或代码所在的偏移地址：org 参数\n\n名字和标号的属性：\n\n * 名字指向一条伪指令，标号指向一条硬指令。\n * 具有两类属性：\n   * 地址：段地址和偏移地址；\n   * 类型：\n     * 变量类型：byte、word和dword；\n     * 标号、段名、子程序名的类型：near(近)和far(远)\n\n\n# 段定义\n\nproc 定义过程.\n\nendp 过程结束.\n\nsegment 定义段.\n\nassume 建立段寄存器寻址.\n\nends 段结束.\n\nend 程序结束.\n\nret 返回主程序\n\niret 子程序返回\n\n1、格式：\n\n段名 segment\n……\n段名 ends\n\n\n1\n2\n3\n\n\n2、assume ds:数据段名,cs:代码段名,ss:堆栈段名,es:附加段名:\n\n * 指定逻辑地址与物理地址之间的对应关系\n * 用指令mov实现：\n\nmov ax,段名\nmov ds,ax\n\n\n1\n2\n\n\n\n# 过程定义（子程序）\n\n1、格式：\n\n过程名 proc [属性near或far]\n……\n过程名 endp\n\n\n1\n2\n3\n\n * near：段内调用，同一代码段\n * far：段间调用，不同代码段\n\n2、举例：\n\ndpchar porc\n\tpush ax\n\tpush bx\n\t……\n\tpop bx\n\tpop ax\n\tret\t\t；子程序返回\ndpchar endp ；过程结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n中断服务子程序的一般构成：\n\n * 开中断、保护现场、中断服务、恢复现场、中断返回\n\nintp porc\n\tsti\t\t\t；开中断\n\tpush ax\n\tpush bx\n\t……\t\t  ；中断服务过程\n\tpop bx\n\tpop ax\n\tiret\t\t；子程序返回\nintp endp ；过程结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 十、分支程序设计\n\n * 根据条件是真或假决定执行与否\n * 判断的条件指令，如cmp，test，执行后形成的状态标志\n\n\n# 十一、循环程序设计\n\n3个组成部分：\n\n * 循环初始部分：为开始循环准备必要的条件，如循环次数、循环体需要的数值等。\n * 循环体部分：指重复执行的程序部分，其中包括对循环条件等的修改程序段\n * 循环控制部分：判断循环条件是否成立，决定是否继续循环",charsets:{cjk:!0},lastUpdated:"2022/06/20, 23:06:00",lastUpdatedTimestamp:1655737214e3},{title:"文档 - 快速上手",frontmatter:{title:"文档 - 快速上手",date:"2021-05-16T22:47:39.000Z",permalink:"/pages/c6c456/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/02.%E6%96%87%E6%A1%A3%20-%20%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html",relativePath:"10.关于/02.关于 - 本站/02.文档 -  快速上手.md",key:"v-257b116f",path:"/pages/c6c456/",headers:[{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:3},{level:2,title:"快速开始",slug:"快速开始",normalizedTitle:"快速开始",charIndex:9},{level:2,title:"配置信息修改",slug:"配置信息修改",normalizedTitle:"配置信息修改",charIndex:17},{level:2,title:"详情请看",slug:"详情请看",normalizedTitle:"详情请看",charIndex:27}],headersStr:"准备 快速开始 配置信息修改 详情请看",content:" * 准备\n * 快速开始\n * 配置信息修改\n * 详情请看\n\n使用 vuepress 及主题 vdoing ，自动部署在GitHub Pages\n\n纯新手可看 bilibili 的 vuepress 视频教程：https://www.bilibili.com/video/BV17t41177cr\n\n\n# 准备\n\nVuePress 需要 Node.js >= 8.6\n\n首先需要下载 Node.js\n\n 1. 克隆到本地并进入目录\n    \n    git clone https://github.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n    \n    或 gitee 地址：\n    \n    git clone https://gitee.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n\n 2. 安装本地依赖\n    \n    npm install\n    \n    \n    1\n    \n\n 3. 本地测试\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    默认访问链接：http://localhost:8080\n\n\n# 快速开始\n\n使用 markdown 语法编写 md 文件，所有笔记 md 文件放在 docs/ 目录下\n\n例如添加 test 类，并编写 hello.md 文件\n\n 1. 创建目录\n    \n    格式：序号+标题\n    \n    例如：30.test\n\n 2. 添加笔记\n    \n    例如：01.hello.md\n\n 3. 编写内容\n    \n    ## 标题\n    \n    hello world\n    \n    \n    1\n    2\n    3\n    \n\n 4. 测试运行\n    \n    在项目根目录下\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    会自动生成\n    \n    tittle：标题，默认文件名，即 hello\n    \n    permalink：访问链接\n    \n    date：日期，默认文件创建时间\n\n\n# 配置信息修改\n\n一些常用的\n\n目录 docs\\.vuepress 下\n\n * config.js\n   \n   修改 vuepress 和主题一些配置\n\n * config\\nav.js\n   \n   修改首页导航栏\n\n\n# 详情请看\n\n关于 vuepress 的配置：\n\n * vuepress官方文档\n\n * vdoing主题介绍文档",normalizedContent:" * 准备\n * 快速开始\n * 配置信息修改\n * 详情请看\n\n使用 vuepress 及主题 vdoing ，自动部署在github pages\n\n纯新手可看 bilibili 的 vuepress 视频教程：https://www.bilibili.com/video/bv17t41177cr\n\n\n# 准备\n\nvuepress 需要 node.js >= 8.6\n\n首先需要下载 node.js\n\n 1. 克隆到本地并进入目录\n    \n    git clone https://github.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n    \n    或 gitee 地址：\n    \n    git clone https://gitee.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n\n 2. 安装本地依赖\n    \n    npm install\n    \n    \n    1\n    \n\n 3. 本地测试\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    默认访问链接：http://localhost:8080\n\n\n# 快速开始\n\n使用 markdown 语法编写 md 文件，所有笔记 md 文件放在 docs/ 目录下\n\n例如添加 test 类，并编写 hello.md 文件\n\n 1. 创建目录\n    \n    格式：序号+标题\n    \n    例如：30.test\n\n 2. 添加笔记\n    \n    例如：01.hello.md\n\n 3. 编写内容\n    \n    ## 标题\n    \n    hello world\n    \n    \n    1\n    2\n    3\n    \n\n 4. 测试运行\n    \n    在项目根目录下\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    会自动生成\n    \n    tittle：标题，默认文件名，即 hello\n    \n    permalink：访问链接\n    \n    date：日期，默认文件创建时间\n\n\n# 配置信息修改\n\n一些常用的\n\n目录 docs\\.vuepress 下\n\n * config.js\n   \n   修改 vuepress 和主题一些配置\n\n * config\\nav.js\n   \n   修改首页导航栏\n\n\n# 详情请看\n\n关于 vuepress 的配置：\n\n * vuepress官方文档\n\n * vdoing主题介绍文档",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"文档 - md文件写作",frontmatter:{title:"文档 - md文件写作",date:"2021-05-30T00:13:42.000Z",permalink:"/pages/2a3030/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/03.%E6%96%87%E6%A1%A3%20-%20md%E6%96%87%E4%BB%B6%E5%86%99%E4%BD%9C.html",relativePath:"10.关于/02.关于 - 本站/03.文档 - md文件写作.md",key:"v-7c85b34c",path:"/pages/2a3030/",headers:[{level:2,title:"推荐写作软件",slug:"推荐写作软件",normalizedTitle:"推荐写作软件",charIndex:2},{level:2,title:"图片要求",slug:"图片要求",normalizedTitle:"图片要求",charIndex:176},{level:2,title:"文件命名约定",slug:"文件命名约定",normalizedTitle:"文件命名约定",charIndex:302},{level:2,title:"级别说明",slug:"级别说明",normalizedTitle:"级别说明",charIndex:602}],headersStr:"推荐写作软件 图片要求 文件命名约定 级别说明",content:"# 推荐写作软件\n\n推荐写 markdown 软件\n\n 1. Typora\n    \n    下载即用\n\n 2. vs code\n    \n    需要下载 markdown 插件\n    \n    里面终端可设置 git bash 终端，方便调试，适合程序员使用\n    \n    设置教程：新版本VS Code 终端设置为git bash\n\n\n# 图片要求\n\n图片地址必须是可在线访问的链接，不能是本地图片\n\n可以用 GitHub+PicGo+jsDelivr 搭建免费图床\n\n如何免费搭建图床，并在markdown中使用教程：https://oddfar.com/archives/91/\n\n\n# 文件命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n * 文件或文件夹名称中间不能出现多余的点.，如01.我是.名称.md中间出现.将会导致解析错误。\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 README.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\nvdoing主题介绍文档：https://doc.xugaoyi.com/pages/33d574/",normalizedContent:"# 推荐写作软件\n\n推荐写 markdown 软件\n\n 1. typora\n    \n    下载即用\n\n 2. vs code\n    \n    需要下载 markdown 插件\n    \n    里面终端可设置 git bash 终端，方便调试，适合程序员使用\n    \n    设置教程：新版本vs code 终端设置为git bash\n\n\n# 图片要求\n\n图片地址必须是可在线访问的链接，不能是本地图片\n\n可以用 github+picgo+jsdelivr 搭建免费图床\n\n如何免费搭建图床，并在markdown中使用教程：https://oddfar.com/archives/91/\n\n\n# 文件命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n * 文件或文件夹名称中间不能出现多余的点.，如01.我是.名称.md中间出现.将会导致解析错误。\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 readme.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\nvdoing主题介绍文档：https://doc.xugaoyi.com/pages/33d574/",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"文档 - 部署",frontmatter:{title:"文档 - 部署",date:"2021-05-16T22:53:51.000Z",permalink:"/pages/39f283/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/05.%E6%96%87%E6%A1%A3%20-%20%E9%83%A8%E7%BD%B2.html",relativePath:"10.关于/02.关于 - 本站/05.文档 - 部署.md",key:"v-d5fd0592",path:"/pages/39f283/",headers:[{level:2,title:"手动部署",slug:"手动部署",normalizedTitle:"手动部署",charIndex:3},{level:3,title:"GitHub",slug:"github",normalizedTitle:"github",charIndex:13},{level:3,title:"自己服务器",slug:"自己服务器",normalizedTitle:"自己服务器",charIndex:25},{level:2,title:"GitHub 自动部署",slug:"github-自动部署",normalizedTitle:"github 自动部署",charIndex:34},{level:3,title:"生成 Token",slug:"生成-token",normalizedTitle:"生成 token",charIndex:51},{level:3,title:"配置秘钥",slug:"配置秘钥",normalizedTitle:"配置秘钥",charIndex:65},{level:2,title:"自动部署自己服务器",slug:"自动部署自己服务器",normalizedTitle:"自动部署自己服务器",charIndex:73}],headersStr:"手动部署 GitHub 自己服务器 GitHub 自动部署 生成 Token 配置秘钥 自动部署自己服务器",content:" * 手动部署\n   * GitHub\n   * 自己服务器\n * GitHub 自动部署\n   * 生成 Token\n   * 配置秘钥\n * 自动部署自己服务器\n\n\n# 手动部署\n\n\n# GitHub\n\n创建分支：gh-pages\n\n更改文件deploy.sh内容\n\n仓库地址替换成自己的：\n\n * githubUrl=git@github.com:oddfar/notes.git\n\n * githubUrl=https://oddfar:${GITHUB_TOKEN}@github.com/oddfar/notes.git\n\n * initDist \"module.exports = '/notes/'\"\n\n修好完后，双击运行 deploy.sh\n\n之后配置 GitHub Pages\n\n\n\n\n# 自己服务器\n\n根目录下执行命令\n\nnpm run build\n\n\n1\n\n\n生成文件在 docs\\.vuepress\\dist\\ 目录下\n\n打包到服务器即可\n\n注：本地不可直接访问，需要配合插件，详情看官方文档\n\n\n# GitHub 自动部署\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n若不需要同步到 Gitee 镜像，且需要配置对，否则把文件里面的 步骤三和步骤四 删掉\n\n配置文件已经写好了，我们只需要在 github 上配置下秘钥（secrets）\n\n前提已经配置了 GitHub Pages 服务并能正常访问\n\n\n# 生成 Token\n\nSettings -> Developer settings->Personal access tokens\n\n1、Settings\n\n\n\n2、Developer settings\n\n\n\n3、Personal access tokens\n\n\n\n4、Generate new token\n\n\n\n创建成功后，会生成一串token，这串token之后不会再显示，请认真保存\n\n\n# 配置秘钥\n\n仓库Setting -> secrets -> New repository secret\n\n\n\nName必须填 ACCESS_TOKEN\n\nValue填写上一步生成的Token\n\n\n\n至此已全部配置好\n\n每当我们 push 到主分支 master 时候，github pages 会自动部署\n\n\n# 自动部署自己服务器\n\n简单的说下步骤：\n\n\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n需要把项目地址修改成自己的，并在 Secret 中添加Token： GITEE_RSA_PRIVATE_KEY 内容为 SSH 私钥\n\n脚本文件：\n\ncd /www/wwwroot/note.oddfar.com/\nrm -rf notes\ngit clone -b gh-pages https://gitee.com/oddfar/notes.git\nrm -rf run/*\ncp -rf notes/* run/\n\n\n1\n2\n3\n4\n5\n\n\n定时任务：\n\n宝塔 设置运行目录，并关闭防跨站攻击：\n\n最后访问地址：\n\n * https://note.oddfar.com\n\n * https://oddfar.github.io/notes",normalizedContent:" * 手动部署\n   * github\n   * 自己服务器\n * github 自动部署\n   * 生成 token\n   * 配置秘钥\n * 自动部署自己服务器\n\n\n# 手动部署\n\n\n# github\n\n创建分支：gh-pages\n\n更改文件deploy.sh内容\n\n仓库地址替换成自己的：\n\n * githuburl=git@github.com:oddfar/notes.git\n\n * githuburl=https://oddfar:${github_token}@github.com/oddfar/notes.git\n\n * initdist \"module.exports = '/notes/'\"\n\n修好完后，双击运行 deploy.sh\n\n之后配置 github pages\n\n\n\n\n# 自己服务器\n\n根目录下执行命令\n\nnpm run build\n\n\n1\n\n\n生成文件在 docs\\.vuepress\\dist\\ 目录下\n\n打包到服务器即可\n\n注：本地不可直接访问，需要配合插件，详情看官方文档\n\n\n# github 自动部署\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n若不需要同步到 gitee 镜像，且需要配置对，否则把文件里面的 步骤三和步骤四 删掉\n\n配置文件已经写好了，我们只需要在 github 上配置下秘钥（secrets）\n\n前提已经配置了 github pages 服务并能正常访问\n\n\n# 生成 token\n\nsettings -> developer settings->personal access tokens\n\n1、settings\n\n\n\n2、developer settings\n\n\n\n3、personal access tokens\n\n\n\n4、generate new token\n\n\n\n创建成功后，会生成一串token，这串token之后不会再显示，请认真保存\n\n\n# 配置秘钥\n\n仓库setting -> secrets -> new repository secret\n\n\n\nname必须填 access_token\n\nvalue填写上一步生成的token\n\n\n\n至此已全部配置好\n\n每当我们 push 到主分支 master 时候，github pages 会自动部署\n\n\n# 自动部署自己服务器\n\n简单的说下步骤：\n\n\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n需要把项目地址修改成自己的，并在 secret 中添加token： gitee_rsa_private_key 内容为 ssh 私钥\n\n脚本文件：\n\ncd /www/wwwroot/note.oddfar.com/\nrm -rf notes\ngit clone -b gh-pages https://gitee.com/oddfar/notes.git\nrm -rf run/*\ncp -rf notes/* run/\n\n\n1\n2\n3\n4\n5\n\n\n定时任务：\n\n宝塔 设置运行目录，并关闭防跨站攻击：\n\n最后访问地址：\n\n * https://note.oddfar.com\n\n * https://oddfar.github.io/notes",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"输入输出系统接口芯片",frontmatter:{title:"输入输出系统接口芯片",date:"2022-04-11T02:30:00.000Z",permalink:"/c1/5",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/02.%E7%BB%83%E4%B9%A0%E9%A2%98/04.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87.html",relativePath:"02.练习题/04.输入输出系统接口芯片.md",key:"v-9e40a888",path:"/c1/5/",headers:[{level:2,title:"输入输出（I/O）接口概念",slug:"输入输出-i-o-接口概念",normalizedTitle:"输入输出（i/o）接口概念",charIndex:17},{level:2,title:"数据传送方式",slug:"数据传送方式",normalizedTitle:"数据传送方式",charIndex:1459},{level:3,title:"一、无条件传送方式（同步）",slug:"一、无条件传送方式-同步",normalizedTitle:"一、无条件传送方式（同步）",charIndex:1646},{level:3,title:"二、查询传送方式（异步）",slug:"二、查询传送方式-异步",normalizedTitle:"二、查询传送方式（异步）",charIndex:1765},{level:3,title:"三、中断传送方式：int 21h",slug:"三、中断传送方式-int-21h",normalizedTitle:"三、中断传送方式：int 21h",charIndex:1985},{level:3,title:"四、DMA传送方式",slug:"四、dma传送方式",normalizedTitle:"四、dma传送方式",charIndex:2385},{level:2,title:"并行通信",slug:"并行通信",normalizedTitle:"并行通信",charIndex:3109},{level:2,title:"一、8255A的内部结构和引脚：",slug:"一、8255a的内部结构和引脚",normalizedTitle:"一、8255a的内部结构和引脚：",charIndex:3192},{level:2,title:"二、8255A的工作方式",slug:"二、8255a的工作方式",normalizedTitle:"二、8255a的工作方式",charIndex:3732},{level:2,title:"三、8255A的编程",slug:"三、8255a的编程",normalizedTitle:"三、8255a的编程",charIndex:4162},{level:2,title:"一、概念",slug:"一、概念",normalizedTitle:"一、概念",charIndex:4860},{level:2,title:"二、通用异步接收发送器UART（8251、8250）",slug:"二、通用异步接收发送器uart-8251、8250",normalizedTitle:"二、通用异步接收发送器uart（8251、8250）",charIndex:5639},{level:2,title:"一、中断控制器8259A",slug:"一、中断控制器8259a",normalizedTitle:"一、中断控制器8259a",charIndex:5880},{level:2,title:"二、8259A的中断过程",slug:"二、8259a的中断过程",normalizedTitle:"二、8259a的中断过程",charIndex:6656},{level:2,title:"三、8259A的工作方式",slug:"三、8259a的工作方式",normalizedTitle:"三、8259a的工作方式",charIndex:6681},{level:2,title:"四、8259A的编程",slug:"四、8259a的编程",normalizedTitle:"四、8259a的编程",charIndex:7793},{level:3,title:"初始化编程",slug:"初始化编程",normalizedTitle:"初始化编程",charIndex:4259},{level:2,title:"一、定时/计数器原理",slug:"一、定时-计数器原理",normalizedTitle:"一、定时/计数器原理",charIndex:9782},{level:2,title:"二、8253的内部结构和引脚",slug:"二、8253的内部结构和引脚",normalizedTitle:"二、8253的内部结构和引脚",charIndex:10023},{level:2,title:"三、8253的工作方式",slug:"三、8253的工作方式",normalizedTitle:"三、8253的工作方式",charIndex:10630},{level:2,title:"四、8253的编程",slug:"四、8253的编程",normalizedTitle:"四、8253的编程",charIndex:10998},{level:2,title:"一、8237 DMA概述",slug:"一、8237-dma概述",normalizedTitle:"一、8237 dma概述",charIndex:11401},{level:2,title:"二、8237 DMA数据传送的工作过程",slug:"二、8237-dma数据传送的工作过程",normalizedTitle:"二、8237 dma数据传送的工作过程",charIndex:11538},{level:2,title:"三、DMA控制器8237A",slug:"三、dma控制器8237a",normalizedTitle:"三、dma控制器8237a",charIndex:11838}],headersStr:"输入输出（I/O）接口概念 数据传送方式 一、无条件传送方式（同步） 二、查询传送方式（异步） 三、中断传送方式：int 21h 四、DMA传送方式 并行通信 一、8255A的内部结构和引脚： 二、8255A的工作方式 三、8255A的编程 一、概念 二、通用异步接收发送器UART（8251、8250） 一、中断控制器8259A 二、8259A的中断过程 三、8259A的工作方式 四、8259A的编程 初始化编程 一、定时/计数器原理 二、8253的内部结构和引脚 三、8253的工作方式 四、8253的编程 一、8237 DMA概述 二、8237 DMA数据传送的工作过程 三、DMA控制器8237A",content:"# 输入输出系统接口芯片\n\n\n# 输入输出（I/O）接口概念\n\n一、I/O接口概念\n\n1、为什么需要I/O接口（电路）？\n\n * 微机的外部设别多种多样\n * 工作原理、信息格式、工作速度等方面差别很大\n * 外设不能与CPU直接向相连\n * 必须经过中间电路再与系统相连\n\n2、什么是I/O接口电路？\n\n * I/O接口是位于系统与外设间、用来协助完成数据传送和控制任务的逻辑电路；\n * 可编程接口芯片、I/O总线槽的电路板（适配器）都是接口电路。\n\n3、I/O接口的主要功能\n\n * 速度匹配、数据缓冲；\n * 数据格式的转换；\n * 对I/O端口寻址、地址译码；\n * CPU与外设信息联络；\n * 设置中断和DMA控制逻辑\n\n4、端口（PORT）\n\n * 泛指I/O地址，对应接口电路的寄存器；\n * 一个接口电路可以具有多个I/O端口（寄存器）\n * 数据端口、状态端口和控制端口：用于保存数据、状态信息\n\n二、I/O接口的典型结构\n\n1、接口结构\n\n2、I/O接口组成\n\n接口由硬件和软件组成。\n\n接口软件有两类：\n\n * 初始化程序段：\n   * 设备驱动程序、设定芯片工作方式等\n * 数据交换程序段：\n   * 管理、控制、驱动外设，负责和系统间信息交换。\n\n三、I/O端口的编址\n\n两类编址\n\n * I/O端口单独编址（独立编址）：\n   * I/O地址空间独立于存储地址空间，内存与I/O空间各自独立\n   * 如：8086/8088\n * I/O端口与存储器统一编址：\n   * 他们共享一个地址空间，内存与I/O空间共用\n   * 如：M6800\n\n独立编址：\n\n优点：\n- I/O端口的地址空间独立\n- 控制和地址译码电路简单\n- 专门的I/O指令\n缺点：\n- I/O指令种类少\n- 空间少\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n统一编址：\n\n优点：\n- 不需要专门的I/O指令\n- I/O数据存取灵活\n缺点：\n- I/O端口要占去部分存储器地址空间\n- 程序不易阅读（不易分清访问存储器和访问外设）\n\n\n1\n2\n3\n4\n5\n6\n\n\n四、88/86的输入输出指令\n\n1、I/O端口地址\n\n * 外设的端口（PORT），即I/O地址。\n * 88/86用于寻址外设端口的地址线为16条，\n * 端口最多为2的16次方=65536（64KB）个，\n * 端口号为：0000H-FFFFH\n\n2、I/O端口寻址方式\n\n88/86的端口有64KB，不分段，两种寻址方式：\n\n * 直接寻址：\n   * 只寻址00H-FFH前256个端口号\n   * 指令中操作数直接使用端口号；\n * 间接寻址：\n   * 可寻址全部64K个端口号：0000H-FFFFH\n   * DX寄存器的值存放端口号；\n   * 0100H-FFFFH的端口只能采用间接寻址方式。\n\n3、输入指令\n\n将外设数据传送给CPU内的AL/AX：\n\n * IN AL,端口地址\n * IN AL,DX/i8 ;字节输入\n * IN AX,DX/i8 ;字输入\n\n4、输出指令\n\n将CPU内的AL/AX数据传送给外设：\n\n * OUT 端口地址,AL/AX\n * OUT DX/i8,AL ;字节输出\n * OUT DX/i8,AX ;字输出\n\n五、I/O地址的译码\n\n * 门电路：接口电路只占少量I/O地址，可以利用线选法地址译码。\n * 译码器：选用2：4译码器或3：8译码器进行\n\n1、逻辑门电路进行I/O地址译码\n\n\n# 数据传送方式\n\n * 程序控制的数据传送：CPU执行程序中I/O指令完成传送，分为：无条件传送、查询传送、中断传送。\n * 直接存储器存取（DMA）：\n   * 硬件芯片8237；\n   * DMAC利用系统总线在外设和主存间传送。\n * I/O处理机实现数据传送：\n   * 协处理器8089：数据输入/出\n   * CPU委托专门的I/O处理机来完成数据传送。\n\n\n# 一、无条件传送方式（同步）\n\n1、原理：\n\n * CPU与慢速外设交换数据；\n * 外设处于“就绪”状态，随时可以进行数据传送，亦称同步传送；\n * 适用于简单设备，如：LED数码管，按键等；\n * 传送条件：外设必须随时就绪。\n\n\n# 二、查询传送方式（异步）\n\n1、原理\n\n * CPU先查询外设的工作状态，\n * 在外设就绪时，实现数据输入或输出；\n * 查询传送的特点是：工作可靠，但传送效率低。\n\n2、查询传送的两个环节\n\n * 查询\n   * 寻址状态口\n   * 读取状态端口的状态位；\n   * 若无就绪就继续查询；\n * 传送\n   * 外设就绪后，寻址数据口\n   * 输入：IN指令从数据端口读入数据\n   * 输出：OUT指令向数据端口输出数据\n\n\n# 三、中断传送方式：int 21h\n\n1、用中断服务子程序实现\n\n2、特点：\n\n * 是一种效率较高的程序传送方式；\n * 中断服务程序是预先设计好的；\n * CPU在每条指令周期后采样中断请求输入信号；\n * 外设需要传输数据时，主动向CPU提出中断请求，提高实时性；\n * 外设准备数据和CPU执行程序并行工作，提高CPU效率；\n * 每传输一次数据就要中断一次，需保护断点和现场；\n * 需要中断控制器8259芯片；\n * 适合少量数据、中慢速外设的数据传送，如鼠标、键盘。\n\n3、中断过程：\n\n1、中断请求（外设）\n2、中断响应（CPU）\n3、关中断（CPU）\n4、断点保护（CPU）\n5、识别中断源（硬件/软件）\n6、现场保护（用户）\n7、中断服务：数据交换\n8、恢复现场（用户）\n9、开中断（CPU/用户）\n10、中断fan'hui\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 四、DMA传送方式\n\n1、特点：\n\n * 克服程序控制传输的不足\n\n外设->CPU->存储器\n外设<-CPU<-存储器\n\n\n1\n2\n\n * 直接存储器存取DMA：\n\n外设->存储器\n外设<-存储器\n\n\n1\n2\n\n\nDMA传送中，CPU释放总线，由DMA控制器（8237 ）管理。\n\n2、DMA传送原理\n\n * CPU对DMA控制器8237进行初始化设置；\n * 外设、DMAC和CPU三者通过应答信号建立联系：CPU将总线给DMAC控制；\n * DMAC控制数据在内存和外设间传送送：\n   * DMA读存储器：存储器->外设\n   * DMA写存储器：存储器<-外设\n * 自动增减地址和计数，判断传送完成否。\n * 传送完成后8237归还CPU总线\n\n3、DMA传送过程\n\n * 外设向DMA发出请求；\n * DMAC向CPU申请总线（hold）；\n * CPU完成当前总线周期后响应（hlda），并释放总线控制权；\n * DMAC得到总线控制权，发出DMA响应信号；\n * 由DMAC发出读写控制信号，控制外设与存储器之间的数据传输；\n * 数据传送完成后，DMAC撤销HOLD信号；\n * CPU释放HLDA信号，并重新控制总线。\n\n总结：传送方式比较\n\n * 无条件传送：慢速外设需要与CPU保持同步。\n * 查询传送：简单使用，CPU效率较低。\n * 中断传送：外设主动、实时性高，与CPU并行工作，CPU效率高，但每次传送需要大量额外时间开销，适用于中慢速外设。\n * DMA传送：传送过程中由专门硬件DMAC控制，不需要CPU介入，外设直接和主存进行数据传送，适合大量、快速数据传送。\n\n\n# 可编程并行接口芯片8255A\n\n\n# 并行通信\n\n * 以计算机的字长（8位、16位或32位）为传输单位，一次传送一个字长的数据。\n * 适合外部设备与微机之间进行近距离、大量和快速的信息交换。\n\n\n# 一、8255A的内部结构和引脚：\n\n * 3个8位端口：端口A、端口B、端口C\n * 3种工作方式：方式0、方式1、方式2\n * 4个端口地址：端口A、端口B、端口C、控制口，地址\n * 2个控制字：\n   * 方式控制字：\n   * C口的按位置位/复位字：\n\n1、与外设连接的端口\n\n端口A：PA0-PA7\n\t- 常作数据端口，共能最强大，\n\t- 支持工作方式0、1、2\n端口B：PB0-PB7\n\t- 常作数据端口，支持工作方式0、1\n端口C:PC0-PC7\n\t- 可作数据、状态、和控制端口\n\t- 分两个4位、每位可独立操作\n\t- 仅支持工作方式0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、处理器连接的引脚\n\n * 数据线：8条\n * 地址线：2条，A0、A1\n * CS片选信号\n * RD读信号\n * WR写信号\n * RESET复位信号\n\n3、8255的四个端口地址\n\nCS   A1   A0   读操作RD   写操作WR\n0    0    0    读端口A    写端口A\n0    0    1    读端口B    写端口B\n0    1    0    读端口C    写端口C\n0    1    1    非法      写控制口\n\n\n# 二、8255A的工作方式\n\n1、三种工作方式\n\n * 方式0：基本输入输出方式\n   * 适用于 无条件传送和查询方式的接口电路\n * 方式1：选通输入输出方式\n   * 适用于 查询方式和中断方式的接口电路\n * 方式2：双向选通输入传送方式\n   * 适用于 查询方式和中断方式的接口电路\n\n2、方式0：基本I/O方式\n\n * 通常不用联络信号或不使用固定的联络信号；\n * PA、PB和两个4位PC都可以作为数据的入/出（由程序设定）；\n * 方式0适于无条件传送和查询传送；\n * 输入时，使用IN指令；输出时，使用OUT指令\n\n方式1：选通I/O方式\n\n * 通常使用固定联络信号；\n * 适于查询和中断方式；\n * 可以产生中断；\n * 一般作为中断方式I/O\n * 输入时，使用IN指令；输出时，使用OUT指令\n\n方式2：双向方式\n\n * 方式2可以同时发送数据和接收数据\n * 只有端口A可以工作于方式2\n * 需要利用端口C的信号线\n\n\n# 三、8255A的编程\n\n1、编程步骤：\n\n * 根据题意明确三个端口的工作方式和方向\n * 确定两个字：方式控制字、置位/复位字\n * 确定4个端口地址：依次A、B、C、控制口\n * 8255的初始化编程：两个字送到控制端口\n * 8255的功能驱动编程。\n\n2、方式控制字格式\n\nD7   功能\n1    标志位\n\nD6   D5   功能\n0    0    A口方式0\n0    1    A口方式1\n1    0    A口方式2\n1    1    A口方式2\n\nD4   功能\n0    A口输出\n1    A口输入\n\nD3   功能\n0    PC7-PC4输出\n1    PC7-PC4输入\n\nD2   功能\n0    B口方式0\n1    B口方式1\n\nD1   功能\n0    B口输出\n1    B口输入\n\nD0   功能\n0    PC3-PC0输出\n1    PC3-PC0输入\n\n3、C口的置位/复位字\n\nD7   功能\n0    标志位\n\nD6   D5   D4   功能\nx    x    x    未用\n\nD3   D2   D1   选择C口的位\n0    0    0    PC0\n0    0    1    PC1\n0    1    0    PC2\n0    1    1    PC3\n1    0    0    PC4\n1    0    1    PC5\n1    1    0    PC6\n1    1    1    PC7\n\nD0   功能\n0    选择的位 置 0\n1    选择的位 置 1\n\n\n# 串行通信基础\n\n\n# 一、概念\n\n1、串行通信\n\n * 定义：将数据以二进制位形式用一条信号线，一位一位顺序传送的方式；\n\n * 特点：用于通信的线路少，适用于远距离数据传送，也常用于速度要求不高的近距离数据传送；\n\n * 应用：PC系列机上有两个串行异步通信接口、键盘、鼠标与主机间采用串行数据传送；\n\n2、异步通信\n\n * 串行通信时的数据、控制和状态信息都使用同一根信号线传送；\n * 收发双方必须遵守共同的通信协议（规程），才能解决传送速率、信息格式、同步、校验等问题；\n * 串行异少通信以宇符为单位进行传输，其通信协议是起止式异步通信协议。\n\n协议格式：\n\n1位起始位：0\n8位数据位：0/1\n1位奇偶校验位：0/1\t\n\t偶校验：包括校验位在内1的个数是偶数个\n\t奇校验：包括校验位在内1的个数是及数个\n两位停止位：11\n一帧：12位\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n数据传输率（比特率Bit Rate）\n\n * 定义：每秒传输的二进制位数（bps）\n   * 单位：波特 或 bit/s\n * 数据传输速率的倒数：每个二进制位传输的时间\n * 采用二进制传输时，比特率等于波特率\n * 串行异步通信的数据传输速率在50bps到9600bps之间。高达115200bps或更高。\n\n波特因子\n\n * 接收器或发送器的频率/数据传输的波特率\n\n * 在8251（可编程串行接口）芯片中有三种：1、16、64\n\n3、同步通信\n\n * 以一个数据块（帧）为传输单位，每一个数据块附加1个或2个同步字符，最后以检验字符结束。\n * 同步通信的数据传输效率和传输速率较高，但硬件电路比较复杂\n\n数据格式：同步字符 8位数据 校验字符\n\n4、传输制式\n\n * 全双工：可双向同时通信 —> <—\n * 半双工：可双向异步通信 <—>\n * 单共：只可单方向通信 —>\n\n\n# 二、通用异步接收发送器UART（8251、8250）\n\n * 串行异步通信的接口芯片\n * 串行传输，需要并行到串行、串行到并行的转换，\n * 按照传输协议发送和接收每个字符（或数据块）\n\n1、8250\n\n * 8250实现了起止式串行异步通信协议，支持全双工通信\n   * 数据位为5—8位\n   * 停止位1、1.5或2位\n   * 奇偶奇偶校验1位\n   * 具有奇偶、帧和溢出错误检测电路\n * 8250支持的数据传输速率为50—9600bps\n\n\n# 控制器芯片\n\n\n# 一、中断控制器8259A\n\n * 可编程中断控制器PIC\n * 用于管理Intel 8086/8088、80286/80386的可屏蔽中断\n * 8259A的基本功能：\n   * 一片8259A可以管理8级中断，可扩展至64级\n   * 每一级中断都可单独被屏蔽或允许\n   * 在中断响应周期，可提供相应的中断向量号\n   * 8259A有多种工作方式，可以通过编程选择\n\n1、内部寄存器\n\n * 中断请求寄存器IRR：IR0—IR7\n * 中断服务寄存器ISR：ISR0—ISR7\n * 中断屏蔽寄存器IMR：IMR0—IMR7\n\n2、与处理器接口\n\nA0   RD(低电平有效)   WR(低电平有效)   CS(低电平有效)   功能\n0    1           0           0           写入ICW1、OCW2和OCW3\n1    1           0           0           写入ICW2—ICW4和OCW1\n0    0           1           0           读IRR、ISR和查询字\n1    0           1           0           读出IMR\n\n3、中断级连\n\n * 8259A可以级联，一片8259A，可以级联最多8片从8259A；\n * 级联时，主8259A的CAS0-CAS2为输出线，连至从8259A的CAS0-CAS2，主片给从片送上被响应的从片编号;\n * 从8259A的INT，连主8259A的IR；\n * 主8259A的INT线连至CPU的INTR；\n * SP/EN在非缓冲方式下，SP=1时，8259A是主片；SP=0时，8259A是从片。\n * 地址线A0连接到各片8259上的A0口。\n\n\n# 二、8259A的中断过程\n\n书P409页\n\n\n# 三、8259A的工作方式\n\n1、设置优先权方式\n\n * 普通全嵌套方式\n\n>  * 8259A的中断优先权顺序固定不变，从高到低依次为IR0>……>IR7\n>  * 中断请求后，8259A响应最高优先级，ISR对应位置=1，直到中断结束，ISR的位复位=0；\n>  * 在ISR期间，禁止同级和低级优先权的中断，但允许高级优先权中断嵌套。\n\n * 特殊全嵌套方式\n\n> CPU正在处理某一级中断时，只可对本级中断进行屏蔽，允许比它高或比它低的中断源开放。\n\n * 优先权自动循环方式\n\n>  * 初始优先级顺序为IR0最高、IR7最低；\n>  * 当某一个中断源收到服务后，它的优先级改为最低，而比它低一级的中断源为最高优先级，其他级别依次类推。\n\n * 优先权特殊循环方式\n\n> 与优先级自动循环方式基本相同，不同点在于可以根据用户要求将最低优先级赋予某一中断源。\n\n2、结束中断处理方式\n\n什么是8259A的中断结束？\n\n> 8259A利用中断服务寄存器ISR判断：\n> \n>  * 某位为1，表示正在进行中断服务；\n>  * 该位为0，就是该中断结束服务；\n\n如何使ISR某位为0：\n\n * 自动中断结束方式\n\n> 当前CPU执行完某一个中断请求后ISR对应=0\n\n * 一般（普通）中断结束方式\n\n>  * 配合全嵌套优先权方式使用\n>  * 当CPU往8259A发中断结束命令时，8259A就会把所有正在服务的中断优先权最高的ISR位复位。\n\n * 特殊结束方式\n\n>  * 配合循环优先权方式使用\n>  * CPU向8259A发送一条特殊中断结束命令，指出要清除哪个ISR位。\n\n3、屏蔽中断源方式\n\n * 普通屏蔽方式\n\n>  * 只允许高优先级的中断源请求\n> \n>  * 不允许同级别或低级别的中断源\n\n * 特殊屏蔽方式\n\n>  * 将IMR的Di位置1，使用ISR的Di位置0\n>  * 只对本级中断进行屏蔽\n\n4、中断请求方式\n\n * 边沿触发方式\n\n> 中断请求输入出现的上升沿作为中断请求信号。不能跳变。\n\n * 电平触发方式\n\n> 中断请求端的高电平是有效的中断请求信号。响应后，必须撤销信号。\n\n * 中断查询方式\n\n> IF=0（关中断），查询IR0—IR7有无中断请求。\n\n5、数据线连接方式\n\n * 缓冲方式\n\n>  * 8259A的数据线需加缓冲器（驱动器）予以驱动\n>  * 多片级联的系统\n\n * 非缓冲方式\n\n>  * SP/EN引脚为输入端\n>  * 8259直接和数据线相连\n>  * 用于单片，引脚接高电平\n>  * 级联时，由于引脚确定是主片（高）或从片（低）\n\n\n# 四、8259A的编程\n\n\n# 初始化编程\n\n * 8259A开始工作前，必须进行初始化编程\n * 给8259A写入初始化命令字ICW。\n\n1、初始化命令字ICW\n\n * 初始化命令字ICW最多有4个；\n * 必须按照ICW1-ICW4的顺序写入；\n * ICW1和ICW2是必须送的；\n * ICW3用于级联；\n * ICW4用于8088/8086\n\nICW1\n\n * LTIM：触发方式\n * ADI：服务程序间隔\n * A0=0\n\n位    D7   D6   D5   D4   D3（LTIM）   D2（ADI）   D1（SNGL）   D0（IC4）\n     X    X    X    1    0          0         0          0\n功能   未用   未用   未用        边沿触发       间隔为8      多片使用       不需要ICW4\n     X    X    X    1    1          1         1          1\n功能   未用   未用   未用        电平触发       间隔为4      单片使用       需要ICW4\n\nICW2\n\n * A0=1\n * D7-D3：由用户决定（中断类型号高5位）\n * D2-D0：由中断源引脚程序决定（IR0-IR7）\n\nICW3\n\n * 主8259A\n\n>  * A0=1\n>  * D7-D0：为1的位（该引脚有从片）；为0的位（该引脚未接有从片）\n\n * 从8259A\n\n>  * A0=1\n>  * D7-D3：未用（默认按0）\n>  * D2-D0：接主片的（IR0-IR7分别对应000-111）\n\nICW4\n\n * A0=1；\n * D7-D5：未用（默认为0）；\n * SFNM：嵌套方式选择；BUF：方式选择；M/S：主从选择；AEDI：结束方式；UPM：系统选择；\n\n位    D4（SFNM）   D3（BUF）   D2（M/S）   D1（AEDI）   D0（UPM）\n     0          0         0         0          0\n功能   普通全嵌套      非缓冲方式     本片为从片     正常EOI      8080/8085\n     1          1         1         1          1\n功能   特殊全嵌套      缓冲方式      本片为主片     自动EOI      8086/8088\n\n2、操作命令字OCW\n\n * 8259A工作期间，可以接受操作命令字OCW；\n * OCW共有三个：OCW1-OCW3；\n * 写入时没有顺序要求，需要哪个OCW就写入那个OCW；\n\n中断屏蔽操作字：OCW1\n\n * A0=1，写入奇地址\n * 内容写入中断屏蔽寄存器IMR\n * Mi对应IRi，为 1 禁止IRi中断、为 0 允许IRi中断；\n\n优先级循环和中断结束命令操作字：OCW2\n\n * A0=0，写入偶地址\n\nD7（R）   D6（SL）   D5（EOI）   功能\n0       0        0         清除优先级自动循环命令\n0       0        1         普通EOI方式\n0       1        0         无操作\n0       1        1         特殊EOI方式\n1       0        0         设置优先级自动循环命令\n1       0        1         自动循环普通EOI方式\n1       1        0         设置优先权命令\n1       1        1         自动循环特殊EOI方式\n\n * D4、D3为 0（标志位）\n * D2-D0：分别对应IR0-IR7\n\n设置特殊屏蔽方式命令字：OCW3\n\n * A0=0，写入偶地址\n * D7为 0\n\nD6（ESMM）   功能\n0          不允许特殊屏蔽方式\n1          允许特殊屏蔽方式\n\nD5（SMM）   功能\n0         撤销特殊屏蔽方式\n1         设置特殊屏蔽方式\n\n * D4=0，D3=1（标志位）\n\nD2（P）   功能\n0       非查询命令\n1       查询命令\n\nD1（RR）   功能\n0        不发读命令\n1        发读命令\n\nD0（RIS）   功能\n0         读IRR\n1         读ISR\n\n\n# 定时/计数控制器8253\n\n\n# 一、定时/计数器原理\n\n * 定时器：由计数电路构成，通过记录高精度晶振脉冲信号的个数，输出准确的时间间隔。\n * 计数器：计数电路如果记录外设提供的具有一定随机性的脉冲信号时，它主要反映脉冲的个数。\n * 均采用减一计数的倒计数原理，每过一个clk周期计算器减一。\n\n软件延时\n\n * 利用CPU执行一个延时程序实现；\n * 不用硬件，但占用CPU时间、定时精度不高，随系统主频改变。\n\n可编程的硬件定时\n\n * 软件硬件结合、可编程定时芯片\n * 能够输出多种控制信号\n\n\n# 二、8253的内部结构和引脚\n\n1、原理\n\n * 2种计数制：按二进制或BCD码计数\n * 3个独立的16位计数器\n * 4个端口地址\n * 6种工作方式\n\n2、结构\n\n书P418\n\n3、引脚\n\n * CLK：时钟输入信号（Fclk，Tclk）\n * GATE：们控输入信号\n   * 控制计数器是否计数\n   * 两种：电平控制和上升沿控制\n * OUT：计数器输出信号\n   * 当计数值减为0，OUT引脚上产生一个输出信号。（Fout，Tout）\n\n4、与处理器接口\n\n * 数据线：8位\n * 地址线：2位（A0、A1）\n * CS片选\n * RD读信号\n * WR写信号\n\n5、8253的I/O地址：4个\n\nCS   RD   WR   A1   A0   功能\n0    1    0    0    0    对计数器 0 设置计数初值\n0    1    0    0    1    对计数器 1 设置计数初值\n0    1    0    1    0    对计数器 2 设置计数初值\n0    1    0    1    1    设置控制字到控制口\n0    0    1    0    0    从计数器 0 读出计数值\n0    0    1    0    1    从计数器 1 读出计数值\n0    0    1    1    0    从计数器 2 读出计数值\n\n\n# 三、8253的工作方式\n\n8253有6种工作方式，由方式控制字确定\n\n1、工作方式类型：\n\n * 方式0：计数结束中断\n\n * 方式1：可编程单稳脉冲\n\n * 方式2：频率发生器（分频器）\n\n * 方式3：方波发生器\n\n * 方式4：软件触发选通信号\n\n * 方式5：硬件触发选通信号\n\n2、工作方式特点：\n\n * 只有方式 2 和 3 为自动装入初值循环计数；\n * 方式 1 和 5 由外部gate上升沿触发启动计数器；\n * 方式 0 - 4 为计数值启动后，开始计数；\n * 方式 1 的输出波形全为负电平：Tout=N*Tclk\n * 方式 2 的输出波形：Tout中有一个Tclk的负电平\n * 方式 3 初值N为偶数：N/2*Tout的高（低）电平\n   * 初值N为奇数：（N+1）/2*Tout的高（低）电平\n\n\n# 四、8253的编程\n\n1、确定8253的4个端口地址；\n\n2、确定CPU写入8253的初值和计数制（二进制0-65535、BCD码0-9999）\n\n3、确定CPU写入8253的方式控制字\n\n4、编写8253的初始化程序段\n\n方式控制字\n\nD7   D6   功能\n0    0    选择计数器0\n0    1    选择计数器1\n1    0    选择计数器2\n1    1    非法\n\nD5   D4   功能\n0    0    计数器锁存命令\n0    1    只读写低字节\n1    0    只读写高字节\n1    1    先读写低字节，再读写高字节\n\n * D3-D1：对应6种工作方式\n * D0：为0选择二进制计数方式；为1选择BCD计数方式\n\n初值计算\n\n初值（N）=Tout/Tclk=Fclk/Fout\n\n> Tclk=1/Fclk\n\n\n# DMA控制器8237A\n\n\n# 一、8237 DMA概述\n\n为了提高数据传送效率，提出了DMA数据传送控制方式，由DMA控制器取代CPU，获得CPUD总线控制权，实现 内存与外设 或 内存的不同区域之间 或者 外设与外设 大量数据的快速传送。\n\n用于：图像的显示、磁盘的存取，磁盘间的数据传送等。\n\n\n# 二、8237 DMA数据传送的工作过程\n\n书：p427(图8-16)\n\n * 接收从外设发出的DMA请求，并向CPU发出总线请求信号。\n * 当CPU响应请求，发出HLDA后，DMA控制器能接管对总线的控制，进入DMA操作方式。\n * 发出存储器地址，确定数据传送的地址单元，并能自动修改地址指针。\n * 识别数据传送的方向，发出读或写控制信号。\n * 确定传送数据的个数，判断传送是否结束。\n * 发出DMA操作的结束信号。\n\n需要注意的是：\n\n> 在内存与外设之间进行DMA传送期间，DMAC控制器只是输出地址及控制信号，而数据传送是直接在内存和外设端口之间进行的，并不是经过DMAC。\n\n\n# 三、DMA控制器8237A\n\n * 每个8237A芯片由4个DMA通道，即有4个DMA控制器；\n * 每个DMA通道具有不同的优先权；\n * 每个DMA通道可以分别允许和禁止\n * 每个DMA通道有四种工作方式\n * 一次传输的最大长度可达64KB\n\n1、8237A的工作方式\n\n * DMA传送方式\n\n>  * 单字节传送方式\n>  * 数据块传送方式\n>  * 请求级联方式\n>  * 级联方式\n\n * DMA传送类型\n\n>  * DMA读：读存储器—>外设\n>  * DMA写：外设—>存储器\n>  * DMA检验：",normalizedContent:"# 输入输出系统接口芯片\n\n\n# 输入输出（i/o）接口概念\n\n一、i/o接口概念\n\n1、为什么需要i/o接口（电路）？\n\n * 微机的外部设别多种多样\n * 工作原理、信息格式、工作速度等方面差别很大\n * 外设不能与cpu直接向相连\n * 必须经过中间电路再与系统相连\n\n2、什么是i/o接口电路？\n\n * i/o接口是位于系统与外设间、用来协助完成数据传送和控制任务的逻辑电路；\n * 可编程接口芯片、i/o总线槽的电路板（适配器）都是接口电路。\n\n3、i/o接口的主要功能\n\n * 速度匹配、数据缓冲；\n * 数据格式的转换；\n * 对i/o端口寻址、地址译码；\n * cpu与外设信息联络；\n * 设置中断和dma控制逻辑\n\n4、端口（port）\n\n * 泛指i/o地址，对应接口电路的寄存器；\n * 一个接口电路可以具有多个i/o端口（寄存器）\n * 数据端口、状态端口和控制端口：用于保存数据、状态信息\n\n二、i/o接口的典型结构\n\n1、接口结构\n\n2、i/o接口组成\n\n接口由硬件和软件组成。\n\n接口软件有两类：\n\n * 初始化程序段：\n   * 设备驱动程序、设定芯片工作方式等\n * 数据交换程序段：\n   * 管理、控制、驱动外设，负责和系统间信息交换。\n\n三、i/o端口的编址\n\n两类编址\n\n * i/o端口单独编址（独立编址）：\n   * i/o地址空间独立于存储地址空间，内存与i/o空间各自独立\n   * 如：8086/8088\n * i/o端口与存储器统一编址：\n   * 他们共享一个地址空间，内存与i/o空间共用\n   * 如：m6800\n\n独立编址：\n\n优点：\n- i/o端口的地址空间独立\n- 控制和地址译码电路简单\n- 专门的i/o指令\n缺点：\n- i/o指令种类少\n- 空间少\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n统一编址：\n\n优点：\n- 不需要专门的i/o指令\n- i/o数据存取灵活\n缺点：\n- i/o端口要占去部分存储器地址空间\n- 程序不易阅读（不易分清访问存储器和访问外设）\n\n\n1\n2\n3\n4\n5\n6\n\n\n四、88/86的输入输出指令\n\n1、i/o端口地址\n\n * 外设的端口（port），即i/o地址。\n * 88/86用于寻址外设端口的地址线为16条，\n * 端口最多为2的16次方=65536（64kb）个，\n * 端口号为：0000h-ffffh\n\n2、i/o端口寻址方式\n\n88/86的端口有64kb，不分段，两种寻址方式：\n\n * 直接寻址：\n   * 只寻址00h-ffh前256个端口号\n   * 指令中操作数直接使用端口号；\n * 间接寻址：\n   * 可寻址全部64k个端口号：0000h-ffffh\n   * dx寄存器的值存放端口号；\n   * 0100h-ffffh的端口只能采用间接寻址方式。\n\n3、输入指令\n\n将外设数据传送给cpu内的al/ax：\n\n * in al,端口地址\n * in al,dx/i8 ;字节输入\n * in ax,dx/i8 ;字输入\n\n4、输出指令\n\n将cpu内的al/ax数据传送给外设：\n\n * out 端口地址,al/ax\n * out dx/i8,al ;字节输出\n * out dx/i8,ax ;字输出\n\n五、i/o地址的译码\n\n * 门电路：接口电路只占少量i/o地址，可以利用线选法地址译码。\n * 译码器：选用2：4译码器或3：8译码器进行\n\n1、逻辑门电路进行i/o地址译码\n\n\n# 数据传送方式\n\n * 程序控制的数据传送：cpu执行程序中i/o指令完成传送，分为：无条件传送、查询传送、中断传送。\n * 直接存储器存取（dma）：\n   * 硬件芯片8237；\n   * dmac利用系统总线在外设和主存间传送。\n * i/o处理机实现数据传送：\n   * 协处理器8089：数据输入/出\n   * cpu委托专门的i/o处理机来完成数据传送。\n\n\n# 一、无条件传送方式（同步）\n\n1、原理：\n\n * cpu与慢速外设交换数据；\n * 外设处于“就绪”状态，随时可以进行数据传送，亦称同步传送；\n * 适用于简单设备，如：led数码管，按键等；\n * 传送条件：外设必须随时就绪。\n\n\n# 二、查询传送方式（异步）\n\n1、原理\n\n * cpu先查询外设的工作状态，\n * 在外设就绪时，实现数据输入或输出；\n * 查询传送的特点是：工作可靠，但传送效率低。\n\n2、查询传送的两个环节\n\n * 查询\n   * 寻址状态口\n   * 读取状态端口的状态位；\n   * 若无就绪就继续查询；\n * 传送\n   * 外设就绪后，寻址数据口\n   * 输入：in指令从数据端口读入数据\n   * 输出：out指令向数据端口输出数据\n\n\n# 三、中断传送方式：int 21h\n\n1、用中断服务子程序实现\n\n2、特点：\n\n * 是一种效率较高的程序传送方式；\n * 中断服务程序是预先设计好的；\n * cpu在每条指令周期后采样中断请求输入信号；\n * 外设需要传输数据时，主动向cpu提出中断请求，提高实时性；\n * 外设准备数据和cpu执行程序并行工作，提高cpu效率；\n * 每传输一次数据就要中断一次，需保护断点和现场；\n * 需要中断控制器8259芯片；\n * 适合少量数据、中慢速外设的数据传送，如鼠标、键盘。\n\n3、中断过程：\n\n1、中断请求（外设）\n2、中断响应（cpu）\n3、关中断（cpu）\n4、断点保护（cpu）\n5、识别中断源（硬件/软件）\n6、现场保护（用户）\n7、中断服务：数据交换\n8、恢复现场（用户）\n9、开中断（cpu/用户）\n10、中断fan'hui\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 四、dma传送方式\n\n1、特点：\n\n * 克服程序控制传输的不足\n\n外设->cpu->存储器\n外设<-cpu<-存储器\n\n\n1\n2\n\n * 直接存储器存取dma：\n\n外设->存储器\n外设<-存储器\n\n\n1\n2\n\n\ndma传送中，cpu释放总线，由dma控制器（8237 ）管理。\n\n2、dma传送原理\n\n * cpu对dma控制器8237进行初始化设置；\n * 外设、dmac和cpu三者通过应答信号建立联系：cpu将总线给dmac控制；\n * dmac控制数据在内存和外设间传送送：\n   * dma读存储器：存储器->外设\n   * dma写存储器：存储器<-外设\n * 自动增减地址和计数，判断传送完成否。\n * 传送完成后8237归还cpu总线\n\n3、dma传送过程\n\n * 外设向dma发出请求；\n * dmac向cpu申请总线（hold）；\n * cpu完成当前总线周期后响应（hlda），并释放总线控制权；\n * dmac得到总线控制权，发出dma响应信号；\n * 由dmac发出读写控制信号，控制外设与存储器之间的数据传输；\n * 数据传送完成后，dmac撤销hold信号；\n * cpu释放hlda信号，并重新控制总线。\n\n总结：传送方式比较\n\n * 无条件传送：慢速外设需要与cpu保持同步。\n * 查询传送：简单使用，cpu效率较低。\n * 中断传送：外设主动、实时性高，与cpu并行工作，cpu效率高，但每次传送需要大量额外时间开销，适用于中慢速外设。\n * dma传送：传送过程中由专门硬件dmac控制，不需要cpu介入，外设直接和主存进行数据传送，适合大量、快速数据传送。\n\n\n# 可编程并行接口芯片8255a\n\n\n# 并行通信\n\n * 以计算机的字长（8位、16位或32位）为传输单位，一次传送一个字长的数据。\n * 适合外部设备与微机之间进行近距离、大量和快速的信息交换。\n\n\n# 一、8255a的内部结构和引脚：\n\n * 3个8位端口：端口a、端口b、端口c\n * 3种工作方式：方式0、方式1、方式2\n * 4个端口地址：端口a、端口b、端口c、控制口，地址\n * 2个控制字：\n   * 方式控制字：\n   * c口的按位置位/复位字：\n\n1、与外设连接的端口\n\n端口a：pa0-pa7\n\t- 常作数据端口，共能最强大，\n\t- 支持工作方式0、1、2\n端口b：pb0-pb7\n\t- 常作数据端口，支持工作方式0、1\n端口c:pc0-pc7\n\t- 可作数据、状态、和控制端口\n\t- 分两个4位、每位可独立操作\n\t- 仅支持工作方式0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、处理器连接的引脚\n\n * 数据线：8条\n * 地址线：2条，a0、a1\n * cs片选信号\n * rd读信号\n * wr写信号\n * reset复位信号\n\n3、8255的四个端口地址\n\ncs   a1   a0   读操作rd   写操作wr\n0    0    0    读端口a    写端口a\n0    0    1    读端口b    写端口b\n0    1    0    读端口c    写端口c\n0    1    1    非法      写控制口\n\n\n# 二、8255a的工作方式\n\n1、三种工作方式\n\n * 方式0：基本输入输出方式\n   * 适用于 无条件传送和查询方式的接口电路\n * 方式1：选通输入输出方式\n   * 适用于 查询方式和中断方式的接口电路\n * 方式2：双向选通输入传送方式\n   * 适用于 查询方式和中断方式的接口电路\n\n2、方式0：基本i/o方式\n\n * 通常不用联络信号或不使用固定的联络信号；\n * pa、pb和两个4位pc都可以作为数据的入/出（由程序设定）；\n * 方式0适于无条件传送和查询传送；\n * 输入时，使用in指令；输出时，使用out指令\n\n方式1：选通i/o方式\n\n * 通常使用固定联络信号；\n * 适于查询和中断方式；\n * 可以产生中断；\n * 一般作为中断方式i/o\n * 输入时，使用in指令；输出时，使用out指令\n\n方式2：双向方式\n\n * 方式2可以同时发送数据和接收数据\n * 只有端口a可以工作于方式2\n * 需要利用端口c的信号线\n\n\n# 三、8255a的编程\n\n1、编程步骤：\n\n * 根据题意明确三个端口的工作方式和方向\n * 确定两个字：方式控制字、置位/复位字\n * 确定4个端口地址：依次a、b、c、控制口\n * 8255的初始化编程：两个字送到控制端口\n * 8255的功能驱动编程。\n\n2、方式控制字格式\n\nd7   功能\n1    标志位\n\nd6   d5   功能\n0    0    a口方式0\n0    1    a口方式1\n1    0    a口方式2\n1    1    a口方式2\n\nd4   功能\n0    a口输出\n1    a口输入\n\nd3   功能\n0    pc7-pc4输出\n1    pc7-pc4输入\n\nd2   功能\n0    b口方式0\n1    b口方式1\n\nd1   功能\n0    b口输出\n1    b口输入\n\nd0   功能\n0    pc3-pc0输出\n1    pc3-pc0输入\n\n3、c口的置位/复位字\n\nd7   功能\n0    标志位\n\nd6   d5   d4   功能\nx    x    x    未用\n\nd3   d2   d1   选择c口的位\n0    0    0    pc0\n0    0    1    pc1\n0    1    0    pc2\n0    1    1    pc3\n1    0    0    pc4\n1    0    1    pc5\n1    1    0    pc6\n1    1    1    pc7\n\nd0   功能\n0    选择的位 置 0\n1    选择的位 置 1\n\n\n# 串行通信基础\n\n\n# 一、概念\n\n1、串行通信\n\n * 定义：将数据以二进制位形式用一条信号线，一位一位顺序传送的方式；\n\n * 特点：用于通信的线路少，适用于远距离数据传送，也常用于速度要求不高的近距离数据传送；\n\n * 应用：pc系列机上有两个串行异步通信接口、键盘、鼠标与主机间采用串行数据传送；\n\n2、异步通信\n\n * 串行通信时的数据、控制和状态信息都使用同一根信号线传送；\n * 收发双方必须遵守共同的通信协议（规程），才能解决传送速率、信息格式、同步、校验等问题；\n * 串行异少通信以宇符为单位进行传输，其通信协议是起止式异步通信协议。\n\n协议格式：\n\n1位起始位：0\n8位数据位：0/1\n1位奇偶校验位：0/1\t\n\t偶校验：包括校验位在内1的个数是偶数个\n\t奇校验：包括校验位在内1的个数是及数个\n两位停止位：11\n一帧：12位\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n数据传输率（比特率bit rate）\n\n * 定义：每秒传输的二进制位数（bps）\n   * 单位：波特 或 bit/s\n * 数据传输速率的倒数：每个二进制位传输的时间\n * 采用二进制传输时，比特率等于波特率\n * 串行异步通信的数据传输速率在50bps到9600bps之间。高达115200bps或更高。\n\n波特因子\n\n * 接收器或发送器的频率/数据传输的波特率\n\n * 在8251（可编程串行接口）芯片中有三种：1、16、64\n\n3、同步通信\n\n * 以一个数据块（帧）为传输单位，每一个数据块附加1个或2个同步字符，最后以检验字符结束。\n * 同步通信的数据传输效率和传输速率较高，但硬件电路比较复杂\n\n数据格式：同步字符 8位数据 校验字符\n\n4、传输制式\n\n * 全双工：可双向同时通信 —> <—\n * 半双工：可双向异步通信 <—>\n * 单共：只可单方向通信 —>\n\n\n# 二、通用异步接收发送器uart（8251、8250）\n\n * 串行异步通信的接口芯片\n * 串行传输，需要并行到串行、串行到并行的转换，\n * 按照传输协议发送和接收每个字符（或数据块）\n\n1、8250\n\n * 8250实现了起止式串行异步通信协议，支持全双工通信\n   * 数据位为5—8位\n   * 停止位1、1.5或2位\n   * 奇偶奇偶校验1位\n   * 具有奇偶、帧和溢出错误检测电路\n * 8250支持的数据传输速率为50—9600bps\n\n\n# 控制器芯片\n\n\n# 一、中断控制器8259a\n\n * 可编程中断控制器pic\n * 用于管理intel 8086/8088、80286/80386的可屏蔽中断\n * 8259a的基本功能：\n   * 一片8259a可以管理8级中断，可扩展至64级\n   * 每一级中断都可单独被屏蔽或允许\n   * 在中断响应周期，可提供相应的中断向量号\n   * 8259a有多种工作方式，可以通过编程选择\n\n1、内部寄存器\n\n * 中断请求寄存器irr：ir0—ir7\n * 中断服务寄存器isr：isr0—isr7\n * 中断屏蔽寄存器imr：imr0—imr7\n\n2、与处理器接口\n\na0   rd(低电平有效)   wr(低电平有效)   cs(低电平有效)   功能\n0    1           0           0           写入icw1、ocw2和ocw3\n1    1           0           0           写入icw2—icw4和ocw1\n0    0           1           0           读irr、isr和查询字\n1    0           1           0           读出imr\n\n3、中断级连\n\n * 8259a可以级联，一片8259a，可以级联最多8片从8259a；\n * 级联时，主8259a的cas0-cas2为输出线，连至从8259a的cas0-cas2，主片给从片送上被响应的从片编号;\n * 从8259a的int，连主8259a的ir；\n * 主8259a的int线连至cpu的intr；\n * sp/en在非缓冲方式下，sp=1时，8259a是主片；sp=0时，8259a是从片。\n * 地址线a0连接到各片8259上的a0口。\n\n\n# 二、8259a的中断过程\n\n书p409页\n\n\n# 三、8259a的工作方式\n\n1、设置优先权方式\n\n * 普通全嵌套方式\n\n>  * 8259a的中断优先权顺序固定不变，从高到低依次为ir0>……>ir7\n>  * 中断请求后，8259a响应最高优先级，isr对应位置=1，直到中断结束，isr的位复位=0；\n>  * 在isr期间，禁止同级和低级优先权的中断，但允许高级优先权中断嵌套。\n\n * 特殊全嵌套方式\n\n> cpu正在处理某一级中断时，只可对本级中断进行屏蔽，允许比它高或比它低的中断源开放。\n\n * 优先权自动循环方式\n\n>  * 初始优先级顺序为ir0最高、ir7最低；\n>  * 当某一个中断源收到服务后，它的优先级改为最低，而比它低一级的中断源为最高优先级，其他级别依次类推。\n\n * 优先权特殊循环方式\n\n> 与优先级自动循环方式基本相同，不同点在于可以根据用户要求将最低优先级赋予某一中断源。\n\n2、结束中断处理方式\n\n什么是8259a的中断结束？\n\n> 8259a利用中断服务寄存器isr判断：\n> \n>  * 某位为1，表示正在进行中断服务；\n>  * 该位为0，就是该中断结束服务；\n\n如何使isr某位为0：\n\n * 自动中断结束方式\n\n> 当前cpu执行完某一个中断请求后isr对应=0\n\n * 一般（普通）中断结束方式\n\n>  * 配合全嵌套优先权方式使用\n>  * 当cpu往8259a发中断结束命令时，8259a就会把所有正在服务的中断优先权最高的isr位复位。\n\n * 特殊结束方式\n\n>  * 配合循环优先权方式使用\n>  * cpu向8259a发送一条特殊中断结束命令，指出要清除哪个isr位。\n\n3、屏蔽中断源方式\n\n * 普通屏蔽方式\n\n>  * 只允许高优先级的中断源请求\n> \n>  * 不允许同级别或低级别的中断源\n\n * 特殊屏蔽方式\n\n>  * 将imr的di位置1，使用isr的di位置0\n>  * 只对本级中断进行屏蔽\n\n4、中断请求方式\n\n * 边沿触发方式\n\n> 中断请求输入出现的上升沿作为中断请求信号。不能跳变。\n\n * 电平触发方式\n\n> 中断请求端的高电平是有效的中断请求信号。响应后，必须撤销信号。\n\n * 中断查询方式\n\n> if=0（关中断），查询ir0—ir7有无中断请求。\n\n5、数据线连接方式\n\n * 缓冲方式\n\n>  * 8259a的数据线需加缓冲器（驱动器）予以驱动\n>  * 多片级联的系统\n\n * 非缓冲方式\n\n>  * sp/en引脚为输入端\n>  * 8259直接和数据线相连\n>  * 用于单片，引脚接高电平\n>  * 级联时，由于引脚确定是主片（高）或从片（低）\n\n\n# 四、8259a的编程\n\n\n# 初始化编程\n\n * 8259a开始工作前，必须进行初始化编程\n * 给8259a写入初始化命令字icw。\n\n1、初始化命令字icw\n\n * 初始化命令字icw最多有4个；\n * 必须按照icw1-icw4的顺序写入；\n * icw1和icw2是必须送的；\n * icw3用于级联；\n * icw4用于8088/8086\n\nicw1\n\n * ltim：触发方式\n * adi：服务程序间隔\n * a0=0\n\n位    d7   d6   d5   d4   d3（ltim）   d2（adi）   d1（sngl）   d0（ic4）\n     x    x    x    1    0          0         0          0\n功能   未用   未用   未用        边沿触发       间隔为8      多片使用       不需要icw4\n     x    x    x    1    1          1         1          1\n功能   未用   未用   未用        电平触发       间隔为4      单片使用       需要icw4\n\nicw2\n\n * a0=1\n * d7-d3：由用户决定（中断类型号高5位）\n * d2-d0：由中断源引脚程序决定（ir0-ir7）\n\nicw3\n\n * 主8259a\n\n>  * a0=1\n>  * d7-d0：为1的位（该引脚有从片）；为0的位（该引脚未接有从片）\n\n * 从8259a\n\n>  * a0=1\n>  * d7-d3：未用（默认按0）\n>  * d2-d0：接主片的（ir0-ir7分别对应000-111）\n\nicw4\n\n * a0=1；\n * d7-d5：未用（默认为0）；\n * sfnm：嵌套方式选择；buf：方式选择；m/s：主从选择；aedi：结束方式；upm：系统选择；\n\n位    d4（sfnm）   d3（buf）   d2（m/s）   d1（aedi）   d0（upm）\n     0          0         0         0          0\n功能   普通全嵌套      非缓冲方式     本片为从片     正常eoi      8080/8085\n     1          1         1         1          1\n功能   特殊全嵌套      缓冲方式      本片为主片     自动eoi      8086/8088\n\n2、操作命令字ocw\n\n * 8259a工作期间，可以接受操作命令字ocw；\n * ocw共有三个：ocw1-ocw3；\n * 写入时没有顺序要求，需要哪个ocw就写入那个ocw；\n\n中断屏蔽操作字：ocw1\n\n * a0=1，写入奇地址\n * 内容写入中断屏蔽寄存器imr\n * mi对应iri，为 1 禁止iri中断、为 0 允许iri中断；\n\n优先级循环和中断结束命令操作字：ocw2\n\n * a0=0，写入偶地址\n\nd7（r）   d6（sl）   d5（eoi）   功能\n0       0        0         清除优先级自动循环命令\n0       0        1         普通eoi方式\n0       1        0         无操作\n0       1        1         特殊eoi方式\n1       0        0         设置优先级自动循环命令\n1       0        1         自动循环普通eoi方式\n1       1        0         设置优先权命令\n1       1        1         自动循环特殊eoi方式\n\n * d4、d3为 0（标志位）\n * d2-d0：分别对应ir0-ir7\n\n设置特殊屏蔽方式命令字：ocw3\n\n * a0=0，写入偶地址\n * d7为 0\n\nd6（esmm）   功能\n0          不允许特殊屏蔽方式\n1          允许特殊屏蔽方式\n\nd5（smm）   功能\n0         撤销特殊屏蔽方式\n1         设置特殊屏蔽方式\n\n * d4=0，d3=1（标志位）\n\nd2（p）   功能\n0       非查询命令\n1       查询命令\n\nd1（rr）   功能\n0        不发读命令\n1        发读命令\n\nd0（ris）   功能\n0         读irr\n1         读isr\n\n\n# 定时/计数控制器8253\n\n\n# 一、定时/计数器原理\n\n * 定时器：由计数电路构成，通过记录高精度晶振脉冲信号的个数，输出准确的时间间隔。\n * 计数器：计数电路如果记录外设提供的具有一定随机性的脉冲信号时，它主要反映脉冲的个数。\n * 均采用减一计数的倒计数原理，每过一个clk周期计算器减一。\n\n软件延时\n\n * 利用cpu执行一个延时程序实现；\n * 不用硬件，但占用cpu时间、定时精度不高，随系统主频改变。\n\n可编程的硬件定时\n\n * 软件硬件结合、可编程定时芯片\n * 能够输出多种控制信号\n\n\n# 二、8253的内部结构和引脚\n\n1、原理\n\n * 2种计数制：按二进制或bcd码计数\n * 3个独立的16位计数器\n * 4个端口地址\n * 6种工作方式\n\n2、结构\n\n书p418\n\n3、引脚\n\n * clk：时钟输入信号（fclk，tclk）\n * gate：们控输入信号\n   * 控制计数器是否计数\n   * 两种：电平控制和上升沿控制\n * out：计数器输出信号\n   * 当计数值减为0，out引脚上产生一个输出信号。（fout，tout）\n\n4、与处理器接口\n\n * 数据线：8位\n * 地址线：2位（a0、a1）\n * cs片选\n * rd读信号\n * wr写信号\n\n5、8253的i/o地址：4个\n\ncs   rd   wr   a1   a0   功能\n0    1    0    0    0    对计数器 0 设置计数初值\n0    1    0    0    1    对计数器 1 设置计数初值\n0    1    0    1    0    对计数器 2 设置计数初值\n0    1    0    1    1    设置控制字到控制口\n0    0    1    0    0    从计数器 0 读出计数值\n0    0    1    0    1    从计数器 1 读出计数值\n0    0    1    1    0    从计数器 2 读出计数值\n\n\n# 三、8253的工作方式\n\n8253有6种工作方式，由方式控制字确定\n\n1、工作方式类型：\n\n * 方式0：计数结束中断\n\n * 方式1：可编程单稳脉冲\n\n * 方式2：频率发生器（分频器）\n\n * 方式3：方波发生器\n\n * 方式4：软件触发选通信号\n\n * 方式5：硬件触发选通信号\n\n2、工作方式特点：\n\n * 只有方式 2 和 3 为自动装入初值循环计数；\n * 方式 1 和 5 由外部gate上升沿触发启动计数器；\n * 方式 0 - 4 为计数值启动后，开始计数；\n * 方式 1 的输出波形全为负电平：tout=n*tclk\n * 方式 2 的输出波形：tout中有一个tclk的负电平\n * 方式 3 初值n为偶数：n/2*tout的高（低）电平\n   * 初值n为奇数：（n+1）/2*tout的高（低）电平\n\n\n# 四、8253的编程\n\n1、确定8253的4个端口地址；\n\n2、确定cpu写入8253的初值和计数制（二进制0-65535、bcd码0-9999）\n\n3、确定cpu写入8253的方式控制字\n\n4、编写8253的初始化程序段\n\n方式控制字\n\nd7   d6   功能\n0    0    选择计数器0\n0    1    选择计数器1\n1    0    选择计数器2\n1    1    非法\n\nd5   d4   功能\n0    0    计数器锁存命令\n0    1    只读写低字节\n1    0    只读写高字节\n1    1    先读写低字节，再读写高字节\n\n * d3-d1：对应6种工作方式\n * d0：为0选择二进制计数方式；为1选择bcd计数方式\n\n初值计算\n\n初值（n）=tout/tclk=fclk/fout\n\n> tclk=1/fclk\n\n\n# dma控制器8237a\n\n\n# 一、8237 dma概述\n\n为了提高数据传送效率，提出了dma数据传送控制方式，由dma控制器取代cpu，获得cpud总线控制权，实现 内存与外设 或 内存的不同区域之间 或者 外设与外设 大量数据的快速传送。\n\n用于：图像的显示、磁盘的存取，磁盘间的数据传送等。\n\n\n# 二、8237 dma数据传送的工作过程\n\n书：p427(图8-16)\n\n * 接收从外设发出的dma请求，并向cpu发出总线请求信号。\n * 当cpu响应请求，发出hlda后，dma控制器能接管对总线的控制，进入dma操作方式。\n * 发出存储器地址，确定数据传送的地址单元，并能自动修改地址指针。\n * 识别数据传送的方向，发出读或写控制信号。\n * 确定传送数据的个数，判断传送是否结束。\n * 发出dma操作的结束信号。\n\n需要注意的是：\n\n> 在内存与外设之间进行dma传送期间，dmac控制器只是输出地址及控制信号，而数据传送是直接在内存和外设端口之间进行的，并不是经过dmac。\n\n\n# 三、dma控制器8237a\n\n * 每个8237a芯片由4个dma通道，即有4个dma控制器；\n * 每个dma通道具有不同的优先权；\n * 每个dma通道可以分别允许和禁止\n * 每个dma通道有四种工作方式\n * 一次传输的最大长度可达64kb\n\n1、8237a的工作方式\n\n * dma传送方式\n\n>  * 单字节传送方式\n>  * 数据块传送方式\n>  * 请求级联方式\n>  * 级联方式\n\n * dma传送类型\n\n>  * dma读：读存储器—>外设\n>  * dma写：外设—>存储器\n>  * dma检验：",charsets:{cjk:!0},lastUpdated:"2022/06/20, 23:06:00",lastUpdatedTimestamp:1655737214e3},{title:"第一章 基础语法",frontmatter:{title:"第一章 基础语法",date:"2021-09-11T14:30:00.000Z",permalink:"/c/note1/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"50.C语言/02.第一章基础语法.md",key:"v-b75bc230",path:"/c/note1/",headers:[{level:2,title:"1、输出函数",slug:"_1、输出函数",normalizedTitle:"1、输出函数",charIndex:61},{level:2,title:"2、运算符",slug:"_2、运算符",normalizedTitle:"2、运算符",charIndex:248},{level:2,title:"3、变量定义",slug:"_3、变量定义",normalizedTitle:"3、变量定义",charIndex:563},{level:2,title:"4、变量的名字",slug:"_4、变量的名字",normalizedTitle:"4、变量的名字",charIndex:612},{level:2,title:"5、变量初始化",slug:"_5、变量初始化",normalizedTitle:"5、变量初始化",charIndex:1088},{level:2,title:"6、变量类型",slug:"_6、变量类型",normalizedTitle:"6、变量类型",charIndex:1269},{level:2,title:"7、常量",slug:"_7、常量",normalizedTitle:"7、常量",charIndex:1582},{level:2,title:"8、转义字符",slug:"_8、转义字符",normalizedTitle:"8、转义字符",charIndex:1666},{level:2,title:"9、输入函数",slug:"_9、输入函数",normalizedTitle:"9、输入函数",charIndex:1689},{level:2,title:"10、运算符优先级和结合性",slug:"_10、运算符优先级和结合性",normalizedTitle:"10、运算符优先级和结合性",charIndex:2870},{level:2,title:"11、一些容易出错的优先级问题",slug:"_11、一些容易出错的优先级问题",normalizedTitle:"11、一些容易出错的优先级问题",charIndex:3124},{level:2,title:"12、不同类型数据间的混合运算",slug:"_12、不同类型数据间的混合运算",normalizedTitle:"12、不同类型数据间的混合运算",charIndex:4134}],headersStr:"1、输出函数 2、运算符 3、变量定义 4、变量的名字 5、变量初始化 6、变量类型 7、常量 8、转义字符 9、输入函数 10、运算符优先级和结合性 11、一些容易出错的优先级问题 12、不同类型数据间的混合运算",content:'# 第一章 基础语法\n\n注意事项：编写代码注意：代码里的符号一定要是英文状态下的标点符号！！！，不要用中文！！！\n\n\n# 1、输出函数\n\nprintf("Hello World!\\n"); ""⾥⾯的内容叫做“字符串”，printf会把其中的内容原封不动地输出\\n表⽰需要在输出的结果后⾯换⼀⾏。\n\n补充：\n\n * 如果你在使⽤Dev C++ 4.9.9.2 system("pause");\n * 让程序运⾏完成后，窗⼝还能留下\n * 不是Dev C++ 4.9.9.2就不需要这个了\n\n\n# 2、运算符\n\n算数运算符\n\nC符号   意义\n+     加\n-     减\n*     乘\n/     除\n%     取余\n()    括号\n++    自增\n--    自减\n\n关系运算符\n\nC符号   意义\n>     大于\n<     小于\n==    等于\n>=    大于等于\n<=    小于等于\n!=    不等于\n\n逻辑运算符\n\nC符号   意义\n！     非\n&&    与\n||    或\n\n位运算符：【>>,<<,~,|,^,&】 赋值运算符：【=】 条件运算符（三元运算符）：【常量表达式？返回值1:返回值2;】 逗号运算符：【,】 指针运算符：【*,&】 求字节数运算符：【sizeof】\n\n\n# 3、变量定义\n\n变量定义的⼀般形式就是：<类型名称> <变量名称>; 例如：int a;\n\n\n# 4、变量的名字\n\n * 变量需要⼀个名字，变量的名字是⼀种“标识符”，意思是它是⽤来识别这个和那个的不同的名字。\n\n * 标识符有标识符的构造规则。基本的原则是：标识符只能由字⺟、数字和下划线组成，数字不可以出现在第⼀个位置上，C语⾔的关键字（有的地⽅叫它们保留字）不可以⽤做标识符。 C语⾔的保留字：\n\n  auto、break、case、char、const 、continue、default、do、double 、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、 struct、switch、typedef、union、unsigned、void、volatile、while、inline、restrict\n\n\n1\n\n\n赋值和初始化 int price = 0; 这⼀⾏，定义了⼀个变量。变量的名字是price，类型是int，初始值是0。 这⾥的“＝”是⼀个赋值运算符，表⽰将“＝”右边的值赋给左边的变量。\n\n\n# 5、变量初始化\n\n如果没有进行初始化变量，直接使用，运算出来的结果会是一个很奇怪的值。 格式为：<类型名称> <变量名称> = <初始值>;\n\n> 当赋值发⽣在定义变量的时候，就像程序1中的第7⾏那样，就是变量的初始化。虽然C语⾔并没有强制要求所有的变量都在定义的地⽅做初始化，但是所有的变量在第⼀次被使⽤（出现在赋值运算符的右边）之前被应该赋值⼀次。\n\n\n# 6、变量类型\n\nC是⼀种有类型的语⾔，所有的变量在使⽤之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表⽰在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运⾏过程中也不能改变变量的类型。\n\n六种基本数据类型。\n\n变量类型     说明        字节大小\nchar     字符型类型     1\nshort    短整型类型     2\nint      整型类型      4\nlong     长整型类型     4or8\nfloat    单精度浮点类型   4\ndouble   双精度浮点类型   8\n\n * signed:有符号，可省略\n * unsigned:无符号\n\n\n# 7、常量\n\nC99允许使用常变量，方法是在定义变量时，前面加一个关键字const。 符号常量#define：用法#define 常量名 值，注意行末没有分号。\n\n\n# 8、转义字符\n\n转义字符及其作用\n\n\n\n\n# 9、输入函数\n\nscanf(“格式控制字符串”, 地址表列); 格式控制字符串的作用与printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串。地址表列中给出各变量的地址。地址是由地址运算符“&”后跟变量名组成的。 例如：\n\n#include <stdio.h>\nint main(void){\n    int a,b,c;\n    printf("input a,b,c\\n");\n    scanf("%d%d%d",&a,&b,&c);\n    printf("a=%d,b=%d,c=%d",a,b,c);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n** 格式字符串** 格式字符串的一般形式为： %[*][输入数据宽度][长度]类型 其中有方括号[]的项为任选项。各项的意义如下。 类型 表示输入数据的类型，其格式符和意义如下表所示。\n\n格式      字符意义\n%d      输入十进制整数\n%o      输入八进制整数\n%x      输入十六进制整数\n%u      输入无符号十进制整数\n%f或%e   输入实型数(用小数形式或指数形式)\n%c      输入单个字符\n%s      输入字符串\n\n使用scanf函数还必须注意以下几点：\n\n 1. scanf函数中没有精度控制，如：scanf("%5.2f",&a);是非法的。不能企图用此语句输入小数为2位的实数。\n 2. scanf中要求给出变量地址，如给出变量名则会出错。如 scanf("%d",a);是非法的，应改为scnaf("%d",&a);才是合法的。\n 3. 在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。\n 4. 在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。\n\nprintf格式附加字符\n\n字符           说明\nl            长整型整数，可加在格式符d、o、x、u前面\nm(代表一个正整数)   数据最小宽度\nn(代表一个正整数)   对实数，表示输出n位小数；对字符串，表示截取的字符个数;\n-            输出的数字或字符域内向左靠\n\n一般形式为：% 附加字符 格式字符\n\nscanf格式附加字符\n\n字符   说明\nl    输入长整型数据（可用%ld，%lo，%lx，%lu）以及double型数据（用%lf或%le）\nh    输入短整型数据（可用%hd，%ho，%hx）\n域宽   指定输入输入数据所占宽度（列数），宽域应为正整数\n*    本输入项在读入后不赋给相应变量\n\n\n# 10、运算符优先级和结合性\n\n\n\n\n\n\n\n上表中可以总结出如下规律：\n\n 1. 结合方向只有三个是从右往左，其余都是从左往右。\n 2. 所有双目运算符中只有赋值运算符的结合方向是从右往左。\n 3. 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。\n 4. C语言中有且只有一个三目运算符。\n 5. 逗号运算符的优先级最低，要记住。\n 6. 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。\n\n\n# 11、一些容易出错的优先级问题\n\n上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？这是很多初学者迷糊的地方。下表就整理了这些容易出错的情况：\n\n优先级问题                        表达式                    经常误认为的结果                                实际结果\n. 的优先级高于 *（-> 操作符用于消除这个问题）   *p.f                   p 所指对象的字段 f，等价于： (*p).f                 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于： *(p.f)\n[] 高于 *                      int *ap[]              ap 是个指向 int 数组的指针，等价于： int (*ap)[]      ap 是个元素为 int 指针的数组，等价于： int *(ap [])\n函数 () 高于 *                   int *fp()              fp 是个函数指针，所指函数返回 int，等价于： int (*fp)()   fp 是个函数，返回 int*，等价于： int*( fp() )\n== 和 != 高于位操作                (val & mask != 0)      (val &mask) != 0                        val & (mask != 0)\n== 和 != 高于赋值符                c = getchar() != EOF   (c = getchar()) != EOF                  c = (getchar() != EOF)\n算术运算符高于位移 运算符                msb << 4 + lsb         (msb << 4) + lsb                        msb << (4 + lsb)\n逗号运算符在所有运 算符中优先级最低           i = 1, 2               i = (1,2)                               (i = 1), 2\n\n\n# 12、不同类型数据间的混合运算\n\n（1）+、-、*、/、运算符两侧中有一个为float或double型，结果都为double型数据。 （2）如果 int型与float型数据进行运算，会先把int型和和float型数据转换为double型，然后再进行运算，结果是double型 （3）字符（char）型数据与整形数据进行运算，就是把字符型数据的ASCLL代码与整形数据进行运算。如：12+\'A\'等效于12+65结果为77，字符型数据与实型数据进行运算，则会将字符型的ASCLL代码转换为double型数据然后再进行运算。\n\n以上的转换都是由编译器自动完成转换的，知道其转换的原理即可，不用自己进行转换。',normalizedContent:'# 第一章 基础语法\n\n注意事项：编写代码注意：代码里的符号一定要是英文状态下的标点符号！！！，不要用中文！！！\n\n\n# 1、输出函数\n\nprintf("hello world!\\n"); ""⾥⾯的内容叫做“字符串”，printf会把其中的内容原封不动地输出\\n表⽰需要在输出的结果后⾯换⼀⾏。\n\n补充：\n\n * 如果你在使⽤dev c++ 4.9.9.2 system("pause");\n * 让程序运⾏完成后，窗⼝还能留下\n * 不是dev c++ 4.9.9.2就不需要这个了\n\n\n# 2、运算符\n\n算数运算符\n\nc符号   意义\n+     加\n-     减\n*     乘\n/     除\n%     取余\n()    括号\n++    自增\n--    自减\n\n关系运算符\n\nc符号   意义\n>     大于\n<     小于\n==    等于\n>=    大于等于\n<=    小于等于\n!=    不等于\n\n逻辑运算符\n\nc符号   意义\n！     非\n&&    与\n||    或\n\n位运算符：【>>,<<,~,|,^,&】 赋值运算符：【=】 条件运算符（三元运算符）：【常量表达式？返回值1:返回值2;】 逗号运算符：【,】 指针运算符：【*,&】 求字节数运算符：【sizeof】\n\n\n# 3、变量定义\n\n变量定义的⼀般形式就是：<类型名称> <变量名称>; 例如：int a;\n\n\n# 4、变量的名字\n\n * 变量需要⼀个名字，变量的名字是⼀种“标识符”，意思是它是⽤来识别这个和那个的不同的名字。\n\n * 标识符有标识符的构造规则。基本的原则是：标识符只能由字⺟、数字和下划线组成，数字不可以出现在第⼀个位置上，c语⾔的关键字（有的地⽅叫它们保留字）不可以⽤做标识符。 c语⾔的保留字：\n\n  auto、break、case、char、const 、continue、default、do、double 、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、 struct、switch、typedef、union、unsigned、void、volatile、while、inline、restrict\n\n\n1\n\n\n赋值和初始化 int price = 0; 这⼀⾏，定义了⼀个变量。变量的名字是price，类型是int，初始值是0。 这⾥的“＝”是⼀个赋值运算符，表⽰将“＝”右边的值赋给左边的变量。\n\n\n# 5、变量初始化\n\n如果没有进行初始化变量，直接使用，运算出来的结果会是一个很奇怪的值。 格式为：<类型名称> <变量名称> = <初始值>;\n\n> 当赋值发⽣在定义变量的时候，就像程序1中的第7⾏那样，就是变量的初始化。虽然c语⾔并没有强制要求所有的变量都在定义的地⽅做初始化，但是所有的变量在第⼀次被使⽤（出现在赋值运算符的右边）之前被应该赋值⼀次。\n\n\n# 6、变量类型\n\nc是⼀种有类型的语⾔，所有的变量在使⽤之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表⽰在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运⾏过程中也不能改变变量的类型。\n\n六种基本数据类型。\n\n变量类型     说明        字节大小\nchar     字符型类型     1\nshort    短整型类型     2\nint      整型类型      4\nlong     长整型类型     4or8\nfloat    单精度浮点类型   4\ndouble   双精度浮点类型   8\n\n * signed:有符号，可省略\n * unsigned:无符号\n\n\n# 7、常量\n\nc99允许使用常变量，方法是在定义变量时，前面加一个关键字const。 符号常量#define：用法#define 常量名 值，注意行末没有分号。\n\n\n# 8、转义字符\n\n转义字符及其作用\n\n\n\n\n# 9、输入函数\n\nscanf(“格式控制字符串”, 地址表列); 格式控制字符串的作用与printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串。地址表列中给出各变量的地址。地址是由地址运算符“&”后跟变量名组成的。 例如：\n\n#include <stdio.h>\nint main(void){\n    int a,b,c;\n    printf("input a,b,c\\n");\n    scanf("%d%d%d",&a,&b,&c);\n    printf("a=%d,b=%d,c=%d",a,b,c);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n** 格式字符串** 格式字符串的一般形式为： %[*][输入数据宽度][长度]类型 其中有方括号[]的项为任选项。各项的意义如下。 类型 表示输入数据的类型，其格式符和意义如下表所示。\n\n格式      字符意义\n%d      输入十进制整数\n%o      输入八进制整数\n%x      输入十六进制整数\n%u      输入无符号十进制整数\n%f或%e   输入实型数(用小数形式或指数形式)\n%c      输入单个字符\n%s      输入字符串\n\n使用scanf函数还必须注意以下几点：\n\n 1. scanf函数中没有精度控制，如：scanf("%5.2f",&a);是非法的。不能企图用此语句输入小数为2位的实数。\n 2. scanf中要求给出变量地址，如给出变量名则会出错。如 scanf("%d",a);是非法的，应改为scnaf("%d",&a);才是合法的。\n 3. 在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，tab或回车作间隔。c编译在碰到空格，tab，回车或非法数据(如对“%d”输入“12a”时，a即为非法数据)时即认为该数据结束。\n 4. 在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。\n\nprintf格式附加字符\n\n字符           说明\nl            长整型整数，可加在格式符d、o、x、u前面\nm(代表一个正整数)   数据最小宽度\nn(代表一个正整数)   对实数，表示输出n位小数；对字符串，表示截取的字符个数;\n-            输出的数字或字符域内向左靠\n\n一般形式为：% 附加字符 格式字符\n\nscanf格式附加字符\n\n字符   说明\nl    输入长整型数据（可用%ld，%lo，%lx，%lu）以及double型数据（用%lf或%le）\nh    输入短整型数据（可用%hd，%ho，%hx）\n域宽   指定输入输入数据所占宽度（列数），宽域应为正整数\n*    本输入项在读入后不赋给相应变量\n\n\n# 10、运算符优先级和结合性\n\n\n\n\n\n\n\n上表中可以总结出如下规律：\n\n 1. 结合方向只有三个是从右往左，其余都是从左往右。\n 2. 所有双目运算符中只有赋值运算符的结合方向是从右往左。\n 3. 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。\n 4. c语言中有且只有一个三目运算符。\n 5. 逗号运算符的优先级最低，要记住。\n 6. 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。\n\n\n# 11、一些容易出错的优先级问题\n\n上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？这是很多初学者迷糊的地方。下表就整理了这些容易出错的情况：\n\n优先级问题                        表达式                    经常误认为的结果                                实际结果\n. 的优先级高于 *（-> 操作符用于消除这个问题）   *p.f                   p 所指对象的字段 f，等价于： (*p).f                 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于： *(p.f)\n[] 高于 *                      int *ap[]              ap 是个指向 int 数组的指针，等价于： int (*ap)[]      ap 是个元素为 int 指针的数组，等价于： int *(ap [])\n函数 () 高于 *                   int *fp()              fp 是个函数指针，所指函数返回 int，等价于： int (*fp)()   fp 是个函数，返回 int*，等价于： int*( fp() )\n== 和 != 高于位操作                (val & mask != 0)      (val &mask) != 0                        val & (mask != 0)\n== 和 != 高于赋值符                c = getchar() != eof   (c = getchar()) != eof                  c = (getchar() != eof)\n算术运算符高于位移 运算符                msb << 4 + lsb         (msb << 4) + lsb                        msb << (4 + lsb)\n逗号运算符在所有运 算符中优先级最低           i = 1, 2               i = (1,2)                               (i = 1), 2\n\n\n# 12、不同类型数据间的混合运算\n\n（1）+、-、*、/、运算符两侧中有一个为float或double型，结果都为double型数据。 （2）如果 int型与float型数据进行运算，会先把int型和和float型数据转换为double型，然后再进行运算，结果是double型 （3）字符（char）型数据与整形数据进行运算，就是把字符型数据的ascll代码与整形数据进行运算。如：12+\'a\'等效于12+65结果为77，字符型数据与实型数据进行运算，则会将字符型的ascll代码转换为double型数据然后再进行运算。\n\n以上的转换都是由编译器自动完成转换的，知道其转换的原理即可，不用自己进行转换。',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"标题 - 锚点比较",frontmatter:{title:"标题 - 锚点比较",date:"2021-05-16T22:54:18.000Z",permalink:"/pages/8bac8d/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/12.%E6%A0%87%E9%A2%98%20-%20%E9%94%9A%E7%82%B9%E6%AF%94%E8%BE%83.html",relativePath:"10.关于/02.关于 - 本站/12.标题 - 锚点比较.md",key:"v-0ebed345",path:"/pages/8bac8d/",headers:[{level:2,title:"一  二级目录2空格",slug:"一-二级目录2空格",normalizedTitle:"一  二级目录2空格",charIndex:null},{level:3,title:"3  相同的三级目录",slug:"_3-相同的三级目录",normalizedTitle:"3  相同的三级目录",charIndex:null},{level:3,title:"3  相同的三级目录",slug:"_3-相同的三级目录-2",normalizedTitle:"3  相同的三级目录",charIndex:null},{level:2,title:"二 二级目录1空格",slug:"二-二级目录1空格",normalizedTitle:"二 二级目录1空格",charIndex:105},{level:2,title:"二 二级目录（带括号）",slug:"二-二级目录-带括号",normalizedTitle:"二 二级目录（带括号）",charIndex:118},{level:3,title:"3 三级目录",slug:"_3-三级目录",normalizedTitle:"3 三级目录",charIndex:135},{level:2,title:"2、带数字和符号的二级目录",slug:"_2、带数字和符号的二级目录",normalizedTitle:"2、带数字和符号的二级目录",charIndex:145},{level:3,title:"3、三级目录",slug:"_3、三级目录",normalizedTitle:"3、三级目录",charIndex:164}],headersStr:"一  二级目录2空格 3  相同的三级目录 3  相同的三级目录 二 二级目录1空格 二 二级目录（带括号） 3 三级目录 2、带数字和符号的二级目录 3、三级目录",content:"----------------------------------------\n\nvuepress生成的目录\n\n\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n\n\n\n----------------------------------------\n\n点击两款标题跳转的锚点，自行判断二者的区别\n\n----------------------------------------\n\ndoctoc生成的目录\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n     * 不带符号和空格的四级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n     * 4 四级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n     * 4、四级目录\n\n----------------------------------------\n\n\n# 一 二级目录2空格\n\n\n# 3 相同的三级目录\n\n\n# 3 相同的三级目录\n\n# 不带符号和空格的四级目录\n\n\n# 二 二级目录1空格\n\n\n# 二 二级目录（带括号）\n\n\n# 3 三级目录\n\n# 4 四级目录\n\n\n# 2、带数字和符号的二级目录\n\n\n# 3、三级目录\n\n# 4、四级目录",normalizedContent:"----------------------------------------\n\nvuepress生成的目录\n\n\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n\n\n\n----------------------------------------\n\n点击两款标题跳转的锚点，自行判断二者的区别\n\n----------------------------------------\n\ndoctoc生成的目录\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n     * 不带符号和空格的四级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n     * 4 四级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n     * 4、四级目录\n\n----------------------------------------\n\n\n# 一 二级目录2空格\n\n\n# 3 相同的三级目录\n\n\n# 3 相同的三级目录\n\n# 不带符号和空格的四级目录\n\n\n# 二 二级目录1空格\n\n\n# 二 二级目录（带括号）\n\n\n# 3 三级目录\n\n# 4 四级目录\n\n\n# 2、带数字和符号的二级目录\n\n\n# 3、三级目录\n\n# 4、四级目录",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第三章 数组",frontmatter:{title:"第三章 数组",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note3/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%95%B0%E7%BB%84.html",relativePath:"50.C语言/04.第三章数组.md",key:"v-7cfc0d66",path:"/c/note3/",headers:[{level:2,title:"1. 一维数组",slug:"_1-一维数组",normalizedTitle:"1. 一维数组",charIndex:24},{level:2,title:"2. 二维数组",slug:"_2-二维数组",normalizedTitle:"2. 二维数组",charIndex:1892},{level:2,title:"3. 字符数组",slug:"_3-字符数组",normalizedTitle:"3. 字符数组",charIndex:3347}],headersStr:"1. 一维数组 2. 二维数组 3. 字符数组",content:'# 第三章 数组【一维数组、多维数组】\n\n\n# 1. 一维数组\n\n一维数组的定义方式为： 类型说明符 数组名 [常量表达式]; 其中，类型说明符是任一种基本数据类型或构造数据类型。数组名是用户定义的数组标识符。方括号中的常量表达式表示数据元素的个数，也称为数组的长度。例如：\n\nint a[10]; \t\t\t\t /* 说明整型数组a，有10个元素 */\nfloat b[10], c[20];  \t /* 说明实型数组b，有10个元素，实型数组c，有20个元素 */\nchar ch[20];  \t\t\t /* 说明字符数组ch，有20个元素 */\n\n\n1\n2\n3\n\n\n对于数组类型说明应注意以下几点：\n\n 1. 数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同的。\n 2. 数组名的书写规则应符合标识符的书写规定。\n 3. 数组名不能与其它变量名相同。例如：\n\nint a;\nfloat a[10];\n\n\n1\n2\n\n\n是错误的。\n\n 4. 方括号中常量表达式表示数组元素的个数，如a[5]表示数组a有5个元素。但是其下标从0开始计算。因此5个元素分别为a[0], a[1], a[2], a[3], a[4]。\n\n 5. 不能在方括号中用变量来表示元素的个数，但是可以是符号常数或常量表达式。例如：\n\n#define FD 5\t// 宏定义，FD为常量（值不可改变）\nint a[3+2],b[7+FD];\n\n\n1\n2\n\n\n是合法的。但是下述说明方式是错误的。\n\nint n=5;\nint a[n];\n\n\n1\n2\n\n 6. 允许在同一个类型说明中，说明多个数组和多个变量。例如：\n\nint a,b,c,d,k1[10],k2[20];\n\n\n1\n\n\n一维数组元素的引用 数组元素是组成数组的基本单元。数组元素也是一种变量， 其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。数组元素的一般形式为： 数组名[下标] 其中下标只能为整型常量或整型表达式。如为小数时，C编译将自动取整。例如： a[5] a[i+j] a[i++] 都是合法的数组元素。\n\n数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。在C语言中只能逐个地使用下标变量，而不能一次引用整个数组。\n\n一维数组的初始化\n\n一维数组的初始化可以使用以下方法实现:\n\n 1. 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：\n\nint a[5] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n通过将数组元素的初值依次放在一对花括号中，如此初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。\n\n 2. 可以只给一部分元素赋值，这叫“不完全初始化”。例如：\n\nint a[5] = {1, 2};\n\n\n1\n\n\n定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。不完全初始化时，没有被初始化的元素自动为 0。\n\n需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。\n\n你也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int a[5]={0}；”，这时就是给数组“清零”，此时数组中每个元素都是零。此外，如果定义的数组的长度比花括号中所提供的初值的个数少，也是语法错误，如“a[2]={1，2，3，4，5}；”。\n\n 3. 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了。编程时我们经常都会使用这种写法，因为方便，既不会出问题，也不用自己计算有几个元素，系统会自动分配空间。例如：\n\nint a[5] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n可以写成：\n\nint a[] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n第二种写法的花括号中有 5 个数，所以系统会自动定义数组 a 的长度为 5。但是要注意，只有在定义数组时就初始化才可以这样写。如果定义数组时不初始化，那么省略数组长度就是语法错误。比如：\n\nint a[];\n\n\n1\n\n\n那么编译时就会提示错误，编译器会提示你没有指定数组的长度。\n\n\n# 2. 二维数组\n\n二维数组定义的一般形式是： 类型说明符 数组名[常量表达式1][常量表达式2] 其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。例如：\n\nint a[3][4];\n\n\n1\n\n\n说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。 该数组的下标变量共有3×4个，即：\n\n  a[0][0], a[0][1], a[0][2], a[0][3]\n  a[1][0], a[1][1], a[1][2], a[1][3]\n  a[2][0], a[2][1], a[2][2], a[2][3]\n\n\n1\n2\n3\n\n\n二维数组在概念上是二维的，即是说其下标在两个方向上变化，下标变量在数组中的位置也处于一个平面之中，而不是象一维数组只是一个向量。但是，实际的硬件存储器却是连续编址的，也就是说存储器单元是按一维线性排列的。如何在一维存储器中存放二维数组，可有两种方式：一种是按行排列， 即放完一行之后顺次放入第二行。另一种是按列排列， 即放完一列之后再顺次放入第二列。\n\n在C语言中，二维数组是按行排列的。即，先存放a[0]行，再存放a[1]行，最后存放a[2]行。每行中有四个元素也是依次存放。由于数组a说明为int类型，该类型占两个字节的内存空间，所以每个元素均占有两个字节。\n\n二维数组元素的引用 二维数组的元素也称为双下标变量，其表示的形式为： 数组名[下标][下标] 其中下标应为整型常量或整型表达式。例如： a[3][4] 表示a数组三行四列的元素。\n\n下标变量和数组说明在形式中有些相似，但这两者具有完全不同的含义。数组说明的方括号中给出的是某一维的长度，即可取下标的最大值；而数组元素中的下标是该元素在数组中的位置标识。前者只能是常量，后者可以是常量，变量或表达式。\n\n二维数组元素的初始化 二维数组初始化也是在类型说明时给各下标变量赋以初值。二维数组可按行分段赋值，也可按行连续赋值。 对于二维数组初始化赋值还有以下说明：\n\n 1. 可以只对部分元素赋初值，未赋初值的元素自动取0值。例如：\n\nint a[3][3]={{1},{2},{3}};\n\n\n1\n\n\n是对每一行的第一列元素赋值，未赋值的元素取0值。 赋值后各元素的值为： 1 0 0 2 0 0 3 0 0\n\nint a [3][3]={{0,1},{0,0,2},{3}};\n\n\n1\n\n\n赋值后的元素值为： 0 1 0 0 0 2 3 0 0\n\n 2. 如对全部元素赋初值，则第一维的长度可以不给出。例如：\n\nint a[3][3]={1,2,3,4,5,6,7,8,9};\n\n\n1\n\n\n可以写为：\n\nint a[][3]={1,2,3,4,5,6,7,8,9};\n\n\n1\n\n 3. 数组是一种构造类型的数据。二维数组可以看作是由一维数组的嵌套而构成的。设一维数组的每个元素都又是一个数组，就组成了二维数组。当然，前提是各元素类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组。C语言允许这种分解。 如二维数组a[3][4]，可分解为三个一维数组，其数组名分别为： a[0] a[1] a[2] 对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组a[0]的元素为a[0][0],a[0][1],a[0][2],a[0][3]。必须强调的是，a[0],a[1],a[2]不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。\n\n\n# 3. 字符数组\n\n1、字符数组的定义 char word[] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’,‘!’,’\\0’}; 以0（整数0）结尾的⼀串字符 0或’\\0’是⼀样的，但是和’0’不同 0标志字符串的结束，但它不是字符串的⼀部分 计算字符串⻓度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 2、字符数组与字符串 • "Hello" • "Hello" 会被编译器变成⼀个字符数组放在某处，这 个数组的⻓度是6，结尾还有表⽰结束的0 • 两个相邻的字符串常量会被⾃动连接起来 • ⾏末的\\表⽰下⼀⾏还是这个字符串常量\n\n----------------------------------------\n\n• C语⾔的字符串是以字符数组的形态存在的 • 不能⽤运算符对字符串做运算 • 通过数组的⽅式可以遍历字符串 • 唯⼀特殊的地⽅是字符串字⾯量可以⽤来初始化字符 数组 • 以及标准库提供了⼀系列字符串函数\n\n----------------------------------------\n\nchar*s = "Hello, world!"; • s 是⼀个指针，初始化为指向⼀个字符串常量 • 由于这个常量所在的地⽅，所以实际上s是 const char* s ，但是由于历史的原因，编译器接受不带 const的写法 • 但是试图对s所指的字符串做写⼊会导致严重的后果 • 如果需要修改字符串，应该⽤数组：char s[] = "Hello, world!";\n\n指针还是数组？ • char *str = "Hello"; • char word[] = "Hello"; • 数组：这个字符串在这⾥ • 作为本地变量空间⾃动被回收 • 指针：这个字符串不知道在哪⾥ • 处理参数 • 动态分配空间\n\n * 如果要构造⼀个字符串—>数组\n\n * 如果要处理⼀个字符串—>指针\n\n3、字符串的表示形式 在C语言中，可以用两种方法表示和存放字符串： （1）用字符数组存放一个字符串 char str[]="I love China"; （2）用字符指针指向一个字符串 char* str="I love China"; 对于第二种表示方法，有人认为str是一个字符串变量，以为定义时把字符串常量"I love China"直接赋给该字符串变量，这是不对的。 C语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量str时只是把字符串首地址（即存放字符串的字符数组的首地址）赋给str。\n\n两种表示方式的字符串输出都用 printf("%s\\n",str); %s表示输出一个字符串，给出字符指针变量名str（对于第一种表示方法，字符数组名即是字符数组的首地址，与第二种中的指针意义是一致的），则系统先输出它所指向的一个字符数据，然后自动使str自动加1，使之指向下一个字符...，如此，直到遇到字符串结束标识符 " \\0 "。\n\n• 字符串可以表达为char的形式 • char不⼀定是字符串 • 本意是指向字符的指针，可能指向的是字符 的数组（就像int*⼀样） • 只有它所指的字符数组有结尾的0，才能说它 所指的是字符串\n\n4、对使用字符指针变量和字符数组两种方法表示字符串的讨论 虽然用字符数组和字符指针变量都能实现字符串的存储和运算，但它们二者之间是有区别的，不应混为一谈。 4.1、字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址） 4.2、赋值方式： 对字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值\n\nchar str[14];\nstr="I love China";\n//（但在字符数组**初始化**时可以，即char str[14]="I love China";）\n\n\n1\n2\n3\n\n\n而对字符指针变量，采用下面方法赋值：\n\nchar* a;\na="I love China";\n\n\n1\n2\n\n\n或者是char* a="I love China";都可以\n\n4.3、对字符指针变量赋初值（初始化）： char* a="I love China"; 等价于：\n\nchar* a;\na="I love China";\n\n\n1\n2\n\n\n而对于字符数组的初始化 char str[14]="I love China"; 不能等价于：\n\nchar str[14];\nstr="I love China"; （这种不是初始化，而是赋值，而对数组这样赋值是不对的）\n\n\n1\n2\n\n\n4.4、如果定义了一个字符数组，那么它有确定的内存地址；而定义一个字符指针变量时，它并未指向个确定的字符数据，并且可以多次赋值。\n\n----------------------------------------\n\n5、字符串处理函数\n\n**注意：**在使用字符串处理函数函数时应当在程序文件的开头用#include <string.h>。\n\n * puts函数\n   \n   * 输出字符串：puts(字符数组)\n\n * gets函数\n   \n   * 输入字符串：gets(字符数组)\n\n * strcat函数\n   \n   * 字符串连接函数：strcat（字符串数组1，字符串数组2）\n\n * strcpy函数\n   \n   * 字符串复制函数：strcpy（字符串数组1，字符串数组2）\n\n * strncpy函数\n   \n   * 字符串复制函数：strncpy（字符串数组1，字符串数组2，n），n为常数\n   * 把字符串数组2中前面n个字符复制到字符串数组1中\n\n * strcmp函数\n   \n   * 字符串比较函数：strcmp(字符串数组1，字符串数组2)\n   \n   * 比较规则：将两个字符串自左向右逐个字符相比（按ASCII码值大小比较），直到出现不同的字符或遇到‘\\0’为止。\n     \n     > 1.如果字符串数组1与字符串数组2相同，则返回函数值为0。\n     > \n     > 2.如果字符串数组1>字符串数组2相同，则返回函数值为一个正整数。\n     > \n     > 3.如果字符串数组1<字符串数组2相同，则返回函数值为一个负整数。\n\n * strlen函数\n   \n   * 测字符串长度：strlen(字符串数组)\n   * 函数的值为字符串中的实际长度（不包括\'\\0\'在内）\n\n * strlwr函数\n   \n   * 转换为小写：strlwr(字符串数组)\n\n * strupr函数\n   \n   * 转换为小写：strupr(字符串数组)\n\n----------------------------------------',normalizedContent:'# 第三章 数组【一维数组、多维数组】\n\n\n# 1. 一维数组\n\n一维数组的定义方式为： 类型说明符 数组名 [常量表达式]; 其中，类型说明符是任一种基本数据类型或构造数据类型。数组名是用户定义的数组标识符。方括号中的常量表达式表示数据元素的个数，也称为数组的长度。例如：\n\nint a[10]; \t\t\t\t /* 说明整型数组a，有10个元素 */\nfloat b[10], c[20];  \t /* 说明实型数组b，有10个元素，实型数组c，有20个元素 */\nchar ch[20];  \t\t\t /* 说明字符数组ch，有20个元素 */\n\n\n1\n2\n3\n\n\n对于数组类型说明应注意以下几点：\n\n 1. 数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同的。\n 2. 数组名的书写规则应符合标识符的书写规定。\n 3. 数组名不能与其它变量名相同。例如：\n\nint a;\nfloat a[10];\n\n\n1\n2\n\n\n是错误的。\n\n 4. 方括号中常量表达式表示数组元素的个数，如a[5]表示数组a有5个元素。但是其下标从0开始计算。因此5个元素分别为a[0], a[1], a[2], a[3], a[4]。\n\n 5. 不能在方括号中用变量来表示元素的个数，但是可以是符号常数或常量表达式。例如：\n\n#define fd 5\t// 宏定义，fd为常量（值不可改变）\nint a[3+2],b[7+fd];\n\n\n1\n2\n\n\n是合法的。但是下述说明方式是错误的。\n\nint n=5;\nint a[n];\n\n\n1\n2\n\n 6. 允许在同一个类型说明中，说明多个数组和多个变量。例如：\n\nint a,b,c,d,k1[10],k2[20];\n\n\n1\n\n\n一维数组元素的引用 数组元素是组成数组的基本单元。数组元素也是一种变量， 其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。数组元素的一般形式为： 数组名[下标] 其中下标只能为整型常量或整型表达式。如为小数时，c编译将自动取整。例如： a[5] a[i+j] a[i++] 都是合法的数组元素。\n\n数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。在c语言中只能逐个地使用下标变量，而不能一次引用整个数组。\n\n一维数组的初始化\n\n一维数组的初始化可以使用以下方法实现:\n\n 1. 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：\n\nint a[5] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n通过将数组元素的初值依次放在一对花括号中，如此初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。\n\n 2. 可以只给一部分元素赋值，这叫“不完全初始化”。例如：\n\nint a[5] = {1, 2};\n\n\n1\n\n\n定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。不完全初始化时，没有被初始化的元素自动为 0。\n\n需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。\n\n你也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int a[5]={0}；”，这时就是给数组“清零”，此时数组中每个元素都是零。此外，如果定义的数组的长度比花括号中所提供的初值的个数少，也是语法错误，如“a[2]={1，2，3，4，5}；”。\n\n 3. 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了。编程时我们经常都会使用这种写法，因为方便，既不会出问题，也不用自己计算有几个元素，系统会自动分配空间。例如：\n\nint a[5] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n可以写成：\n\nint a[] = {1, 2, 3, 4, 5};\n\n\n1\n\n\n第二种写法的花括号中有 5 个数，所以系统会自动定义数组 a 的长度为 5。但是要注意，只有在定义数组时就初始化才可以这样写。如果定义数组时不初始化，那么省略数组长度就是语法错误。比如：\n\nint a[];\n\n\n1\n\n\n那么编译时就会提示错误，编译器会提示你没有指定数组的长度。\n\n\n# 2. 二维数组\n\n二维数组定义的一般形式是： 类型说明符 数组名[常量表达式1][常量表达式2] 其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。例如：\n\nint a[3][4];\n\n\n1\n\n\n说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。 该数组的下标变量共有3×4个，即：\n\n  a[0][0], a[0][1], a[0][2], a[0][3]\n  a[1][0], a[1][1], a[1][2], a[1][3]\n  a[2][0], a[2][1], a[2][2], a[2][3]\n\n\n1\n2\n3\n\n\n二维数组在概念上是二维的，即是说其下标在两个方向上变化，下标变量在数组中的位置也处于一个平面之中，而不是象一维数组只是一个向量。但是，实际的硬件存储器却是连续编址的，也就是说存储器单元是按一维线性排列的。如何在一维存储器中存放二维数组，可有两种方式：一种是按行排列， 即放完一行之后顺次放入第二行。另一种是按列排列， 即放完一列之后再顺次放入第二列。\n\n在c语言中，二维数组是按行排列的。即，先存放a[0]行，再存放a[1]行，最后存放a[2]行。每行中有四个元素也是依次存放。由于数组a说明为int类型，该类型占两个字节的内存空间，所以每个元素均占有两个字节。\n\n二维数组元素的引用 二维数组的元素也称为双下标变量，其表示的形式为： 数组名[下标][下标] 其中下标应为整型常量或整型表达式。例如： a[3][4] 表示a数组三行四列的元素。\n\n下标变量和数组说明在形式中有些相似，但这两者具有完全不同的含义。数组说明的方括号中给出的是某一维的长度，即可取下标的最大值；而数组元素中的下标是该元素在数组中的位置标识。前者只能是常量，后者可以是常量，变量或表达式。\n\n二维数组元素的初始化 二维数组初始化也是在类型说明时给各下标变量赋以初值。二维数组可按行分段赋值，也可按行连续赋值。 对于二维数组初始化赋值还有以下说明：\n\n 1. 可以只对部分元素赋初值，未赋初值的元素自动取0值。例如：\n\nint a[3][3]={{1},{2},{3}};\n\n\n1\n\n\n是对每一行的第一列元素赋值，未赋值的元素取0值。 赋值后各元素的值为： 1 0 0 2 0 0 3 0 0\n\nint a [3][3]={{0,1},{0,0,2},{3}};\n\n\n1\n\n\n赋值后的元素值为： 0 1 0 0 0 2 3 0 0\n\n 2. 如对全部元素赋初值，则第一维的长度可以不给出。例如：\n\nint a[3][3]={1,2,3,4,5,6,7,8,9};\n\n\n1\n\n\n可以写为：\n\nint a[][3]={1,2,3,4,5,6,7,8,9};\n\n\n1\n\n 3. 数组是一种构造类型的数据。二维数组可以看作是由一维数组的嵌套而构成的。设一维数组的每个元素都又是一个数组，就组成了二维数组。当然，前提是各元素类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组。c语言允许这种分解。 如二维数组a[3][4]，可分解为三个一维数组，其数组名分别为： a[0] a[1] a[2] 对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组a[0]的元素为a[0][0],a[0][1],a[0][2],a[0][3]。必须强调的是，a[0],a[1],a[2]不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。\n\n\n# 3. 字符数组\n\n1、字符数组的定义 char word[] = {‘h’, ‘e’, ‘l’, ‘l’, ‘o’,‘!’,’\\0’}; 以0（整数0）结尾的⼀串字符 0或’\\0’是⼀样的，但是和’0’不同 0标志字符串的结束，但它不是字符串的⼀部分 计算字符串⻓度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 2、字符数组与字符串 • "hello" • "hello" 会被编译器变成⼀个字符数组放在某处，这 个数组的⻓度是6，结尾还有表⽰结束的0 • 两个相邻的字符串常量会被⾃动连接起来 • ⾏末的\\表⽰下⼀⾏还是这个字符串常量\n\n----------------------------------------\n\n• c语⾔的字符串是以字符数组的形态存在的 • 不能⽤运算符对字符串做运算 • 通过数组的⽅式可以遍历字符串 • 唯⼀特殊的地⽅是字符串字⾯量可以⽤来初始化字符 数组 • 以及标准库提供了⼀系列字符串函数\n\n----------------------------------------\n\nchar*s = "hello, world!"; • s 是⼀个指针，初始化为指向⼀个字符串常量 • 由于这个常量所在的地⽅，所以实际上s是 const char* s ，但是由于历史的原因，编译器接受不带 const的写法 • 但是试图对s所指的字符串做写⼊会导致严重的后果 • 如果需要修改字符串，应该⽤数组：char s[] = "hello, world!";\n\n指针还是数组？ • char *str = "hello"; • char word[] = "hello"; • 数组：这个字符串在这⾥ • 作为本地变量空间⾃动被回收 • 指针：这个字符串不知道在哪⾥ • 处理参数 • 动态分配空间\n\n * 如果要构造⼀个字符串—>数组\n\n * 如果要处理⼀个字符串—>指针\n\n3、字符串的表示形式 在c语言中，可以用两种方法表示和存放字符串： （1）用字符数组存放一个字符串 char str[]="i love china"; （2）用字符指针指向一个字符串 char* str="i love china"; 对于第二种表示方法，有人认为str是一个字符串变量，以为定义时把字符串常量"i love china"直接赋给该字符串变量，这是不对的。 c语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量str时只是把字符串首地址（即存放字符串的字符数组的首地址）赋给str。\n\n两种表示方式的字符串输出都用 printf("%s\\n",str); %s表示输出一个字符串，给出字符指针变量名str（对于第一种表示方法，字符数组名即是字符数组的首地址，与第二种中的指针意义是一致的），则系统先输出它所指向的一个字符数据，然后自动使str自动加1，使之指向下一个字符...，如此，直到遇到字符串结束标识符 " \\0 "。\n\n• 字符串可以表达为char的形式 • char不⼀定是字符串 • 本意是指向字符的指针，可能指向的是字符 的数组（就像int*⼀样） • 只有它所指的字符数组有结尾的0，才能说它 所指的是字符串\n\n4、对使用字符指针变量和字符数组两种方法表示字符串的讨论 虽然用字符数组和字符指针变量都能实现字符串的存储和运算，但它们二者之间是有区别的，不应混为一谈。 4.1、字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址） 4.2、赋值方式： 对字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值\n\nchar str[14];\nstr="i love china";\n//（但在字符数组**初始化**时可以，即char str[14]="i love china";）\n\n\n1\n2\n3\n\n\n而对字符指针变量，采用下面方法赋值：\n\nchar* a;\na="i love china";\n\n\n1\n2\n\n\n或者是char* a="i love china";都可以\n\n4.3、对字符指针变量赋初值（初始化）： char* a="i love china"; 等价于：\n\nchar* a;\na="i love china";\n\n\n1\n2\n\n\n而对于字符数组的初始化 char str[14]="i love china"; 不能等价于：\n\nchar str[14];\nstr="i love china"; （这种不是初始化，而是赋值，而对数组这样赋值是不对的）\n\n\n1\n2\n\n\n4.4、如果定义了一个字符数组，那么它有确定的内存地址；而定义一个字符指针变量时，它并未指向个确定的字符数据，并且可以多次赋值。\n\n----------------------------------------\n\n5、字符串处理函数\n\n**注意：**在使用字符串处理函数函数时应当在程序文件的开头用#include <string.h>。\n\n * puts函数\n   \n   * 输出字符串：puts(字符数组)\n\n * gets函数\n   \n   * 输入字符串：gets(字符数组)\n\n * strcat函数\n   \n   * 字符串连接函数：strcat（字符串数组1，字符串数组2）\n\n * strcpy函数\n   \n   * 字符串复制函数：strcpy（字符串数组1，字符串数组2）\n\n * strncpy函数\n   \n   * 字符串复制函数：strncpy（字符串数组1，字符串数组2，n），n为常数\n   * 把字符串数组2中前面n个字符复制到字符串数组1中\n\n * strcmp函数\n   \n   * 字符串比较函数：strcmp(字符串数组1，字符串数组2)\n   \n   * 比较规则：将两个字符串自左向右逐个字符相比（按ascii码值大小比较），直到出现不同的字符或遇到‘\\0’为止。\n     \n     > 1.如果字符串数组1与字符串数组2相同，则返回函数值为0。\n     > \n     > 2.如果字符串数组1>字符串数组2相同，则返回函数值为一个正整数。\n     > \n     > 3.如果字符串数组1<字符串数组2相同，则返回函数值为一个负整数。\n\n * strlen函数\n   \n   * 测字符串长度：strlen(字符串数组)\n   * 函数的值为字符串中的实际长度（不包括\'\\0\'在内）\n\n * strlwr函数\n   \n   * 转换为小写：strlwr(字符串数组)\n\n * strupr函数\n   \n   * 转换为小写：strupr(字符串数组)\n\n----------------------------------------',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"标题 - 目录生成",frontmatter:{title:"标题 - 目录生成",date:"2021-05-16T23:36:45.000Z",permalink:"/pages/2bde62/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/11.%E6%A0%87%E9%A2%98%20-%20%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90.html",relativePath:"10.关于/02.关于 - 本站/11.标题 - 目录生成.md",key:"v-579999c0",path:"/pages/2bde62/",headers:[{level:2,title:"标题目录生成",slug:"标题目录生成",normalizedTitle:"标题目录生成",charIndex:3},{level:3,title:"typora",slug:"typora",normalizedTitle:"typora",charIndex:15},{level:3,title:"vuepress",slug:"vuepress",normalizedTitle:"vuepress",charIndex:27},{level:3,title:"DoCToc",slug:"doctoc",normalizedTitle:"doctoc",charIndex:41},{level:2,title:"标题建议",slug:"标题建议",normalizedTitle:"标题建议",charIndex:51}],headersStr:"标题目录生成 typora vuepress DoCToc 标题建议",content:" * 标题目录生成\n   * typora\n   * vuepress\n   * DoCToc\n * 标题建议\n\n\n# 标题目录生成\n\n推荐使用DocToc\n\n\n# typora\n\n输入\n\n[TOC]\n\n\n1\n\n\n生成所有标题\n\n但不能在 github vuepress 中正常显示，可在 csdn 中使用\n\n\n# vuepress\n\n[[TOC]]\n\n\n1\n\n\n只生成二级、三级标题\n\n只在 vuepress 中显示\n\n\n# DoCToc\n\n建议使用 DocToc\n\nDocToc：为本地git仓库内的markdown文件生成目录。链接与github或其他站点生成的锚点兼容。\n\n全局安装\n\nnpm install -g doctoc\n\n\n1\n\n\n使用方法：\n\n官方文档：https://www.npmjs.com/package/doctoc\n\nDocToc 默认在顶头生成目录，但在 vuepress 中顶头写的是配置\n\n所以需要自定义目录位置\n\n\x3c!-- START doctoc --\x3e\n\x3c!-- END doctoc --\x3e\n\n\n1\n2\n\n\n例如：\n\n// my_new_post.md\nHere we are, introducing the post. It's going to be great!\nBut first: a TOC for easy reference.\n\n\x3c!-- START doctoc --\x3e\n\x3c!-- END doctoc --\x3e\n\n# Section One\n\nHere we'll discuss...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成目录\n\n生成一个文件 README.md\n\ndoctoc README.md --github\n\n\n1\n\n\n更新目录\n\n更新一个文件 README.md\n\ndoctoc README.md --github -u\n\n\n1\n\n\n目录下所有文件一键生成\n\n在项目根目录中\n\ndoctoc . --github -u\n\n\n1\n\n\n此命令只会在有标记记录的md文件 生成/更新 目录\n\n若你想每个文件都生成，需要自己在每个文件中加上标记\n\n\n# 标题建议\n\n为了链接适配 github 及 vuepress 标题锚点兼容\n\n建议\n\n * 不要使用小写数字+空格，可用大写数字+空格\n\n * 不要使用符号\n   \n   可以用空格，且只能一个空格\n\n * 三级标题及更小标题不可添加符号及空格\n\n正确：\n\n## 一 java简介\n## 二 Java的特性和优势\n## Java三大版本\n\n\n1\n2\n3\n\n\n错误\n\n//使用二个空格\n## 一  java简介\n//使用符号\n## 2、java简介\n\n//三级及以下标题不可加符号和空格\n### 三 Java三大版本\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两者生成的锚点链接差异：访问下文\n\n总结：不用符号",normalizedContent:" * 标题目录生成\n   * typora\n   * vuepress\n   * doctoc\n * 标题建议\n\n\n# 标题目录生成\n\n推荐使用doctoc\n\n\n# typora\n\n输入\n\n[toc]\n\n\n1\n\n\n生成所有标题\n\n但不能在 github vuepress 中正常显示，可在 csdn 中使用\n\n\n# vuepress\n\n[[toc]]\n\n\n1\n\n\n只生成二级、三级标题\n\n只在 vuepress 中显示\n\n\n# doctoc\n\n建议使用 doctoc\n\ndoctoc：为本地git仓库内的markdown文件生成目录。链接与github或其他站点生成的锚点兼容。\n\n全局安装\n\nnpm install -g doctoc\n\n\n1\n\n\n使用方法：\n\n官方文档：https://www.npmjs.com/package/doctoc\n\ndoctoc 默认在顶头生成目录，但在 vuepress 中顶头写的是配置\n\n所以需要自定义目录位置\n\n\x3c!-- start doctoc --\x3e\n\x3c!-- end doctoc --\x3e\n\n\n1\n2\n\n\n例如：\n\n// my_new_post.md\nhere we are, introducing the post. it's going to be great!\nbut first: a toc for easy reference.\n\n\x3c!-- start doctoc --\x3e\n\x3c!-- end doctoc --\x3e\n\n# section one\n\nhere we'll discuss...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成目录\n\n生成一个文件 readme.md\n\ndoctoc readme.md --github\n\n\n1\n\n\n更新目录\n\n更新一个文件 readme.md\n\ndoctoc readme.md --github -u\n\n\n1\n\n\n目录下所有文件一键生成\n\n在项目根目录中\n\ndoctoc . --github -u\n\n\n1\n\n\n此命令只会在有标记记录的md文件 生成/更新 目录\n\n若你想每个文件都生成，需要自己在每个文件中加上标记\n\n\n# 标题建议\n\n为了链接适配 github 及 vuepress 标题锚点兼容\n\n建议\n\n * 不要使用小写数字+空格，可用大写数字+空格\n\n * 不要使用符号\n   \n   可以用空格，且只能一个空格\n\n * 三级标题及更小标题不可添加符号及空格\n\n正确：\n\n## 一 java简介\n## 二 java的特性和优势\n## java三大版本\n\n\n1\n2\n3\n\n\n错误\n\n//使用二个空格\n## 一  java简介\n//使用符号\n## 2、java简介\n\n//三级及以下标题不可加符号和空格\n### 三 java三大版本\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两者生成的锚点链接差异：访问下文\n\n总结：不用符号",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第二章 控制语句",frontmatter:{title:"第二章 控制语句",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note2/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",relativePath:"50.C语言/03.第二章控制语句.md",key:"v-11af5453",path:"/c/note2/",headers:[{level:2,title:"1. 字符输入输出函数",slug:"_1-字符输入输出函数",normalizedTitle:"1. 字符输入输出函数",charIndex:195},{level:2,title:"2. 选择结构嵌套",slug:"_2-选择结构嵌套",normalizedTitle:"2. 选择结构嵌套",charIndex:241},{level:2,title:"3. switch多分支",slug:"_3-switch多分支",normalizedTitle:"3. switch多分支",charIndex:343}],headersStr:"1. 字符输入输出函数 2. 选择结构嵌套 3. switch多分支",content:"# 第二章 控制语句\n\n * if…else… 条件语句\n * for()… 循环语句\n * whille()… 循环语句\n * do…whille() 循环语句\n * continue 结束本次循环\n * break 终止执行switch或循环语句\n * switch 多分支语句\n * return 从函数返回语句\n * goto 转向语句，在结构化程序中基本不用goto语句\n\n\n# 1. 字符输入输出函数\n\nputchar输出一个字符\n\ngetchar输入一个字符\n\n\n# 2. 选择结构嵌套\n\nif(){\n    if()语句；\n    else()语句；\n}\nelse{\n    if()语句；\n    else()语句；\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. switch多分支\n\nswitch(表达式)\n{\n    case 常量1:语句1;break;\n    case 常量2:语句2;break;\n        ……\n    case 常量n:语句n;break;\n    default :语句 n+1;break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于用法基本一致，其余不做详细介绍。请参考：《C语言程序设计（第五版）》——谭浩强 【第五章-循环结构 -110页】",normalizedContent:"# 第二章 控制语句\n\n * if…else… 条件语句\n * for()… 循环语句\n * whille()… 循环语句\n * do…whille() 循环语句\n * continue 结束本次循环\n * break 终止执行switch或循环语句\n * switch 多分支语句\n * return 从函数返回语句\n * goto 转向语句，在结构化程序中基本不用goto语句\n\n\n# 1. 字符输入输出函数\n\nputchar输出一个字符\n\ngetchar输入一个字符\n\n\n# 2. 选择结构嵌套\n\nif(){\n    if()语句；\n    else()语句；\n}\nelse{\n    if()语句；\n    else()语句；\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. switch多分支\n\nswitch(表达式)\n{\n    case 常量1:语句1;break;\n    case 常量2:语句2;break;\n        ……\n    case 常量n:语句n;break;\n    default :语句 n+1;break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于用法基本一致，其余不做详细介绍。请参考：《c语言程序设计（第五版）》——谭浩强 【第五章-循环结构 -110页】",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第五章 指针",frontmatter:{title:"第五章 指针",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note5/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%8C%87%E9%92%88.html",relativePath:"50.C语言/06.第五章指针.md",key:"v-744e4a64",path:"/c/note5/",headers:[{level:2,title:"1. 指针及指针变量【概念、定义】",slug:"_1-指针及指针变量【概念、定义】",normalizedTitle:"1. 指针及指针变量【概念、定义】",charIndex:21},{level:2,title:"2. 引用指针变量",slug:"_2-引用指针变量",normalizedTitle:"2. 引用指针变量",charIndex:908},{level:2,title:"3. 通过指针引用数组",slug:"_3-通过指针引用数组",normalizedTitle:"3. 通过指针引用数组",charIndex:1466},{level:2,title:"4. 通过指针引用字符串",slug:"_4-通过指针引用字符串",normalizedTitle:"4. 通过指针引用字符串",charIndex:5828},{level:2,title:"5. 指向函数的指针",slug:"_5-指向函数的指针",normalizedTitle:"5. 指向函数的指针",charIndex:7963},{level:2,title:"6. 返回指针值的函数",slug:"_6-返回指针值的函数",normalizedTitle:"6. 返回指针值的函数",charIndex:9200},{level:2,title:"7. 指针数组和多重指针",slug:"_7-指针数组和多重指针",normalizedTitle:"7. 指针数组和多重指针",charIndex:9464},{level:2,title:"8. 动态内存分配与指向它的指针变量",slug:"_8-动态内存分配与指向它的指针变量",normalizedTitle:"8. 动态内存分配与指向它的指针变量",charIndex:10988},{level:2,title:"9. 有关指针的小结",slug:"_9-有关指针的小结",normalizedTitle:"9. 有关指针的小结",charIndex:13190}],headersStr:"1. 指针及指针变量【概念、定义】 2. 引用指针变量 3. 通过指针引用数组 4. 通过指针引用字符串 5. 指向函数的指针 6. 返回指针值的函数 7. 指针数组和多重指针 8. 动态内存分配与指向它的指针变量 9. 有关指针的小结",content:'# 第五章 指针【C语言的灵魂】\n\n\n# 1. 指针及指针变量【概念、定义】\n\n定义指针变量：类型名称 *指针变量名;\n\n在定义指针变量时要注意：\n\n 1. 指针变量前面的“*”表示该变量为指针型变量。\n 2. 在定义指针变量时必须**指定基类型。**指针的基类型用来定义此指针变量可以指向的变量的类型。一个变量的指针的含义包括两个方面，一是存储单元编号表示的纯地址，一是它指向的存储单元的数据类型（如int、char、float等）。\n 3. 指向整型数据的指针类型表示为“int*”，读作**“指向int的指针”或简称“int指针”**。【int*,float*,char*，是三种不同的类型，不能混淆】\n 4. 指针变量中只能存放地址（指针），不要将一个整数赋给指针变量。\n    * 如:*pointer_1=100; //pointer_1是指针变量，100是整数，不合法\n\n如果需要取出某个变量的地址，可以使用取址运算符&:\n\n例如：\n\nchar *pa = &a;\nint *pb = &b;\n\n\n1\n2\n\n\n如果需要访问指针变量指向的数据类型，可以使用取值运算符*:\n\n例如：\n\nprintf("%c,%d\\n",*pa,*pb);\n\n\n1\n\n\n----------------------------------------\n\n访问地址里的值的两种方式：\n\n直接访问：即按变量名进行的访问。\n\n间接访问：即通过指针变量进行的访问。\n\n注意：避免访问未初始化的指针。【因为未初始化的指针指向的地址是随机的，未初始化就使用是非常危险的！！！】\n\n例如：【以下示例为错误的】\n\n#include <stdio.h>\nmain(){\n\tint  *a;\n    *a = 123;\n}\n\n\n1\n2\n3\n4\n5\n\n\n指针与指针变量\n\n如果有一个变量专门来存放另一变量的地址（即指针），则称它为**“指针变量”**。\n\n指针变量就是地址变量，用来存放地址，指针变量的值就是地址（即指针）。\n\n**注意：**区分 “指针” 和 “指针变量” 这两个概念。指针就是一个地址，而指针变量是存放地址值的变量。\n\n\n# 2. 引用指针变量\n\n在引用指针变量时，可能有3种情况：\n\n * 给指针变量赋值。\n   * 如：p = &a; //把 a 的地址赋给指针变量 p。\n   * 指针变量p的值是变量a的地址，p指向a。\n * 引用指针变量指向的变量。\n   * 如果已经执行p=&a;，即指针变量p指向了整型变量a，则printf("%d",*p);\n   * 其作用是以整数形式输出变量p指向的变量的值，即变量a的值。\n * 引用指针变量的值。\n   * 如：printf("%o",p);\n   * 其作用是以八进制整数输出指针变量的值，如果p指向变量a，就是输出了a的地址，即&a。\n\n注意：要熟练掌握两个有关运算符。\n\n * & 取地址运算符。&a是变量a的地址。\n * * 指针运算符（或称“间接访问”运算符），*p代表指针变量p指向的对象。\n\n----------------------------------------\n\n指针变量作为函数参数\n\n函数的参数不仅可以是整数型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。\n\n注意：不能企图通过改变指针形参的值而使指针实参的值改变。\n\n----------------------------------------\n\n\n# 3. 通过指针引用数组\n\n指针变量既然可以指向变量，当然也可以指向数组元素（把某一元素的地址放到一个指针变量中）。所谓数组元素的指针就是数组元素的地址。\n\n将数组元素地址赋值给指针变量，如：\n\nint a[10]={1,3,5,7,9,11,13,15,17,19};//定义a为包含10个整型数据的数组\nint *P;\t\t\t\t\t\t\t\t //定义p为指向整型变量的指针变量\np = &a[0];\t\t\t\t\t\t\t //把a[0]元素的地址赋给指针变量p\n\n\n1\n2\n3\n\n\n下标法赋值：\n\n指针变量 = &数组名[数值]; 将下表为 数组名[数值] 的元素地址，赋值给 指针变量。\n\n不加标赋值：\n\n指针变量 = 数组名;将数组的首元素【即数组名[0]】地址赋值给指针变量。\n\n下面两个语句等价：\n\nint *p;\n p = &a[0];\n-------------------\nint *p;\np = a;\n\n\n1\n2\n3\n4\n5\n\n\n引用数组元时指针的运算\n\n在指针已指向一个数组元素时，可以对指针进行以下运算：\n\n * 加一个整数（用+或+=），如p+1；\n * 减一个整数（用-或-=），如p-1；\n * 自加运算，如：p++; ++p;\n * 自减运算，如：p--; --p;\n\n两指针相减，如：p1-p2（只有p1和p2都指向同一数组中的元素时才有意义）。\n\n分别说明如下：\n\n * 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组元素中的上一个元素。\n   * 注意：执行p+1时并是将p的值（地址）简单的加1，而是加上一个数组元素所占的字节数。\n   * 例如：数组元素是float型，每个元素是float型，每个元素占4个字节，则p+1意味着使p的值（地址）加4个字节，以使它指向下一元素。\n * 如果p的初值为&a[0],则表示p+i和a+i就是数组元素a[i]的地址。\n * *(p+i)或*(a+i)是p+i或a+i所指向的数组元素，即a[i]。\n   * 说明：[]实际上是变址运算符，即将a[i]按a+i计算然后找出此地址单元中的地址。\n * 如果指针变量p1和p2都指向同一组数组中的元素，如执行p2-p1,结果是p2-p1的值（两个地址之差）除以数组元素的的长度。\n   * 注意：两个地址不能相加，如p1+p2是无实际意义的。\n\n----------------------------------------\n\n通过指针引用数组元素\n\n引用一个数组元素，可以用下面两种方法：\n\n * 下标法：如a[i]形式；\n * 指针法：如*(a+i)或*(p+i)。其中 a 是数组名，p 是指向数组元素的指针变量，其初值p=a。\n\n指向数组元素的指针变量也可以带下标，如p[i]。\n\n++ 和 * 同优先级，结合方向为自左向右。\n\n*(p++)与*(++p)，作用不相同。\n\n * *(p++):是先取*p的值，然后使p+1。\n * *(++p):是先p+1，然后再取*p的值。\n\n++(*p)：表示p所指向的元素值加1。\n\n--(*p)：表示p所指向的元素值减1。\n\n所以：\n\n * *(++p)相当与a[++i]，先使p自加，再进行*运算。\n * *(--p)相当与a[--i]，先使p自减，再进行*运算。\n\n用数组名做函数参数\n\n数组名做函数参数方法定义一般形式为：\n\n返回值类型 方法名(参数类型 数组名[],参数列表……){\n    方法体;\n    返回值;\n}\n\n\n1\n2\n3\n4\n\n\n指针做函数参数定义一般形式为：\n\n返回值类型 方法名(参数类型 *数组名,参数列表……){\t//这里的 “*数组名” 表示数组的首元素地址 “数组名[0]”\n    方法体;\n    返回值;\n}\n\n\n1\n2\n3\n4\n\n\n两种定义方法等价。\n\n*数组名等价于数组名[0]。\n\n**注意：**数组名做方法参数时，传递的是数组首元素的地址，而非元素值。\n\n常用这种方法通过调用一个函数来改变实参数组的值。\n\n以表变量名和数组名作为函数参数的比较\n\n参数类型             变量名          数组名\n要求的形参类型          变量名          数组名或指针\n传递参数             变量的值         实参数组首元素地址\n通过函数调用能否改变实参的值   不能改变实参变量的值   能改变实参数组的值\n\n**注意：**实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。\n\n在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它还可以再被赋值。\n\n**归纳分析：**如果有一个实参数组，想要在函数中改变此数组中的元素的值，实参与形参的对应关系有以下4种情况。\n\n * 形参和实参都用数组名。\n   * 例如：\n\nint main(){\n    int a[10];\n    ...\n    f(a,10);\n    ...\n}\nint f(int x[],int n){\n    ...\n}\n//由于形参数组名x接收了实参数组首元素a[0]的地址值，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参用数组名，形参用指针变量。\n   * 例如：\n\nint main(){\n    int a[10];\n    ...\n    f(a,10);\n    ...\n}\nvoid f(int *x,int n){\n    ...\n}\n//实参a为数组名，形参数组x为int * 型的指针变量，调用函数开始后，形参x指向a[0],即x=&a[0]。通过x的值改变，可以指向a数组的任一元素。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参形参都用指针变量。\n   * 例如：\n\nint main(){\n    int a[10], *p = a;\n    ...\n    f(p,10);\n    ...\n}\nvoid f(int *x,int n){\n    ...\n}\n//实参p和形参x都是int * 型的指针变量。先使实参指针变量p指向数组a[0]，p的值是&a[0]。然后将p的值传给指针变量x，x的初始值也是&a[0],通过x值的改变可以使x指向数组元素a的任一元素。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参为指针变量，形参为数组名。\n   * 例如：\n\nint main(){\n    int a[10], *p = a;\n    ...\n    f(p,10);\n    ...\n}\nvoid f(int x[],int n){\n    ...\n}\n//实参p为指针变量，它指向a[0]。形参为数组名x，编译系统把x作为指针变量处理，今将a[0]的地址传给形参x，使x也指向a[0]。也可以理解为形参数组x和a数组共用同一段内存单元。在函数执行过程中可以使x[i]的值发生变化，而x[i]就是a[i]。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n**注意：**如果使用指针变量作实参，必须先使指针变量有确定值，指向一个以定义的对象。\n\n以上4种方法，实质上都是地址的传递。其中（3）、（4）两种只是形式上的不同，实际上形参都是使用指针变量。\n\n通过指针引用多维数组\n\n指针引用多维数组：除了表示取元素之外，还可以表示取哪一维\n\n对于二维数组： 1、\n\na是一个行指针。指向一个有四个元素的数组，占16个字节 &a是一个指向二维数组的指针，二维数组有12个元素，占48个字节 *a是一个指向int类型数据的指针。\n\n2、 a[i][j]等价于*((a+i)+j)，&a[i][j]等价于(a+i)+j a[i]等价于*(a+i)，&a[i]\n\n3、 二维数组名是指向行的，它不能对如下说明的指针变量p直接赋值：\n\nint a[3][4]={{10,11,12,13},{20,21,22,23},{30,31,32,33}},*p;\n\n\n1\n\n\n其原因就是p与a的对象性质不同，或者说二者不是同一级指针。C语言可以通过定义行数组指针的方法，使得一个指针变量与二维数组名具有相同的性质。\n\n行数组指针的定义方法如下： 数据类型 (*指针变量名)[二维数组列数];\n\n例如，对上述a数组，行数组指针定义如下： int (p)[4];它表示，数组p有4个int型元素，分别为(*p)[0]、(*p)[1]、(*p)[2]、(*p)[3]，亦即p指向的是有4个int型元素的一维数组，即p为行指针\n\n此时，可用如下方式对指针p赋值： p=a;\n\n----------------------------------------\n\n指针访问三维数组 数组与指针关系密切，数组元素除了可以使用下标来访问，还可用指针形式表示。数组元素可以很方便地用数组名常指针来表示，以3维int型数组A举例，其中的元素A[i][j][k]可用下述形式表示：\n\n（1）*(A[i][j]+k) A[i][j]是int型指针，其值为&A[i][j][0]，因此，A[i][j][k]可表述为*(A[i][j]+k)。 （2）*(*(A[i]+j)+k) 和第一种形式比较，不难发现A[i][j]= *(A[i]+j)，A[i]是二级指针，其值为&A[i][0]。 （3）*(*(*(A+i)+j)+k) 将第2种形式的A[i]替换成了*(A+i)，此处A是三级指针，其值为&A[0]。 此处以3维数组举例，还可进一步推广到更高维的情况。\n\n----------------------------------------\n\n指针数组 指针也可作为数组中的元素，将一个个指针用数组形式组织起来，就构成了指针数组。\n\n一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。\n\n定义一维指针数组的一般形式为:\n\n类型名 *数组名[数组长度];\nint *p[4];\n\n\n1\n2\n\n\n----------------------------------------\n\n用指向数组的指针作函数参数\n\n一维数组名可以做函数参数，多维数组名可以做函数参数。用指针变量作形参，以接受实参数组名传递过来的地址。\n\n可以有两种方法：\n\n * 用指向变量的指针变量。\n * 用指向一维数组的指针变量。\n\n\n# 4. 通过指针引用字符串\n\n字符串的应用方式：\n\n * 用字符数组存放一个字符串，可以通过数组名和下标引用字符串中的一个字符，也可以通过数组名和格式声明%s输出该字符串。\n\n#include <stdio.h>\nmain(){\n    char *string;\n    string="I love you";\n    printf("%s\\n",string);\n\n    char string2[]="I love you";\n    printf("%s\\n",string2);\n    \n    char string3[]={"I love you"};\n    printf("%s\\n",string3);\n}\n//三种定义形式输出结果一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 用指针变量访问字符串。通过改变指针变量的值使它指向字符串中的不同字符。\n\n使用字符串指针变量和字符数组的比较\n\n 1. 字符串由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中。\n 2. 赋值方式。可以对字符串指针变量赋值，但不能对数组名赋值。\n 3. 初始化定义。对字符指针变量赋初值：\n\nchar *a="I love china!";\n//等价于\nchar *a；\na = "I Love china!";\n//而对数组的初始化：\nchar str[14]="I love china!";\n//不等价于\nchar str[14];\nstr[]="I love china!";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n数组可以在定义时对各元素赋初值，但不能用赋值语句对字符串数组中全部元素整体赋值。\n\n 4. 存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。\n    * 如果定义了字符数组，但未能对它赋值，这时数组中的元素的值是不可预料的。可以引用（如输出）这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和更正。\n    * 如果定义了字符指针变量，应当及时把字符变量（或字数组元素）的地址赋给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量指向的对象输入数据，可能会出现严重的后果。\n 5. 指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。\n 6. 字符数组中各元素的值是可以取代的（可以对它们在赋值），但字指针变量指向的字符串常量中的内容是不可以被取代的（不能对他它们在赋值）。\n 7. 引用数组元素。对字符数组可以用下标法（用数组名和下标）引用一个数组元素，也可以用地址法引用数组元素。\n 8. 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。\n\nchar *format;\nformat = "a=%d,b=%f\\n";//使format指向一个字符串\nprintf(format,a,b);\n//这种printf函数称为可变格式输出函数。\n\n\n1\n2\n3\n4\n\n\n字符指针做函数参数\n\n实参和形参都可以选择字符数组名和字符指针变量，但存在区别： （1）编译时为字符数组分配若干存储单元，以存放个元素的值，而对字符指针变量，只分配一个存储单元 （2）指针变量的值是可以改变的，而数组名代表一个固定的值（数组首元素的地址），不能改变\n\nchar *a="i am a student"\na=a+7;   //合法的\n\nchar str[]={"i am a student"};\nstr=str+7  //非法的\n\n\n1\n2\n3\n4\n5\n\n\n（3）字符数组中各元素的值是可以改变的，但字符指针变量指向的字符串常量中的内容是不能改变的\n\nchar a[]="house";\nchar *b="house";\na[2]=\'r\';    //合法  \n*(b+2)=\'r\';  //非法 \n\n\n1\n2\n3\n4\n\n\n接着，引入一个用字符数组名作为函数参数的例子，实现字符串的复制\n\n#include<stdio.h>\nint main(){\n    void copy_string(char from[] ,char to[]);\n    char a[]="i am a teacher";\n    char b[]="you are a student";\n    \n    copy_string(a,b);  //把a复制到b\n    printf("%s\\n%s",a,b); \n} \nvoid copy_string(char from[], char to[]){\n    int i=0;\n    while(from[i]!=\'\\0\'){\n        to[i]=from[i]; i++;\n    }\n    to[i]=\'\\0\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5. 指向函数的指针\n\n函数名就是函数的指针，它代表函数的起始地址。\n\n定义和使用指向函数的指针变量\n\n定义指向函数的指针变量的一般形式为：\n\n类型名 (*指针变量名)(函数参数列表)\n\n这里的 “类型名” 是指函数的返回类型。\n\n说明：\n\n 1. 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。\n    * 在程序中把哪一个函数的地址赋给它，它就指向哪一个函数。在一个程序运行中，一个指针变量可以先后指向同类型的不同函数。\n 2. 如果要用指针调用函数，必须先使用指针变量指向该函数。\n    * 如：指针变量名 = 函数名 ;这样就把 “函数名” 的入口地址赋给了指针变量 “指针变量名“ 。\n 3. 在给函数指针变量赋值时，只须给出函数名而不必给出参数。\n 4. 用函数指针变量调用函数时，只需将（*指针变量名）代替函数名即可，在（`*指针变量名）之后的括号中根据需要写上实参。\n 5. 对指向函数的指针变量不能进行算数运算，如p+n,p++,p--等运算是无意义的。\n 6. 用函数名调用函数，只能调用所指定的一个函数，而通过指针变量比较灵活，可以根据不同情况先后调用不同的函数。\n\n----------------------------------------\n\n用指向函数的指针作函数参数\n\n指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数。\n\n指向函数的指针可以作为函数参数，把函数的入口地址传递给形参，这样就能够在被调用的函数中使用实参函数。\n\n它的原理简述如下：\n\n有一个函数（假设函数名为fun），它有两个形参（x1和x2），定义x1和x2为指向函数的指针变量。再调用函数fun时，实参为两个函数名f1和f2，给形参传递的是f1和f2的入口地址。这样在函数fun中就可以调用f1和f2函数了。\n\n例如：\n\n实参函数名       f1\t\t\t\tf2\nvoid fun(int (*x1)(int),int (*x2)(int,int))//定义fun函数，形参是指向函数的指针变量\n{\n    int a,b,i=3,j=5;\n    a=(*x1)(i);\t\t//调用f1函数，i是实参\n    b=(*x2)(i,j);\t//调用f2函数，i、j是实参\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在fun函数中声明形参x1和x2为指向函数的指针变量，x1指向的函数有一个整型形参，x2指向的函数有两个整型实参。函数fun的形参x1和x2（指针变量）在函数fun未被调用时并不占内存单元，也不指向任何函数。在主函数调用fun函数时，把实参函数f1和f2的入口地址传给形参指针变量x1和x2，使x1和x2指向函数f1和f2。这时，在函数fun中，用*x1和*x2就可以调用函数f1和f2。(*x1)(i)就相当于f1(i),(*x2)(i,j)就相当于f2(i,j)。\n\n\n# 6. 返回指针值的函数\n\n定义返回指针的函数的原型一般形式为：\n\n类型名 *函数名(参数列表);\n\n\n1\n\n\n例如：\n\nint *a(int x,int y);\n\n\n1\n\n\na是函数名，调用它以后能得到一个int*型（指向整型数据）的指针，即整型数据的地址。x和y是函数a的形参，为整型。\n\n请注意在*a两侧没有括号，在a的两侧分比是*运算符和()运算符。而()优先级高于*，因此a先与()结合，显然这是函数形式。这个函数前面有一个*，表示此函数是指针型函数（函数值是指针）。最前面的int表示返回的指针指向整型变量。\n\n\n# 7. 指针数组和多重指针\n\n定义一维指针数组的一般形式为：\n\n类型名 *数组名[数组长度];\n\n\n1\n\n\n类型名中应包括符号*，如int*表示指向整数数据的指针类型。\n\n例如：\n\nint *p[4];\n\n\n1\n\n\n由于[]比*优先级高，因此p先与[4]结合，形成p[4]形式，表示p数组有4个元素。然后再与p前面的*结合，*表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都指向一个整型变量。\n\n注意一定不要写成：\n\nint (*p)[4];\t//这是指向一维数组的指针变量\n\n\n1\n\n\n指向指针数据的指针变量\n\n定义一个指向指针数据类型的指针变量：\n\nchar **p;\n\n\n1\n\n\np的前面有两个*号。*运算符的结合性是从右到作，因此**p相当于*(*p)，显然*p是指针变量的定义形式。如果没有最前面的*,那就是定义了一个指向字符数据的指针变量。现在它前面又有一个*号，即char**p。可以把它分成两部分看，即：char*和( *p),后面的( *p)表示P是指针变量,前面的char*表示p指向的是char*型的数据。也就是说,P指向一个字符指针变量（这个字符指针变量指向一个字符型数据）。\n\n例如：使用指向指针数据的指针变量。\n\n#include<stdio.h>\nmain(){\n    char *name={"Follw me","BASIC","Great Wall","FORTRAN","Computer design"};\n    char **p;\n    int i;\n    for(i=0;i<5;i++){\n        p=name+i;\n        printf("%s\\n",**p);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n指针数组作main函数的形参\n\nmain函数的第1行一般写成以下形式：\n\nint main()或int main(void)\n\n括号中是空的或有“void”，表示main函数没有参数，调用main函数时不必给出实参。\n\n这是一般程序常采用的形式。实际上，在某些情况下，main函数可以有参数，即：\n\nint main(int arge,char * argv[])\n\n\n1\n\n\n其中，argc和argv就是main函数的形参，它们是程序的“命令行参数”。\n\narge ( argument count的缩写,意思是参数个数) ，argv(argument vector` 缩写,意思是参数向量),它是一个*char指针数组，数组中每一个元素（其值为指针）指向命令行中的-个字符串的首字符。\n\n**注意：**如果用带参数的main函数，其第一个形参必须是int 型,用来接收形参个数，第二个形参必须是字符指针数组，用来接收从操作系统命令行传来的字符串中首字符的地址。通常main函数和其他函数组成一个文件模块，有一个文件名。对这个文件进行编译和连接，得到可执行文件(后缀为.exe)。用户执行这个可执行文件，操作系统就调用main函数，然后由main函数调用其他函数，从而完成程序的功能。\n\n什么情况下main函数需要参数?main函数的形参是从哪里传递给它们的呢？\n\n显然形参的值不可能在程序中得到。main函数是操作系统调用的，实参只能由操作系统给出。在操作命令状态下，实参是和执行文件的命令一起给出的。例如在DOS,UNIX或Linux等系统的操作命令状态下，在命令行中包括了命令名和需要传给main函数的参数。\n\n命令行的一般形式为：\n\n命令名 参数1 参数2 ... 参数n\n\n\n1\n\n\n命令名和各参数之间用空格分隔。\n\n\n# 8. 动态内存分配与指向它的指针变量\n\n对内存动态分配是通过系统提供的函数库来实现的，主要有 molloc ，calloc ，free ，realloc 这4个函数。\n\n * 用malloc函数开辟动态存储区：\n\n其函数原型为：\n\nvoid * malloc(unsigned int size);\n\n\n1\n\n\n其作用是在内存的动态存储区中分配一个长度为size 的连续空间。形参size的类型定为无符号整型(不允许为负数)。\n\n此函数的值(即“返回值")是所分配区域的第一个字节的地址，或者说,此函数是一个指针型函数，返回的指针指向该分配域的第一个字节。如:\n\nmalloc( 100);\t\t//开辟100字节的临时分配域.函数值为其第1个字节的地址\n\n\n1\n\n\n注意指针的基类型为void，即不指向任何类型的数据，只提供一个纯地址。\n\n如果此函数未能成功地执行(例如内存空间不足)，则返回空指针(NULL)。\n\n * 用calloc函数开辟动态存储区：\n\n其函数原型为：\n\nvoid * calloc(unsigned n,unsigned size);\n\n\n1\n\n\n其作用是在内存的动态存储区中分配n个长度为size 的连续空间,这个空间一般比较大，足以保存一个数组。\n\n用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是动态数组。函数返回指向所分配域的第一个字节的指针；如果分配不成功，返回NULL。\n\n如:\n\np= calloc(50.4);\t\t//开辟50X4个字节的临时分配域,把首地址赋给指针变量p\n\n\n1\n\n * 用realloc函数重新分配动态存储区\n\n其函数原型为：\n\nvoid * realloc(void * p,unsigned int size);\n\n\n1\n\n\n如果已经通过 malloc 函数或 calloc 函数获得了动态空间，想改变其大小，可以用 recalloc 函数重新分配。\n\n用realloc函数将p所指向的动态空间的大小改变为size。p的值不变。如果重分配不成功,返回NULL。\n\n如：\n\nrealloc(p,50);\t\t//将p所指向的已分配的动态空间改为50字节\n\n\n1\n\n * 用free函数释放动态存储区\n\n其函数原型为：\n\nvoid free(void * p);\n\n\n1\n\n\n其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的函数返回值。\n\n如：\n\nfree(p);\t\t//释放指针变量p所指向的已分配的动态空间\n\n\n1\n\n\nfree函数无返回值。\n\n**注意：**以上4个函数的声明在stdlib. h头文件中,在用到这些函数时应当用“# include<stdlib.h>”指令把stdlib.h头文件包含到程序文件中。\n\nvoid指针类型\n\nC99允许使用基类型为void的指针类型。可以定义一个基类型为void的指针变量（即void*型变量），它不指向任何类型的数据。请注意：不要把 “指向void类型” 理解为能指向 “任何的类型” 的数据，而应理解为 “指向空类型” 或 “不指向确定的类型“ 的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。\n\n例如:\n\nint a=3;\t\t\t\t\t\t\t//定义a为整型变量\n\nint *p1=&a;\t    \t\t\t\t\t//p1指向int型变量\n\nchar *p2;\t\t\t\t\t\t\t//p2指向char型变量\n\nvoid *p3;\t\t\t\t\t\t\t//p3为无类型指针变量(基类型为void型)\n\np3=(void*)p1;\t\t\t\t\t\t//将p1的值转换为void*类型,然后赋值给p3\n\np2= (char*)p3;\t\t\t\t\t\t//将p3的值转换为char*类型,然后赋值给p2\n\nprintf("%d",* p1);\t\t\t\t\t//合法,输出整型变量a的值\n\np3= &a; printf("%d",* p3);  \t\t//错误,p3是无指向的,不能指向a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这种空类型指针在形式上和其他指针一样，遵循C语言对指针的有关规定，它也有基类型,只是它的基类型是void。\n\n可以这样定义:\n\nvoid * p;\t\t\t//定义p是void*型的指针变量\n\n\n1\n\n\nvoid*型指针代表“无指向的地址”，这种指针不指向任何类型的数据。不能企图通过它存取数据，在程序中它只是过渡性的，只有转换为有指向的地址，才能存取数据。\n\nC 99这样处理,更加规范，更容易理解，概念也更清晰。\n\n现在所用的一些编译系统在进行地址赋值时，会自动进行类型转换。\n\n例如：\n\nint * pt;\npt= (int*)mcaloc(100);\t\t\t//mcaloc(100)是void *型，把它转换为int*型\n可以简化为\npt= mcaloc(100);\t\t\t\t//自动进行类型转换\n\n\n1\n2\n3\n4\n\n\n赋值时，系统会先把mcaloc(100)转换为的pt的类型，即(int* )型，然后赋给pt,这样pt就指向存储区的首字节，在其指向的存储单元中可以存放整型数据。\n\n\n# 9. 有关指针的小结\n\n(1)首先要准确理解指针的含义。“指针”是C语言中一个形象化的名词,形象地表示“指向”的关系，其在物理上的实现是通过地址来完成的。正如高级语言中的“变量”，在物理上是“命名的存储单元”。Windows中的“文件夹”实际上是“目录”。离开地址就不可能弄清楚什么是指针。明确了“指针就是地址”，就比较容易理解了，许多问题也迎办而解了。\n\n例如：\n\n * &a是变量a的地址,也可称为变量a的指针。\n\n * 指针变量是存放地址的变量,也可以说,指针变量是存放指针的变量。\n\n * 指针变量的值是一个地址,也可以说，指针变量的值是- 一个指针。\n\n * 指针变量也可称为地址变量,它的值是地址。\n\n * &是取地址运算符，&a是a的地址,也可以说，&是取指针运算符。&a是变量a的指针（即指向变量a的指针）。\n\n * 数组名是一个地址，是数组首元素的地址，也可以说，数组名是一个指针,是数组首元素的指针。\n\n * 函数名是一个指针（指向函数代码区的首字节），也可以说函数名是一个地址（函数代码区首字节的地址）。\n\n * 函数的实参如果是数组名，传递给形参的是一个地址，也可以说，传递给形参的是一个指针。\n\n(2) 在C语言中，所有的数据都是有类型的，例如常量123并不是数学中的常数123，数学中的123是没有类型的，123和123.0是一样的，而在C语言中，所有数据都要存储在内存的存储单元中，若写成123，则认为是整数，按整型的存储形式存放，如果写成123.0，则认为是单精度实数，按单精度实型的存储形式存放。此外，不同类型数据有不同的运算规则。可以说，C语言中的数据都是“有类型的数据”，或称“带类型的数据”。\n\n对地址而言，也是同样的，它也有类型，首先，它不是一个数值型数据，不是按整型或浮点型方式存储，它是按指针型数据的存储方式存储的（虽然在VisualC++中也为指针变量分配4个字节，但不同于整型数据的存储形式）。指针型存储单元是专门用来存放地址的，指针型数据的存储形式就是地址的存储形式。\n\n其次，它不是一个简单的纯地址，还有一个指向的问题，也就是说它指向的是哪种类型的数据。如果没有这个信息,是无法通过地址存取存储单元中的数据的。所以，一个地址型的数据实际上包含3个信息：\n\n①表示内存编号的纯地址。\n\n②它本身的类型，即指针类型。\n\n③以它为标识的存储单元中存放的是什么类型的数据，即基类型。\n\n例如：已知变量为a为int型，&a为a的地址，它就包括以上3个信息，它代表的是一个整型数据的地址，int是&a的基类型（即它指向的是int型的存储单元）。可以把②和③两项合成一项，如 “指向整型数据的指针类型” 或 “基类型为整型的指针类型” ，其类型可以表示为“int*”型。这样，对地址数据来说，也可以说包含两个要素：内存编号（纯地址）和类型（指针类型和基类型）。这样的地址是 “带类型的地址” 而不是纯地址。\n\n(3)要区别指针和指针变量。指针就是地址，而指针变量是用来存放地址的变量。有人认为指针是类型名，指针的值是地址。这是不对的。类型是没有值的，只有变量才有值，正确的说法是指针变量的值是一个地址。不要杜撰出 “地址的值” 这样莫须有的名词。地址本身就是一个值。\n\n(4)什么叫 “指向” ？地址就意味着指向，因为通过地址能找到具有该地址的对象。对于指针变量来说，把谁的地址存放在指针变量中，就说此指针变量指向谁。但应注意：并不是任何类型数据的地址都可以存放在同一个指针变量中的，只有与指针变量的基类型相同的数据的地址才能存放在相应的指针变量中。\n\n例如：\n\nint a,*P;\t//p是int关型的指针变量,基类型是int型\n\nfloat b;\n\np= &a;\t\t//a是int型,合法\n\np=&b;\t\t//b是float型,类型不匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n既然许多数据对象（如变量数组、字符串和函数等）都在内存中被分配存储空间，就有了地址，也就有了指针。可以定义一些指针变量，分别存放这些数据对象的地址，即指向这些对象。void*指针是一种特殊的指针，不指向任何类型的数据。如果需要用此地址指向某类型的数据，应先对地址进行类型转换。可以在程序中进行显式的类型转换，也可以由编译系统自动进行隐式转换。无论用哪种转换，读者必须了解要进行类型转换。\n\n(5)要深入掌握在对数组的操作中正确地使用指针，搞清楚指针的指向。一维数组名代表数组首元素的地址，如：\n\nint *p,a[10];\np=a;\n\n\n1\n2\n\n\np是指向int型类型的指针变量，显然，p只能指向数组中的元素（int型变量），而不是指向整个数组。在进行赋值时一定要先确定赋值号两侧的类型是否相同，是否允许赋值。\n\n对"p=a;" ，准确地说应该是： p指向a数组的首元素，在不引起误解的情况下，有时也简称为：p指向a数组，但读者对此应有准确的理解。同理，p 指向字符串，也应理解为p指向字符串中的首字符。\n\n(6)有关指针变量的归纳比较\n\n指针变量的类型及含义\n\n变量定义           类型表示        含义\nint i;         int         定义整型变量\nint *p;        int *       定义p为指向整型数据的指针变量\nina a[5];      int [5]     定义整型数组a，它有5个元素\nint *p[4];     int * [4]   定义指针数组p，它由4个指向整型数据的指针元素组成\nint (*p)[4];   int(*)[4]   p为指向包含4个元素的一维数组的指针变量\nint f();       int ()      f为返回整型函数值的函数\nint *p();      int * ()    p为返回一个指针的函数，该指针指向整型数据\nint(*p)();     int(*)()    p为指向函数的指针，该函数返回一个整型值\nint **p;       int **      p是一个指针变量，它指向一个指向整型数据的指针变量\nvoid *p;       void *      p是一个指针变量，基类型为void（空类型），不指向具体的对象\n\n为便于比较,在表中包括了其他一些类型的定义。\n\n(7)指针运算。\n\n①指针变量加（减）一个整数。\n\n例如: p++,p--,p+i,p-i,p+=i,p-=i等均是指针变量加(减)一个整数。\n\n将该指针变量的原值（是一个地址）和它指向的变量所占用的存储单元的字节数相加（减）。\n\n②指针变量赋值。\n\n将一个变量地址赋给一个指针变量。\n\n例如：\n\np= &a;\t\t\t\t//(将变量a的地址赋给p)\n\nP= array;\t\t\t//(将数组array首元素地址赋给p)\n\np= &array[i];\t\t//(将数组array 第i个元素的地址赋给p)\n\np= max;\t\t\t\t//(max为已定义的函数.将max的人口地址赋给p)\n\np1= p2;\t\t\t\t//(pl和p2是基类型相同指针变量,将p2的值赋给pl)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：不应把一个整数赋给指针变量。\n\n③两个指针变量可以相减。\n\n如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之差是两个指针之间的元素个数。\n\n④两个指针变量比较。\n\n若两个指针指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量“小于”指向后面元素的指针变量。如果p1和p2不指向同一数组则比较无意义。\n\n(8)指针变量可以有空值，即该指针变量不指向任何变量，可以这样表示：p= NULL;\n\n其中，NULL是一个符号常量，代表整数0。在stdio.h头文件中对NULL进行了定义:#define NULL 0\n\n它使p指向地址为0的单元。系统保证使该单元不作它用(不存放有效数据)。\n\n应注意，p的值为NULL与未对p赋值是两个不同的概念。前者是有值的（值为0），不指向任何变量，后者虽未对p赋值但并不等于p无值,只是它的值是一个无法预料的值，也就是p可能指向一个事先未指定的单元。这种情况是很危险的。因此，在引用指针变量之前应对它赋值。\n\n任何指针变量或地址都可以与NULL作相等或不相等的比较，例如:\n\nif(p==NULL){\n    ...\n}\n\n\n1\n2\n3\n\n\n指针是C语言中很重要的概念，是C的一个重要特色。\n\n使用指针的优点：\n\n①提高程序效率；\n\n②在调用函数时当指针指向的变量的值改变时,这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值；\n\n③可以实现动态存储分配。\n\n同时应该看到，指针使用实在太灵活，对熟练的程序人员来说，可以利用它编写出颇有特色、质量优良的程序，实现许多用其他高级语言难以实现的功能，但也十分容易出错，而且这种错误往往比较隐蔽。指针运用的错误可能会使整个程序遭受破坏，比如由于未对指针变量p赋值就向* p赋值，就可能破坏了有用的单元的内容。如果使用指针不当，会出现隐蔽的、难以发现和排除的故障。因此，使用指针要十分小心谨慎，要多上机调试程序，以弄清一些细节，并积累经验。',normalizedContent:'# 第五章 指针【c语言的灵魂】\n\n\n# 1. 指针及指针变量【概念、定义】\n\n定义指针变量：类型名称 *指针变量名;\n\n在定义指针变量时要注意：\n\n 1. 指针变量前面的“*”表示该变量为指针型变量。\n 2. 在定义指针变量时必须**指定基类型。**指针的基类型用来定义此指针变量可以指向的变量的类型。一个变量的指针的含义包括两个方面，一是存储单元编号表示的纯地址，一是它指向的存储单元的数据类型（如int、char、float等）。\n 3. 指向整型数据的指针类型表示为“int*”，读作**“指向int的指针”或简称“int指针”**。【int*,float*,char*，是三种不同的类型，不能混淆】\n 4. 指针变量中只能存放地址（指针），不要将一个整数赋给指针变量。\n    * 如:*pointer_1=100; //pointer_1是指针变量，100是整数，不合法\n\n如果需要取出某个变量的地址，可以使用取址运算符&:\n\n例如：\n\nchar *pa = &a;\nint *pb = &b;\n\n\n1\n2\n\n\n如果需要访问指针变量指向的数据类型，可以使用取值运算符*:\n\n例如：\n\nprintf("%c,%d\\n",*pa,*pb);\n\n\n1\n\n\n----------------------------------------\n\n访问地址里的值的两种方式：\n\n直接访问：即按变量名进行的访问。\n\n间接访问：即通过指针变量进行的访问。\n\n注意：避免访问未初始化的指针。【因为未初始化的指针指向的地址是随机的，未初始化就使用是非常危险的！！！】\n\n例如：【以下示例为错误的】\n\n#include <stdio.h>\nmain(){\n\tint  *a;\n    *a = 123;\n}\n\n\n1\n2\n3\n4\n5\n\n\n指针与指针变量\n\n如果有一个变量专门来存放另一变量的地址（即指针），则称它为**“指针变量”**。\n\n指针变量就是地址变量，用来存放地址，指针变量的值就是地址（即指针）。\n\n**注意：**区分 “指针” 和 “指针变量” 这两个概念。指针就是一个地址，而指针变量是存放地址值的变量。\n\n\n# 2. 引用指针变量\n\n在引用指针变量时，可能有3种情况：\n\n * 给指针变量赋值。\n   * 如：p = &a; //把 a 的地址赋给指针变量 p。\n   * 指针变量p的值是变量a的地址，p指向a。\n * 引用指针变量指向的变量。\n   * 如果已经执行p=&a;，即指针变量p指向了整型变量a，则printf("%d",*p);\n   * 其作用是以整数形式输出变量p指向的变量的值，即变量a的值。\n * 引用指针变量的值。\n   * 如：printf("%o",p);\n   * 其作用是以八进制整数输出指针变量的值，如果p指向变量a，就是输出了a的地址，即&a。\n\n注意：要熟练掌握两个有关运算符。\n\n * & 取地址运算符。&a是变量a的地址。\n * * 指针运算符（或称“间接访问”运算符），*p代表指针变量p指向的对象。\n\n----------------------------------------\n\n指针变量作为函数参数\n\n函数的参数不仅可以是整数型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。\n\n注意：不能企图通过改变指针形参的值而使指针实参的值改变。\n\n----------------------------------------\n\n\n# 3. 通过指针引用数组\n\n指针变量既然可以指向变量，当然也可以指向数组元素（把某一元素的地址放到一个指针变量中）。所谓数组元素的指针就是数组元素的地址。\n\n将数组元素地址赋值给指针变量，如：\n\nint a[10]={1,3,5,7,9,11,13,15,17,19};//定义a为包含10个整型数据的数组\nint *p;\t\t\t\t\t\t\t\t //定义p为指向整型变量的指针变量\np = &a[0];\t\t\t\t\t\t\t //把a[0]元素的地址赋给指针变量p\n\n\n1\n2\n3\n\n\n下标法赋值：\n\n指针变量 = &数组名[数值]; 将下表为 数组名[数值] 的元素地址，赋值给 指针变量。\n\n不加标赋值：\n\n指针变量 = 数组名;将数组的首元素【即数组名[0]】地址赋值给指针变量。\n\n下面两个语句等价：\n\nint *p;\n p = &a[0];\n-------------------\nint *p;\np = a;\n\n\n1\n2\n3\n4\n5\n\n\n引用数组元时指针的运算\n\n在指针已指向一个数组元素时，可以对指针进行以下运算：\n\n * 加一个整数（用+或+=），如p+1；\n * 减一个整数（用-或-=），如p-1；\n * 自加运算，如：p++; ++p;\n * 自减运算，如：p--; --p;\n\n两指针相减，如：p1-p2（只有p1和p2都指向同一数组中的元素时才有意义）。\n\n分别说明如下：\n\n * 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组元素中的上一个元素。\n   * 注意：执行p+1时并是将p的值（地址）简单的加1，而是加上一个数组元素所占的字节数。\n   * 例如：数组元素是float型，每个元素是float型，每个元素占4个字节，则p+1意味着使p的值（地址）加4个字节，以使它指向下一元素。\n * 如果p的初值为&a[0],则表示p+i和a+i就是数组元素a[i]的地址。\n * *(p+i)或*(a+i)是p+i或a+i所指向的数组元素，即a[i]。\n   * 说明：[]实际上是变址运算符，即将a[i]按a+i计算然后找出此地址单元中的地址。\n * 如果指针变量p1和p2都指向同一组数组中的元素，如执行p2-p1,结果是p2-p1的值（两个地址之差）除以数组元素的的长度。\n   * 注意：两个地址不能相加，如p1+p2是无实际意义的。\n\n----------------------------------------\n\n通过指针引用数组元素\n\n引用一个数组元素，可以用下面两种方法：\n\n * 下标法：如a[i]形式；\n * 指针法：如*(a+i)或*(p+i)。其中 a 是数组名，p 是指向数组元素的指针变量，其初值p=a。\n\n指向数组元素的指针变量也可以带下标，如p[i]。\n\n++ 和 * 同优先级，结合方向为自左向右。\n\n*(p++)与*(++p)，作用不相同。\n\n * *(p++):是先取*p的值，然后使p+1。\n * *(++p):是先p+1，然后再取*p的值。\n\n++(*p)：表示p所指向的元素值加1。\n\n--(*p)：表示p所指向的元素值减1。\n\n所以：\n\n * *(++p)相当与a[++i]，先使p自加，再进行*运算。\n * *(--p)相当与a[--i]，先使p自减，再进行*运算。\n\n用数组名做函数参数\n\n数组名做函数参数方法定义一般形式为：\n\n返回值类型 方法名(参数类型 数组名[],参数列表……){\n    方法体;\n    返回值;\n}\n\n\n1\n2\n3\n4\n\n\n指针做函数参数定义一般形式为：\n\n返回值类型 方法名(参数类型 *数组名,参数列表……){\t//这里的 “*数组名” 表示数组的首元素地址 “数组名[0]”\n    方法体;\n    返回值;\n}\n\n\n1\n2\n3\n4\n\n\n两种定义方法等价。\n\n*数组名等价于数组名[0]。\n\n**注意：**数组名做方法参数时，传递的是数组首元素的地址，而非元素值。\n\n常用这种方法通过调用一个函数来改变实参数组的值。\n\n以表变量名和数组名作为函数参数的比较\n\n参数类型             变量名          数组名\n要求的形参类型          变量名          数组名或指针\n传递参数             变量的值         实参数组首元素地址\n通过函数调用能否改变实参的值   不能改变实参变量的值   能改变实参数组的值\n\n**注意：**实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。\n\n在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它还可以再被赋值。\n\n**归纳分析：**如果有一个实参数组，想要在函数中改变此数组中的元素的值，实参与形参的对应关系有以下4种情况。\n\n * 形参和实参都用数组名。\n   * 例如：\n\nint main(){\n    int a[10];\n    ...\n    f(a,10);\n    ...\n}\nint f(int x[],int n){\n    ...\n}\n//由于形参数组名x接收了实参数组首元素a[0]的地址值，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参用数组名，形参用指针变量。\n   * 例如：\n\nint main(){\n    int a[10];\n    ...\n    f(a,10);\n    ...\n}\nvoid f(int *x,int n){\n    ...\n}\n//实参a为数组名，形参数组x为int * 型的指针变量，调用函数开始后，形参x指向a[0],即x=&a[0]。通过x的值改变，可以指向a数组的任一元素。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参形参都用指针变量。\n   * 例如：\n\nint main(){\n    int a[10], *p = a;\n    ...\n    f(p,10);\n    ...\n}\nvoid f(int *x,int n){\n    ...\n}\n//实参p和形参x都是int * 型的指针变量。先使实参指针变量p指向数组a[0]，p的值是&a[0]。然后将p的值传给指针变量x，x的初始值也是&a[0],通过x值的改变可以使x指向数组元素a的任一元素。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 实参为指针变量，形参为数组名。\n   * 例如：\n\nint main(){\n    int a[10], *p = a;\n    ...\n    f(p,10);\n    ...\n}\nvoid f(int x[],int n){\n    ...\n}\n//实参p为指针变量，它指向a[0]。形参为数组名x，编译系统把x作为指针变量处理，今将a[0]的地址传给形参x，使x也指向a[0]。也可以理解为形参数组x和a数组共用同一段内存单元。在函数执行过程中可以使x[i]的值发生变化，而x[i]就是a[i]。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n**注意：**如果使用指针变量作实参，必须先使指针变量有确定值，指向一个以定义的对象。\n\n以上4种方法，实质上都是地址的传递。其中（3）、（4）两种只是形式上的不同，实际上形参都是使用指针变量。\n\n通过指针引用多维数组\n\n指针引用多维数组：除了表示取元素之外，还可以表示取哪一维\n\n对于二维数组： 1、\n\na是一个行指针。指向一个有四个元素的数组，占16个字节 &a是一个指向二维数组的指针，二维数组有12个元素，占48个字节 *a是一个指向int类型数据的指针。\n\n2、 a[i][j]等价于*((a+i)+j)，&a[i][j]等价于(a+i)+j a[i]等价于*(a+i)，&a[i]\n\n3、 二维数组名是指向行的，它不能对如下说明的指针变量p直接赋值：\n\nint a[3][4]={{10,11,12,13},{20,21,22,23},{30,31,32,33}},*p;\n\n\n1\n\n\n其原因就是p与a的对象性质不同，或者说二者不是同一级指针。c语言可以通过定义行数组指针的方法，使得一个指针变量与二维数组名具有相同的性质。\n\n行数组指针的定义方法如下： 数据类型 (*指针变量名)[二维数组列数];\n\n例如，对上述a数组，行数组指针定义如下： int (p)[4];它表示，数组p有4个int型元素，分别为(*p)[0]、(*p)[1]、(*p)[2]、(*p)[3]，亦即p指向的是有4个int型元素的一维数组，即p为行指针\n\n此时，可用如下方式对指针p赋值： p=a;\n\n----------------------------------------\n\n指针访问三维数组 数组与指针关系密切，数组元素除了可以使用下标来访问，还可用指针形式表示。数组元素可以很方便地用数组名常指针来表示，以3维int型数组a举例，其中的元素a[i][j][k]可用下述形式表示：\n\n（1）*(a[i][j]+k) a[i][j]是int型指针，其值为&a[i][j][0]，因此，a[i][j][k]可表述为*(a[i][j]+k)。 （2）*(*(a[i]+j)+k) 和第一种形式比较，不难发现a[i][j]= *(a[i]+j)，a[i]是二级指针，其值为&a[i][0]。 （3）*(*(*(a+i)+j)+k) 将第2种形式的a[i]替换成了*(a+i)，此处a是三级指针，其值为&a[0]。 此处以3维数组举例，还可进一步推广到更高维的情况。\n\n----------------------------------------\n\n指针数组 指针也可作为数组中的元素，将一个个指针用数组形式组织起来，就构成了指针数组。\n\n一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。\n\n定义一维指针数组的一般形式为:\n\n类型名 *数组名[数组长度];\nint *p[4];\n\n\n1\n2\n\n\n----------------------------------------\n\n用指向数组的指针作函数参数\n\n一维数组名可以做函数参数，多维数组名可以做函数参数。用指针变量作形参，以接受实参数组名传递过来的地址。\n\n可以有两种方法：\n\n * 用指向变量的指针变量。\n * 用指向一维数组的指针变量。\n\n\n# 4. 通过指针引用字符串\n\n字符串的应用方式：\n\n * 用字符数组存放一个字符串，可以通过数组名和下标引用字符串中的一个字符，也可以通过数组名和格式声明%s输出该字符串。\n\n#include <stdio.h>\nmain(){\n    char *string;\n    string="i love you";\n    printf("%s\\n",string);\n\n    char string2[]="i love you";\n    printf("%s\\n",string2);\n    \n    char string3[]={"i love you"};\n    printf("%s\\n",string3);\n}\n//三种定义形式输出结果一样\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 用指针变量访问字符串。通过改变指针变量的值使它指向字符串中的不同字符。\n\n使用字符串指针变量和字符数组的比较\n\n 1. 字符串由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中。\n 2. 赋值方式。可以对字符串指针变量赋值，但不能对数组名赋值。\n 3. 初始化定义。对字符指针变量赋初值：\n\nchar *a="i love china!";\n//等价于\nchar *a；\na = "i love china!";\n//而对数组的初始化：\nchar str[14]="i love china!";\n//不等价于\nchar str[14];\nstr[]="i love china!";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n数组可以在定义时对各元素赋初值，但不能用赋值语句对字符串数组中全部元素整体赋值。\n\n 4. 存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。\n    * 如果定义了字符数组，但未能对它赋值，这时数组中的元素的值是不可预料的。可以引用（如输出）这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和更正。\n    * 如果定义了字符指针变量，应当及时把字符变量（或字数组元素）的地址赋给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量指向的对象输入数据，可能会出现严重的后果。\n 5. 指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。\n 6. 字符数组中各元素的值是可以取代的（可以对它们在赋值），但字指针变量指向的字符串常量中的内容是不可以被取代的（不能对他它们在赋值）。\n 7. 引用数组元素。对字符数组可以用下标法（用数组名和下标）引用一个数组元素，也可以用地址法引用数组元素。\n 8. 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。\n\nchar *format;\nformat = "a=%d,b=%f\\n";//使format指向一个字符串\nprintf(format,a,b);\n//这种printf函数称为可变格式输出函数。\n\n\n1\n2\n3\n4\n\n\n字符指针做函数参数\n\n实参和形参都可以选择字符数组名和字符指针变量，但存在区别： （1）编译时为字符数组分配若干存储单元，以存放个元素的值，而对字符指针变量，只分配一个存储单元 （2）指针变量的值是可以改变的，而数组名代表一个固定的值（数组首元素的地址），不能改变\n\nchar *a="i am a student"\na=a+7;   //合法的\n\nchar str[]={"i am a student"};\nstr=str+7  //非法的\n\n\n1\n2\n3\n4\n5\n\n\n（3）字符数组中各元素的值是可以改变的，但字符指针变量指向的字符串常量中的内容是不能改变的\n\nchar a[]="house";\nchar *b="house";\na[2]=\'r\';    //合法  \n*(b+2)=\'r\';  //非法 \n\n\n1\n2\n3\n4\n\n\n接着，引入一个用字符数组名作为函数参数的例子，实现字符串的复制\n\n#include<stdio.h>\nint main(){\n    void copy_string(char from[] ,char to[]);\n    char a[]="i am a teacher";\n    char b[]="you are a student";\n    \n    copy_string(a,b);  //把a复制到b\n    printf("%s\\n%s",a,b); \n} \nvoid copy_string(char from[], char to[]){\n    int i=0;\n    while(from[i]!=\'\\0\'){\n        to[i]=from[i]; i++;\n    }\n    to[i]=\'\\0\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5. 指向函数的指针\n\n函数名就是函数的指针，它代表函数的起始地址。\n\n定义和使用指向函数的指针变量\n\n定义指向函数的指针变量的一般形式为：\n\n类型名 (*指针变量名)(函数参数列表)\n\n这里的 “类型名” 是指函数的返回类型。\n\n说明：\n\n 1. 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。\n    * 在程序中把哪一个函数的地址赋给它，它就指向哪一个函数。在一个程序运行中，一个指针变量可以先后指向同类型的不同函数。\n 2. 如果要用指针调用函数，必须先使用指针变量指向该函数。\n    * 如：指针变量名 = 函数名 ;这样就把 “函数名” 的入口地址赋给了指针变量 “指针变量名“ 。\n 3. 在给函数指针变量赋值时，只须给出函数名而不必给出参数。\n 4. 用函数指针变量调用函数时，只需将（*指针变量名）代替函数名即可，在（`*指针变量名）之后的括号中根据需要写上实参。\n 5. 对指向函数的指针变量不能进行算数运算，如p+n,p++,p--等运算是无意义的。\n 6. 用函数名调用函数，只能调用所指定的一个函数，而通过指针变量比较灵活，可以根据不同情况先后调用不同的函数。\n\n----------------------------------------\n\n用指向函数的指针作函数参数\n\n指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数。\n\n指向函数的指针可以作为函数参数，把函数的入口地址传递给形参，这样就能够在被调用的函数中使用实参函数。\n\n它的原理简述如下：\n\n有一个函数（假设函数名为fun），它有两个形参（x1和x2），定义x1和x2为指向函数的指针变量。再调用函数fun时，实参为两个函数名f1和f2，给形参传递的是f1和f2的入口地址。这样在函数fun中就可以调用f1和f2函数了。\n\n例如：\n\n实参函数名       f1\t\t\t\tf2\nvoid fun(int (*x1)(int),int (*x2)(int,int))//定义fun函数，形参是指向函数的指针变量\n{\n    int a,b,i=3,j=5;\n    a=(*x1)(i);\t\t//调用f1函数，i是实参\n    b=(*x2)(i,j);\t//调用f2函数，i、j是实参\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在fun函数中声明形参x1和x2为指向函数的指针变量，x1指向的函数有一个整型形参，x2指向的函数有两个整型实参。函数fun的形参x1和x2（指针变量）在函数fun未被调用时并不占内存单元，也不指向任何函数。在主函数调用fun函数时，把实参函数f1和f2的入口地址传给形参指针变量x1和x2，使x1和x2指向函数f1和f2。这时，在函数fun中，用*x1和*x2就可以调用函数f1和f2。(*x1)(i)就相当于f1(i),(*x2)(i,j)就相当于f2(i,j)。\n\n\n# 6. 返回指针值的函数\n\n定义返回指针的函数的原型一般形式为：\n\n类型名 *函数名(参数列表);\n\n\n1\n\n\n例如：\n\nint *a(int x,int y);\n\n\n1\n\n\na是函数名，调用它以后能得到一个int*型（指向整型数据）的指针，即整型数据的地址。x和y是函数a的形参，为整型。\n\n请注意在*a两侧没有括号，在a的两侧分比是*运算符和()运算符。而()优先级高于*，因此a先与()结合，显然这是函数形式。这个函数前面有一个*，表示此函数是指针型函数（函数值是指针）。最前面的int表示返回的指针指向整型变量。\n\n\n# 7. 指针数组和多重指针\n\n定义一维指针数组的一般形式为：\n\n类型名 *数组名[数组长度];\n\n\n1\n\n\n类型名中应包括符号*，如int*表示指向整数数据的指针类型。\n\n例如：\n\nint *p[4];\n\n\n1\n\n\n由于[]比*优先级高，因此p先与[4]结合，形成p[4]形式，表示p数组有4个元素。然后再与p前面的*结合，*表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都指向一个整型变量。\n\n注意一定不要写成：\n\nint (*p)[4];\t//这是指向一维数组的指针变量\n\n\n1\n\n\n指向指针数据的指针变量\n\n定义一个指向指针数据类型的指针变量：\n\nchar **p;\n\n\n1\n\n\np的前面有两个*号。*运算符的结合性是从右到作，因此**p相当于*(*p)，显然*p是指针变量的定义形式。如果没有最前面的*,那就是定义了一个指向字符数据的指针变量。现在它前面又有一个*号，即char**p。可以把它分成两部分看，即：char*和( *p),后面的( *p)表示p是指针变量,前面的char*表示p指向的是char*型的数据。也就是说,p指向一个字符指针变量（这个字符指针变量指向一个字符型数据）。\n\n例如：使用指向指针数据的指针变量。\n\n#include<stdio.h>\nmain(){\n    char *name={"follw me","basic","great wall","fortran","computer design"};\n    char **p;\n    int i;\n    for(i=0;i<5;i++){\n        p=name+i;\n        printf("%s\\n",**p);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n指针数组作main函数的形参\n\nmain函数的第1行一般写成以下形式：\n\nint main()或int main(void)\n\n括号中是空的或有“void”，表示main函数没有参数，调用main函数时不必给出实参。\n\n这是一般程序常采用的形式。实际上，在某些情况下，main函数可以有参数，即：\n\nint main(int arge,char * argv[])\n\n\n1\n\n\n其中，argc和argv就是main函数的形参，它们是程序的“命令行参数”。\n\narge ( argument count的缩写,意思是参数个数) ，argv(argument vector` 缩写,意思是参数向量),它是一个*char指针数组，数组中每一个元素（其值为指针）指向命令行中的-个字符串的首字符。\n\n**注意：**如果用带参数的main函数，其第一个形参必须是int 型,用来接收形参个数，第二个形参必须是字符指针数组，用来接收从操作系统命令行传来的字符串中首字符的地址。通常main函数和其他函数组成一个文件模块，有一个文件名。对这个文件进行编译和连接，得到可执行文件(后缀为.exe)。用户执行这个可执行文件，操作系统就调用main函数，然后由main函数调用其他函数，从而完成程序的功能。\n\n什么情况下main函数需要参数?main函数的形参是从哪里传递给它们的呢？\n\n显然形参的值不可能在程序中得到。main函数是操作系统调用的，实参只能由操作系统给出。在操作命令状态下，实参是和执行文件的命令一起给出的。例如在dos,unix或linux等系统的操作命令状态下，在命令行中包括了命令名和需要传给main函数的参数。\n\n命令行的一般形式为：\n\n命令名 参数1 参数2 ... 参数n\n\n\n1\n\n\n命令名和各参数之间用空格分隔。\n\n\n# 8. 动态内存分配与指向它的指针变量\n\n对内存动态分配是通过系统提供的函数库来实现的，主要有 molloc ，calloc ，free ，realloc 这4个函数。\n\n * 用malloc函数开辟动态存储区：\n\n其函数原型为：\n\nvoid * malloc(unsigned int size);\n\n\n1\n\n\n其作用是在内存的动态存储区中分配一个长度为size 的连续空间。形参size的类型定为无符号整型(不允许为负数)。\n\n此函数的值(即“返回值")是所分配区域的第一个字节的地址，或者说,此函数是一个指针型函数，返回的指针指向该分配域的第一个字节。如:\n\nmalloc( 100);\t\t//开辟100字节的临时分配域.函数值为其第1个字节的地址\n\n\n1\n\n\n注意指针的基类型为void，即不指向任何类型的数据，只提供一个纯地址。\n\n如果此函数未能成功地执行(例如内存空间不足)，则返回空指针(null)。\n\n * 用calloc函数开辟动态存储区：\n\n其函数原型为：\n\nvoid * calloc(unsigned n,unsigned size);\n\n\n1\n\n\n其作用是在内存的动态存储区中分配n个长度为size 的连续空间,这个空间一般比较大，足以保存一个数组。\n\n用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是动态数组。函数返回指向所分配域的第一个字节的指针；如果分配不成功，返回null。\n\n如:\n\np= calloc(50.4);\t\t//开辟50x4个字节的临时分配域,把首地址赋给指针变量p\n\n\n1\n\n * 用realloc函数重新分配动态存储区\n\n其函数原型为：\n\nvoid * realloc(void * p,unsigned int size);\n\n\n1\n\n\n如果已经通过 malloc 函数或 calloc 函数获得了动态空间，想改变其大小，可以用 recalloc 函数重新分配。\n\n用realloc函数将p所指向的动态空间的大小改变为size。p的值不变。如果重分配不成功,返回null。\n\n如：\n\nrealloc(p,50);\t\t//将p所指向的已分配的动态空间改为50字节\n\n\n1\n\n * 用free函数释放动态存储区\n\n其函数原型为：\n\nvoid free(void * p);\n\n\n1\n\n\n其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的函数返回值。\n\n如：\n\nfree(p);\t\t//释放指针变量p所指向的已分配的动态空间\n\n\n1\n\n\nfree函数无返回值。\n\n**注意：**以上4个函数的声明在stdlib. h头文件中,在用到这些函数时应当用“# include<stdlib.h>”指令把stdlib.h头文件包含到程序文件中。\n\nvoid指针类型\n\nc99允许使用基类型为void的指针类型。可以定义一个基类型为void的指针变量（即void*型变量），它不指向任何类型的数据。请注意：不要把 “指向void类型” 理解为能指向 “任何的类型” 的数据，而应理解为 “指向空类型” 或 “不指向确定的类型“ 的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。\n\n例如:\n\nint a=3;\t\t\t\t\t\t\t//定义a为整型变量\n\nint *p1=&a;\t    \t\t\t\t\t//p1指向int型变量\n\nchar *p2;\t\t\t\t\t\t\t//p2指向char型变量\n\nvoid *p3;\t\t\t\t\t\t\t//p3为无类型指针变量(基类型为void型)\n\np3=(void*)p1;\t\t\t\t\t\t//将p1的值转换为void*类型,然后赋值给p3\n\np2= (char*)p3;\t\t\t\t\t\t//将p3的值转换为char*类型,然后赋值给p2\n\nprintf("%d",* p1);\t\t\t\t\t//合法,输出整型变量a的值\n\np3= &a; printf("%d",* p3);  \t\t//错误,p3是无指向的,不能指向a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这种空类型指针在形式上和其他指针一样，遵循c语言对指针的有关规定，它也有基类型,只是它的基类型是void。\n\n可以这样定义:\n\nvoid * p;\t\t\t//定义p是void*型的指针变量\n\n\n1\n\n\nvoid*型指针代表“无指向的地址”，这种指针不指向任何类型的数据。不能企图通过它存取数据，在程序中它只是过渡性的，只有转换为有指向的地址，才能存取数据。\n\nc 99这样处理,更加规范，更容易理解，概念也更清晰。\n\n现在所用的一些编译系统在进行地址赋值时，会自动进行类型转换。\n\n例如：\n\nint * pt;\npt= (int*)mcaloc(100);\t\t\t//mcaloc(100)是void *型，把它转换为int*型\n可以简化为\npt= mcaloc(100);\t\t\t\t//自动进行类型转换\n\n\n1\n2\n3\n4\n\n\n赋值时，系统会先把mcaloc(100)转换为的pt的类型，即(int* )型，然后赋给pt,这样pt就指向存储区的首字节，在其指向的存储单元中可以存放整型数据。\n\n\n# 9. 有关指针的小结\n\n(1)首先要准确理解指针的含义。“指针”是c语言中一个形象化的名词,形象地表示“指向”的关系，其在物理上的实现是通过地址来完成的。正如高级语言中的“变量”，在物理上是“命名的存储单元”。windows中的“文件夹”实际上是“目录”。离开地址就不可能弄清楚什么是指针。明确了“指针就是地址”，就比较容易理解了，许多问题也迎办而解了。\n\n例如：\n\n * &a是变量a的地址,也可称为变量a的指针。\n\n * 指针变量是存放地址的变量,也可以说,指针变量是存放指针的变量。\n\n * 指针变量的值是一个地址,也可以说，指针变量的值是- 一个指针。\n\n * 指针变量也可称为地址变量,它的值是地址。\n\n * &是取地址运算符，&a是a的地址,也可以说，&是取指针运算符。&a是变量a的指针（即指向变量a的指针）。\n\n * 数组名是一个地址，是数组首元素的地址，也可以说，数组名是一个指针,是数组首元素的指针。\n\n * 函数名是一个指针（指向函数代码区的首字节），也可以说函数名是一个地址（函数代码区首字节的地址）。\n\n * 函数的实参如果是数组名，传递给形参的是一个地址，也可以说，传递给形参的是一个指针。\n\n(2) 在c语言中，所有的数据都是有类型的，例如常量123并不是数学中的常数123，数学中的123是没有类型的，123和123.0是一样的，而在c语言中，所有数据都要存储在内存的存储单元中，若写成123，则认为是整数，按整型的存储形式存放，如果写成123.0，则认为是单精度实数，按单精度实型的存储形式存放。此外，不同类型数据有不同的运算规则。可以说，c语言中的数据都是“有类型的数据”，或称“带类型的数据”。\n\n对地址而言，也是同样的，它也有类型，首先，它不是一个数值型数据，不是按整型或浮点型方式存储，它是按指针型数据的存储方式存储的（虽然在visualc++中也为指针变量分配4个字节，但不同于整型数据的存储形式）。指针型存储单元是专门用来存放地址的，指针型数据的存储形式就是地址的存储形式。\n\n其次，它不是一个简单的纯地址，还有一个指向的问题，也就是说它指向的是哪种类型的数据。如果没有这个信息,是无法通过地址存取存储单元中的数据的。所以，一个地址型的数据实际上包含3个信息：\n\n①表示内存编号的纯地址。\n\n②它本身的类型，即指针类型。\n\n③以它为标识的存储单元中存放的是什么类型的数据，即基类型。\n\n例如：已知变量为a为int型，&a为a的地址，它就包括以上3个信息，它代表的是一个整型数据的地址，int是&a的基类型（即它指向的是int型的存储单元）。可以把②和③两项合成一项，如 “指向整型数据的指针类型” 或 “基类型为整型的指针类型” ，其类型可以表示为“int*”型。这样，对地址数据来说，也可以说包含两个要素：内存编号（纯地址）和类型（指针类型和基类型）。这样的地址是 “带类型的地址” 而不是纯地址。\n\n(3)要区别指针和指针变量。指针就是地址，而指针变量是用来存放地址的变量。有人认为指针是类型名，指针的值是地址。这是不对的。类型是没有值的，只有变量才有值，正确的说法是指针变量的值是一个地址。不要杜撰出 “地址的值” 这样莫须有的名词。地址本身就是一个值。\n\n(4)什么叫 “指向” ？地址就意味着指向，因为通过地址能找到具有该地址的对象。对于指针变量来说，把谁的地址存放在指针变量中，就说此指针变量指向谁。但应注意：并不是任何类型数据的地址都可以存放在同一个指针变量中的，只有与指针变量的基类型相同的数据的地址才能存放在相应的指针变量中。\n\n例如：\n\nint a,*p;\t//p是int关型的指针变量,基类型是int型\n\nfloat b;\n\np= &a;\t\t//a是int型,合法\n\np=&b;\t\t//b是float型,类型不匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n既然许多数据对象（如变量数组、字符串和函数等）都在内存中被分配存储空间，就有了地址，也就有了指针。可以定义一些指针变量，分别存放这些数据对象的地址，即指向这些对象。void*指针是一种特殊的指针，不指向任何类型的数据。如果需要用此地址指向某类型的数据，应先对地址进行类型转换。可以在程序中进行显式的类型转换，也可以由编译系统自动进行隐式转换。无论用哪种转换，读者必须了解要进行类型转换。\n\n(5)要深入掌握在对数组的操作中正确地使用指针，搞清楚指针的指向。一维数组名代表数组首元素的地址，如：\n\nint *p,a[10];\np=a;\n\n\n1\n2\n\n\np是指向int型类型的指针变量，显然，p只能指向数组中的元素（int型变量），而不是指向整个数组。在进行赋值时一定要先确定赋值号两侧的类型是否相同，是否允许赋值。\n\n对"p=a;" ，准确地说应该是： p指向a数组的首元素，在不引起误解的情况下，有时也简称为：p指向a数组，但读者对此应有准确的理解。同理，p 指向字符串，也应理解为p指向字符串中的首字符。\n\n(6)有关指针变量的归纳比较\n\n指针变量的类型及含义\n\n变量定义           类型表示        含义\nint i;         int         定义整型变量\nint *p;        int *       定义p为指向整型数据的指针变量\nina a[5];      int [5]     定义整型数组a，它有5个元素\nint *p[4];     int * [4]   定义指针数组p，它由4个指向整型数据的指针元素组成\nint (*p)[4];   int(*)[4]   p为指向包含4个元素的一维数组的指针变量\nint f();       int ()      f为返回整型函数值的函数\nint *p();      int * ()    p为返回一个指针的函数，该指针指向整型数据\nint(*p)();     int(*)()    p为指向函数的指针，该函数返回一个整型值\nint **p;       int **      p是一个指针变量，它指向一个指向整型数据的指针变量\nvoid *p;       void *      p是一个指针变量，基类型为void（空类型），不指向具体的对象\n\n为便于比较,在表中包括了其他一些类型的定义。\n\n(7)指针运算。\n\n①指针变量加（减）一个整数。\n\n例如: p++,p--,p+i,p-i,p+=i,p-=i等均是指针变量加(减)一个整数。\n\n将该指针变量的原值（是一个地址）和它指向的变量所占用的存储单元的字节数相加（减）。\n\n②指针变量赋值。\n\n将一个变量地址赋给一个指针变量。\n\n例如：\n\np= &a;\t\t\t\t//(将变量a的地址赋给p)\n\np= array;\t\t\t//(将数组array首元素地址赋给p)\n\np= &array[i];\t\t//(将数组array 第i个元素的地址赋给p)\n\np= max;\t\t\t\t//(max为已定义的函数.将max的人口地址赋给p)\n\np1= p2;\t\t\t\t//(pl和p2是基类型相同指针变量,将p2的值赋给pl)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：不应把一个整数赋给指针变量。\n\n③两个指针变量可以相减。\n\n如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之差是两个指针之间的元素个数。\n\n④两个指针变量比较。\n\n若两个指针指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量“小于”指向后面元素的指针变量。如果p1和p2不指向同一数组则比较无意义。\n\n(8)指针变量可以有空值，即该指针变量不指向任何变量，可以这样表示：p= null;\n\n其中，null是一个符号常量，代表整数0。在stdio.h头文件中对null进行了定义:#define null 0\n\n它使p指向地址为0的单元。系统保证使该单元不作它用(不存放有效数据)。\n\n应注意，p的值为null与未对p赋值是两个不同的概念。前者是有值的（值为0），不指向任何变量，后者虽未对p赋值但并不等于p无值,只是它的值是一个无法预料的值，也就是p可能指向一个事先未指定的单元。这种情况是很危险的。因此，在引用指针变量之前应对它赋值。\n\n任何指针变量或地址都可以与null作相等或不相等的比较，例如:\n\nif(p==null){\n    ...\n}\n\n\n1\n2\n3\n\n\n指针是c语言中很重要的概念，是c的一个重要特色。\n\n使用指针的优点：\n\n①提高程序效率；\n\n②在调用函数时当指针指向的变量的值改变时,这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值；\n\n③可以实现动态存储分配。\n\n同时应该看到，指针使用实在太灵活，对熟练的程序人员来说，可以利用它编写出颇有特色、质量优良的程序，实现许多用其他高级语言难以实现的功能，但也十分容易出错，而且这种错误往往比较隐蔽。指针运用的错误可能会使整个程序遭受破坏，比如由于未对指针变量p赋值就向* p赋值，就可能破坏了有用的单元的内容。如果使用指针不当，会出现隐蔽的、难以发现和排除的故障。因此，使用指针要十分小心谨慎，要多上机调试程序，以弄清一些细节，并积累经验。',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第四章 函数实现模块化设计",frontmatter:{title:"第四章 函数实现模块化设计",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note4/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1.html",relativePath:"50.C语言/05.第四章函数实现模块化设计.md",key:"v-06417f73",path:"/c/note4/",headers:[{level:2,title:"1. 定义函数的方法",slug:"_1-定义函数的方法",normalizedTitle:"1. 定义函数的方法",charIndex:20},{level:2,title:"2. 调用函数",slug:"_2-调用函数",normalizedTitle:"2. 调用函数",charIndex:258},{level:2,title:"3. 函数的返回值",slug:"_3-函数的返回值",normalizedTitle:"3. 函数的返回值",charIndex:837},{level:2,title:"4. 对被调用函数的声明和函数原型",slug:"_4-对被调用函数的声明和函数原型",normalizedTitle:"4. 对被调用函数的声明和函数原型",charIndex:1170},{level:2,title:"5. 数组作为函数参数",slug:"_5-数组作为函数参数",normalizedTitle:"5. 数组作为函数参数",charIndex:1749},{level:2,title:"6. 局部变量和全局变量",slug:"_6-局部变量和全局变量",normalizedTitle:"6. 局部变量和全局变量",charIndex:2123},{level:2,title:"7.变量的存储方式和生存期",slug:"_7-变量的存储方式和生存期",normalizedTitle:"7.变量的存储方式和生存期",charIndex:2696},{level:2,title:"8. 存储类别小结",slug:"_8-存储类别小结",normalizedTitle:"8. 存储类别小结",charIndex:6348},{level:2,title:"9. 内部函数和外部函数",slug:"_9-内部函数和外部函数",normalizedTitle:"9. 内部函数和外部函数",charIndex:7139}],headersStr:"1. 定义函数的方法 2. 调用函数 3. 函数的返回值 4. 对被调用函数的声明和函数原型 5. 数组作为函数参数 6. 局部变量和全局变量 7.变量的存储方式和生存期 8. 存储类别小结 9. 内部函数和外部函数",content:'# 第四章 函数实现模块化设计\n\n\n# 1. 定义函数的方法\n\n函数体包括声明部分和语句部分\n\n * 定义无参函数\n\n一般形式为：\n\n类型名 函数名(){\n\t函数体\n}\n或\n类型名 函数名(void){\n\t函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 定义有参函数\n\n一般形式为：\n\n类型名 函数名(形式参数列表){\n\t函数体\n}\n\n\n1\n2\n3\n\n * 定义空参函数\n   * 函数体是空的。调用此函数时，什么工作也不做，没有任何实际作用。\n\n一般形式为：\n\n类型名 函数名()\n{}\n\n\n1\n2\n\n\n\n# 2. 调用函数\n\n调用函数的形式\n\n一般的调用形式为：\n\n函数名(实参表列);\n\n\n1\n\n\n函数调用语句：把函数调用单独作为一个语句。\n\n函数表达式：函数出现在另一个表达式中。\n\n函数参数：函数调用作为另外一个函数调用时的参数。\n\n函数作为参数时的数据传递 【函数形式参数和实际参数】\n\n函数的参数分为两种，分别是形式参数与实际参数。\n\n①形式参数：\n\n在定义函数时函数名后面括号中的变量名称称为形式参数（简称形参），即形参出现在函数定义中。形参变量只有在被调用时才会为其分配内训单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效，只有当函数被调用时，系统才为形参分配存储单元，并完成实参与形参的数据传递。在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。\n\n②实际参数：\n\n主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数（简称实参），即实参出现在主调函数中。\n\n实参可以是常量，变量，表达式，函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传递给形参。因此应预先用赋值，输入等办法使实参获得确定值。\n\n说明：在被定义的函数中，必须指定形参的类型。实参与形参的类型应相同或赋值兼容。实参和形参在数量上，类型上，顺序上应该严格一致，否则会发生类型不匹配的错误。\n\n\n# 3. 函数的返回值\n\n 1. 函数的返回值是通过函数中的return语句获得的。\n    \n    【return语句将被调用函数中的一个确定值带回到主函数中去。】\n\n 2. 函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。\n    \n    【注意：在定义函数时要指定函数的类型。】\n\n 3. 在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致。\n    \n    【如果函数的类型和return语句中表达式的值不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。】\n\n 4. 对于不带回值的函数，应当用定义函数为void类型（或称“空类型”）\n\n\n# 4. 对被调用函数的声明和函数原型\n\n在一个函数中调用另一个函数（即被调用函数）需要具备如下条件：\n\n * 首先被调用的函数必须是已经定义的函数（函数库或用户自定义的函数）。\n\n * 如果使用函数，应该在本文件头用#include指令将调用有关库函数时所需用的到的信息“包含”到文件中来。\n\n * 如果使用用户自定义的函数，而该函数的位置在调用它的函数（即主函数）的后面（在同一个文件中），应该在主函数中对被调用的函数作声明（delcaration）。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别到函数并检查调用是否合法。\n\n函数声明的一般形式有两种：\n\n方式一：\n\n函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,…,参数类型n 参数名n);\n\n\n1\n\n\n方式二：\n\n函数类型 函数名(参数类型1,参数类型2,…,参数类型n);\n\n\n1\n\n\n注意：\n\n函数的 “定义“ 和 ”声明“ 不是同一回事。\n\n * 函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位。\n * 函数声明的作用则是把函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查，它不包含函数体。\n\n\n# 5. 数组作为函数参数\n\n数组元素作函数实参\n\n数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配的存储单元，不可能为一个数组元素单独分配存储单元（数组是一个整体，在内存中占连续的一段存储单元）。在用数组元素作函数参数实参时，把实参的值传给形参，是 ”值传递“ 方式。数据传递方向是从实参传到形参，单向传递。\n\n一维数组名作函数参数\n\n除了可以用数组元素作为函数参数外，还可以用数组名作函数参数（包括实参和形参）。\n\n注意：用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数函数参数时，向形参（数组名或指针变量）传递的是地址值。\n\n多维数组名作函数参数\n\n由于用法基本一致，其余不做详细介绍。\n\n请参考：《C语言程序设计（第五版）》——谭浩强 【第七章- 用函数实现模块化程序设计 -167页】\n\n\n# 6. 局部变量和全局变量\n\n变量按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。\n\n变量按作用域分：\n\n * 全局变量：在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。\n\n * 静态全局变量：只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；\n\n * 静态局部变量：只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。\n\n * 局部变量：在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。\n\n注意：全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知\n\n静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。\n\n形参变量 : 只在被调用期间才分配内存单元，调用结束立即释放。\n\n\n# 7.变量的存储方式和生存期\n\n变量的存储方式有两种：\n\n * 静态存储方式：是指程序在运行期间由系统分配固定的存储空间的方式。\n\n * 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。\n\n供用户使用的存储空间可分为3个部分：程序区，静态存储区，动态存储区。\n\n全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。\n\n动态存储区中存放以下数据：\n\n 1. 函数形式参数。在调用函数时给形参分配存储空间。\n 2. 函数中定义的没有用static关键字声明的变量，即自动变量。\n 3. 函数调用时的现场保护和返回地址等。\n\n每一个变量和函数都有两个属性：数据类型和数据的存储类别。【存储类别指的是数据在内存中存储的方式：静态存储和动态存储】\n\n在定义和声明变量和函数时，一般应该同时指定其数据类型和存储类别，也可以采用默认方式指定（即如果用户不指定，系统会隐含地指定为某一种存储类别）。\n\n**存储类别包括4种：**自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。\n\n * 自动变量（auto变量）\n   \n   * 函数中的局部变量，如果不专门声明为static（静态）存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数的形参和在函数定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用调用结束时就自动释放这些存储空间。因此这类局部变量称为自动变量。\n   \n   * 关键字auto可以省略不写，不写auto则隐含的指定为 “自动存储类别” ，它属于动态存储的方式。程序中大多数变量都属于自动变量。\n\n * 静态局部变量（static局部变量）\n   \n   * 静态局部变量属于静态存储类别，在静态存储区域内分配存储单元。在整个程序运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，分配在动态存储区空间而不再静态存储区空间，函数调用结束后即释放。\n   * 对静态局部变量是在编译时赋初值的，即只赋一次初值，在程序运行时它已有初值。以后每次调用函数函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句。\n   * 如果在定义局部变量时不赋值的话，则对静态局部变量来说，编译时自动赋初值0（对数值变量）或空字符\'\\0\'（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可加的。\n   * 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用他的。因为它是局部变量，只能被本函数引用，而不能被其他函数引用。\n\n * 寄存器变量（register变量）\n   \n   * 寄存器变量的定义形式是：\n     \n     register 类型标识符 变量名\n   \n   * 寄存器是与机器硬件密切相关的，不同类型的计算机，寄存器的数目是不一样的，通常为2到3个，对于在一个函数中说明的多于2到3个的寄存器变量，C编译程序会自动地将寄存器变量变为自动变量。\n   \n   * 由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为"register"。\n   \n   * register型变量常用于作为循环控制变量，这是使用它的高速特点的最佳场合。比较下面两个程序的运算速度。\n\n * 注意三种局部变量的存储位置是不同的\n   \n   * 自动变量存储在动态存储区\n   * 静态局部变量存储在静态存储区\n   * 寄存器存储在CPU中的寄存器中\n\n全局变量的存储类别\n\n * 在一个文件内扩展外部变量的作用域\n   * 如果外部变量不在文件的开头定义,其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量,则应该在引用之前用关键字extern对该变量作**“外部变量声明”**，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从 “声明” 处起,合法地使用该外部变量。\n   * 注意：提倡将外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。\n   * 用extern声明外部变量时，类型名也可以省写。例如：extern int A,B,C;——>extern A,B,C 。\n * 将外部变量的作用域扩展到其他文件\n   \n   * 第一种情况是在同一个源文件中使用外部变量的方法，如果有多个源文件，想在A文件中引用B文件中的已定义外部变量，该如何做？\n     \n     * 假设一个程序包含两个文件，两个文件都需要用到同一个外部变量Num,若在两个文件中各自定义一个外部变量Num，将会在进行程序的连接时出现“重复定义”的错误。\n     \n     * 因此，正确的做法是：在任一个文件中定义外部变量Num，然后在另一个文件中用关键字extern进行“外部变量声明”，即“extern Num”。\n     \n     * 在编译和链接时，系统就会知道Num有外部链接，可以从别处找到已定义的外部变量Num，并将另一个文件中定义的外部变量Num的作用域扩展到本文件，那么就可以在本文件中合法的使用变量Num了。\n     \n     * 例子：分别编写两个源文件文件file1和file2,在file1中定义外部变量A,在file2中用extern来声明外部变量，把A的作用域扩展到file2中\n\nfile1:\n\n    //file1\n    #include<stdio.h>\n    //给定b的值，输入a和m，求a*b和a**m(a的m次方)的值\n  \n    int A;     //定义外部变量\n    int power(int);\n    int main()\n    {\n    \tint b = 3, c, d, m;\n    \tprintf("input a and its power m:");\n    \tscanf_s("%d %d", &A, &m);\n    \tc = A * b;\n    \tprintf("%d*%d=%d\\n", A, b, c);\n    \td = power(m);\n    \tprintf("%d ** %d=%d\\n", A, m, d);\n    \tsystem("pause");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfile2:\n\n    //file2\n    extern A;             \n    //把在file1文件中已定义的外部变量的作用域扩展到本文件\n    int power(int n)\n    {\n    \tint i, y = 1;\n    \tfor ( i = 1; i <= n; i++)\n    \t{\n    \t\ty *= A;\n    \t}\n  \n    \treturn y;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n\n\n * 解析：\n   \n   * 假设某一程序有5个源文件，那么只需要在其中一个源文件中定义外部变量A,然后在其余四个文件中使用关键字extern声明外部变量即可。各文件经过编译后会连接成一个可执行的目标文件。\n   * 用这种方法扩展全局变量的作用域应十分慎重，因为在执行一个文件中的操作时可能会改变该全局变量的值，这样就会影响到另一个文件中全局变量的值，从而影响该文件中函数的执行结果。\n\n * 将外部变量的作用域限制在本文件中\n   \n   * 若希望外部变量仅限于被本文件使用，而不被其它文件使用，那么可以在定义外部变量时加上一个static，例如：\n\nstatic int A;\nint main()\n{\n\t......\n}\n\n\n1\n2\n3\n4\n5\n\n\n这样在其它文件中就算使用“extern A”，也不能使用本文件的外部变量A。 这种加上static声明，只能用于本文件的外部变量成为“静态外部变量”。 用static声明一个变量的作用：\n\n（1）对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间所在的存储单元都不会释放。\n\n（2）对全局变量用static声明，则该变量的作用域只限于本文件模块（即被声明的文件中）\n\n\n# 8. 存储类别小结\n\n对数据的定义，需要指定两种属性：数据类型和存储类别，分别使用两个关键字。\n\n例如：\n\nstatic int a;\t\t//静态局部整型变量或静态外部整型变量\nauto char c;\t\t//自动变量，在函数内定义使用\nregister int d;\t\t//寄存器变量，在函数内定义\n\n\n1\n2\n3\n\n\n此外，可以用extern声明已定义的外部变量，例如：\n\nextern b;\t\t//将已定义的外部变量b的作用域扩展至此\n\n\n1\n\n\n下面从不同角度做些归纳\n\n 1. 从作用域角度分，有局部变量和全局变量。它们采用的存储类型如下：\n    \n    \n\n 2. 从变量存在的时间（生存期）来区分，有动态存储和静态存储两种类型。静态存储类型是整个程序运行时间都存在，而动态存储原则是在调用函数时临时分配分配单元。\n    \n    \n\n 3. 从变量值存放的位置来区分，可分为：\n\n\n\n----------------------------------------\n\n 4. 关9.作用域和生存期的概念。\n\n * 如果一个变量在某个文件或函数范围内是有效的，就称为该范围为该变量的作用域。在此作用域内可以引用该变量，在专业书中称变量在此作用域内 “可见” ，这种性质称为变量的可见性。\n\n * 如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的生存期，或称该变量在此时刻 “存在” 。\n\n各种类型变量的作用域和存在性情况\n\n\n\n 5. static对局部变量和全局变量的作用域不同。对于局部变量来说它使变量的由动态存储方式改变为静态存储方式。而对于全局变量来说，它使变量局部化（局部于本文件）,但静态存储方式。从作用域角度看，但凡有static声明的，其作用域都是局限的或者局限于本函数内（静态局部变量），或者局限于本文件内（静态外部变量）。\n\n\n# 9. 内部函数和外部函数\n\n根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。\n\n内部函数\n\n如果一个函数只能被本文件中其他函数所调用，它将称为内部函数。\n\n在定义内部函数时，在函数名和函数类型前面加static,即：\n\nstatic 类型名 函数名(形参表);\n\n\n1\n\n\n内部函数又称静态函数，因为它是static声明的。\n\n外部函数\n\n如果在定义函数时，在函数首部的最左端加关键字extern，则此函数是外部函数，可供其他文件调用。\n\n一般形式为：\n\nextern 类型名 函数名(形参表);\n\n\n1\n\n\nC语言规定，如果在定义函数时省略extern，则默认为外部函数。\n\n在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也需要用函数原型进行声明）。在对此函数作声明时，要加关键字extern，表示该函数 “是在其他文件中定义的外部函数” 。',normalizedContent:'# 第四章 函数实现模块化设计\n\n\n# 1. 定义函数的方法\n\n函数体包括声明部分和语句部分\n\n * 定义无参函数\n\n一般形式为：\n\n类型名 函数名(){\n\t函数体\n}\n或\n类型名 函数名(void){\n\t函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 定义有参函数\n\n一般形式为：\n\n类型名 函数名(形式参数列表){\n\t函数体\n}\n\n\n1\n2\n3\n\n * 定义空参函数\n   * 函数体是空的。调用此函数时，什么工作也不做，没有任何实际作用。\n\n一般形式为：\n\n类型名 函数名()\n{}\n\n\n1\n2\n\n\n\n# 2. 调用函数\n\n调用函数的形式\n\n一般的调用形式为：\n\n函数名(实参表列);\n\n\n1\n\n\n函数调用语句：把函数调用单独作为一个语句。\n\n函数表达式：函数出现在另一个表达式中。\n\n函数参数：函数调用作为另外一个函数调用时的参数。\n\n函数作为参数时的数据传递 【函数形式参数和实际参数】\n\n函数的参数分为两种，分别是形式参数与实际参数。\n\n①形式参数：\n\n在定义函数时函数名后面括号中的变量名称称为形式参数（简称形参），即形参出现在函数定义中。形参变量只有在被调用时才会为其分配内训单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效，只有当函数被调用时，系统才为形参分配存储单元，并完成实参与形参的数据传递。在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。\n\n②实际参数：\n\n主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数（简称实参），即实参出现在主调函数中。\n\n实参可以是常量，变量，表达式，函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传递给形参。因此应预先用赋值，输入等办法使实参获得确定值。\n\n说明：在被定义的函数中，必须指定形参的类型。实参与形参的类型应相同或赋值兼容。实参和形参在数量上，类型上，顺序上应该严格一致，否则会发生类型不匹配的错误。\n\n\n# 3. 函数的返回值\n\n 1. 函数的返回值是通过函数中的return语句获得的。\n    \n    【return语句将被调用函数中的一个确定值带回到主函数中去。】\n\n 2. 函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。\n    \n    【注意：在定义函数时要指定函数的类型。】\n\n 3. 在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致。\n    \n    【如果函数的类型和return语句中表达式的值不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。】\n\n 4. 对于不带回值的函数，应当用定义函数为void类型（或称“空类型”）\n\n\n# 4. 对被调用函数的声明和函数原型\n\n在一个函数中调用另一个函数（即被调用函数）需要具备如下条件：\n\n * 首先被调用的函数必须是已经定义的函数（函数库或用户自定义的函数）。\n\n * 如果使用函数，应该在本文件头用#include指令将调用有关库函数时所需用的到的信息“包含”到文件中来。\n\n * 如果使用用户自定义的函数，而该函数的位置在调用它的函数（即主函数）的后面（在同一个文件中），应该在主函数中对被调用的函数作声明（delcaration）。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别到函数并检查调用是否合法。\n\n函数声明的一般形式有两种：\n\n方式一：\n\n函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,…,参数类型n 参数名n);\n\n\n1\n\n\n方式二：\n\n函数类型 函数名(参数类型1,参数类型2,…,参数类型n);\n\n\n1\n\n\n注意：\n\n函数的 “定义“ 和 ”声明“ 不是同一回事。\n\n * 函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位。\n * 函数声明的作用则是把函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查，它不包含函数体。\n\n\n# 5. 数组作为函数参数\n\n数组元素作函数实参\n\n数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配的存储单元，不可能为一个数组元素单独分配存储单元（数组是一个整体，在内存中占连续的一段存储单元）。在用数组元素作函数参数实参时，把实参的值传给形参，是 ”值传递“ 方式。数据传递方向是从实参传到形参，单向传递。\n\n一维数组名作函数参数\n\n除了可以用数组元素作为函数参数外，还可以用数组名作函数参数（包括实参和形参）。\n\n注意：用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数函数参数时，向形参（数组名或指针变量）传递的是地址值。\n\n多维数组名作函数参数\n\n由于用法基本一致，其余不做详细介绍。\n\n请参考：《c语言程序设计（第五版）》——谭浩强 【第七章- 用函数实现模块化程序设计 -167页】\n\n\n# 6. 局部变量和全局变量\n\n变量按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。\n\n变量按作用域分：\n\n * 全局变量：在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。\n\n * 静态全局变量：只在定义它的文件内有效，效果和全局变量一样，不过就在本文件内部；\n\n * 静态局部变量：只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。\n\n * 局部变量：在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。\n\n注意：全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知\n\n静态局部变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用。\n\n形参变量 : 只在被调用期间才分配内存单元，调用结束立即释放。\n\n\n# 7.变量的存储方式和生存期\n\n变量的存储方式有两种：\n\n * 静态存储方式：是指程序在运行期间由系统分配固定的存储空间的方式。\n\n * 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。\n\n供用户使用的存储空间可分为3个部分：程序区，静态存储区，动态存储区。\n\n全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。\n\n动态存储区中存放以下数据：\n\n 1. 函数形式参数。在调用函数时给形参分配存储空间。\n 2. 函数中定义的没有用static关键字声明的变量，即自动变量。\n 3. 函数调用时的现场保护和返回地址等。\n\n每一个变量和函数都有两个属性：数据类型和数据的存储类别。【存储类别指的是数据在内存中存储的方式：静态存储和动态存储】\n\n在定义和声明变量和函数时，一般应该同时指定其数据类型和存储类别，也可以采用默认方式指定（即如果用户不指定，系统会隐含地指定为某一种存储类别）。\n\n**存储类别包括4种：**自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。\n\n * 自动变量（auto变量）\n   \n   * 函数中的局部变量，如果不专门声明为static（静态）存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数的形参和在函数定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用调用结束时就自动释放这些存储空间。因此这类局部变量称为自动变量。\n   \n   * 关键字auto可以省略不写，不写auto则隐含的指定为 “自动存储类别” ，它属于动态存储的方式。程序中大多数变量都属于自动变量。\n\n * 静态局部变量（static局部变量）\n   \n   * 静态局部变量属于静态存储类别，在静态存储区域内分配存储单元。在整个程序运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，分配在动态存储区空间而不再静态存储区空间，函数调用结束后即释放。\n   * 对静态局部变量是在编译时赋初值的，即只赋一次初值，在程序运行时它已有初值。以后每次调用函数函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句。\n   * 如果在定义局部变量时不赋值的话，则对静态局部变量来说，编译时自动赋初值0（对数值变量）或空字符\'\\0\'（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可加的。\n   * 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用他的。因为它是局部变量，只能被本函数引用，而不能被其他函数引用。\n\n * 寄存器变量（register变量）\n   \n   * 寄存器变量的定义形式是：\n     \n     register 类型标识符 变量名\n   \n   * 寄存器是与机器硬件密切相关的，不同类型的计算机，寄存器的数目是不一样的，通常为2到3个，对于在一个函数中说明的多于2到3个的寄存器变量，c编译程序会自动地将寄存器变量变为自动变量。\n   \n   * 由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为"register"。\n   \n   * register型变量常用于作为循环控制变量，这是使用它的高速特点的最佳场合。比较下面两个程序的运算速度。\n\n * 注意三种局部变量的存储位置是不同的\n   \n   * 自动变量存储在动态存储区\n   * 静态局部变量存储在静态存储区\n   * 寄存器存储在cpu中的寄存器中\n\n全局变量的存储类别\n\n * 在一个文件内扩展外部变量的作用域\n   * 如果外部变量不在文件的开头定义,其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量,则应该在引用之前用关键字extern对该变量作**“外部变量声明”**，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从 “声明” 处起,合法地使用该外部变量。\n   * 注意：提倡将外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。\n   * 用extern声明外部变量时，类型名也可以省写。例如：extern int a,b,c;——>extern a,b,c 。\n * 将外部变量的作用域扩展到其他文件\n   \n   * 第一种情况是在同一个源文件中使用外部变量的方法，如果有多个源文件，想在a文件中引用b文件中的已定义外部变量，该如何做？\n     \n     * 假设一个程序包含两个文件，两个文件都需要用到同一个外部变量num,若在两个文件中各自定义一个外部变量num，将会在进行程序的连接时出现“重复定义”的错误。\n     \n     * 因此，正确的做法是：在任一个文件中定义外部变量num，然后在另一个文件中用关键字extern进行“外部变量声明”，即“extern num”。\n     \n     * 在编译和链接时，系统就会知道num有外部链接，可以从别处找到已定义的外部变量num，并将另一个文件中定义的外部变量num的作用域扩展到本文件，那么就可以在本文件中合法的使用变量num了。\n     \n     * 例子：分别编写两个源文件文件file1和file2,在file1中定义外部变量a,在file2中用extern来声明外部变量，把a的作用域扩展到file2中\n\nfile1:\n\n    //file1\n    #include<stdio.h>\n    //给定b的值，输入a和m，求a*b和a**m(a的m次方)的值\n  \n    int a;     //定义外部变量\n    int power(int);\n    int main()\n    {\n    \tint b = 3, c, d, m;\n    \tprintf("input a and its power m:");\n    \tscanf_s("%d %d", &a, &m);\n    \tc = a * b;\n    \tprintf("%d*%d=%d\\n", a, b, c);\n    \td = power(m);\n    \tprintf("%d ** %d=%d\\n", a, m, d);\n    \tsystem("pause");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfile2:\n\n    //file2\n    extern a;             \n    //把在file1文件中已定义的外部变量的作用域扩展到本文件\n    int power(int n)\n    {\n    \tint i, y = 1;\n    \tfor ( i = 1; i <= n; i++)\n    \t{\n    \t\ty *= a;\n    \t}\n  \n    \treturn y;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n\n\n * 解析：\n   \n   * 假设某一程序有5个源文件，那么只需要在其中一个源文件中定义外部变量a,然后在其余四个文件中使用关键字extern声明外部变量即可。各文件经过编译后会连接成一个可执行的目标文件。\n   * 用这种方法扩展全局变量的作用域应十分慎重，因为在执行一个文件中的操作时可能会改变该全局变量的值，这样就会影响到另一个文件中全局变量的值，从而影响该文件中函数的执行结果。\n\n * 将外部变量的作用域限制在本文件中\n   \n   * 若希望外部变量仅限于被本文件使用，而不被其它文件使用，那么可以在定义外部变量时加上一个static，例如：\n\nstatic int a;\nint main()\n{\n\t......\n}\n\n\n1\n2\n3\n4\n5\n\n\n这样在其它文件中就算使用“extern a”，也不能使用本文件的外部变量a。 这种加上static声明，只能用于本文件的外部变量成为“静态外部变量”。 用static声明一个变量的作用：\n\n（1）对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间所在的存储单元都不会释放。\n\n（2）对全局变量用static声明，则该变量的作用域只限于本文件模块（即被声明的文件中）\n\n\n# 8. 存储类别小结\n\n对数据的定义，需要指定两种属性：数据类型和存储类别，分别使用两个关键字。\n\n例如：\n\nstatic int a;\t\t//静态局部整型变量或静态外部整型变量\nauto char c;\t\t//自动变量，在函数内定义使用\nregister int d;\t\t//寄存器变量，在函数内定义\n\n\n1\n2\n3\n\n\n此外，可以用extern声明已定义的外部变量，例如：\n\nextern b;\t\t//将已定义的外部变量b的作用域扩展至此\n\n\n1\n\n\n下面从不同角度做些归纳\n\n 1. 从作用域角度分，有局部变量和全局变量。它们采用的存储类型如下：\n    \n    \n\n 2. 从变量存在的时间（生存期）来区分，有动态存储和静态存储两种类型。静态存储类型是整个程序运行时间都存在，而动态存储原则是在调用函数时临时分配分配单元。\n    \n    \n\n 3. 从变量值存放的位置来区分，可分为：\n\n\n\n----------------------------------------\n\n 4. 关9.作用域和生存期的概念。\n\n * 如果一个变量在某个文件或函数范围内是有效的，就称为该范围为该变量的作用域。在此作用域内可以引用该变量，在专业书中称变量在此作用域内 “可见” ，这种性质称为变量的可见性。\n\n * 如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的生存期，或称该变量在此时刻 “存在” 。\n\n各种类型变量的作用域和存在性情况\n\n\n\n 5. static对局部变量和全局变量的作用域不同。对于局部变量来说它使变量的由动态存储方式改变为静态存储方式。而对于全局变量来说，它使变量局部化（局部于本文件）,但静态存储方式。从作用域角度看，但凡有static声明的，其作用域都是局限的或者局限于本函数内（静态局部变量），或者局限于本文件内（静态外部变量）。\n\n\n# 9. 内部函数和外部函数\n\n根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。\n\n内部函数\n\n如果一个函数只能被本文件中其他函数所调用，它将称为内部函数。\n\n在定义内部函数时，在函数名和函数类型前面加static,即：\n\nstatic 类型名 函数名(形参表);\n\n\n1\n\n\n内部函数又称静态函数，因为它是static声明的。\n\n外部函数\n\n如果在定义函数时，在函数首部的最左端加关键字extern，则此函数是外部函数，可供其他文件调用。\n\n一般形式为：\n\nextern 类型名 函数名(形参表);\n\n\n1\n\n\nc语言规定，如果在定义函数时省略extern，则默认为外部函数。\n\n在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也需要用函数原型进行声明）。在对此函数作声明时，要加关键字extern，表示该函数 “是在其他文件中定义的外部函数” 。',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"C语言发展历程",frontmatter:{title:"C语言发展历程",date:"2021-09-11T14:30:00.000Z",permalink:"/c/note0/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/01.C%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.html",relativePath:"50.C语言/01.C语言发展历程.md",key:"v-5476c9e9",path:"/c/note0/",headers:[{level:2,title:"历史介绍及环境搭建",slug:"历史介绍及环境搭建",normalizedTitle:"历史介绍及环境搭建",charIndex:14},{level:2,title:"C的发展与版本-K&R",slug:"c的发展与版本-k-r",normalizedTitle:"c的发展与版本-k&amp;r",charIndex:null},{level:2,title:"C的发展与版本-标准",slug:"c的发展与版本-标准",normalizedTitle:"c的发展与版本-标准",charIndex:381},{level:2,title:"C语⾔⽤在哪⾥？",slug:"c语言用在哪里",normalizedTitle:"c语⾔⽤在哪⾥？",charIndex:504},{level:2,title:"C语言编译软件（IDE）",slug:"c语言编译软件-ide",normalizedTitle:"c语言编译软件（ide）",charIndex:569}],headersStr:"历史介绍及环境搭建 C的发展与版本-K&R C的发展与版本-标准 C语⾔⽤在哪⾥？ C语言编译软件（IDE）",content:"# C语言发展历程\n\n\n# 历史介绍及环境搭建\n\n * C语⾔是从B语⾔发展⽽来的，B语⾔是从BCPL发展⽽来的，BCPL是从 FORTRAN发展⽽来的。\n * BCPL和B都⽀持指针间接⽅式，所以C也⽀持了。\n * C语⾔还受到了PL/1的影响，还和PDP-11的机器语⾔有很⼤的关系。\n * 1973年3⽉，第三版的Unix上出现了C语⾔的编译器。\n * 1973年11⽉，第四版的Unix（System Four）发布了，这个版本是完全用C语言重新编写的。\n\n\n# C的发展与版本-K&R\n\n * 经典 C ----\x3e ⼜被叫做 “K&R the C”\n * The C Programming Language, by Brian Kernighan and Dennis Ritchie, 2nd Edition, Prentice Hall\n\n\n# C的发展与版本-标准\n\n * 1989年ANSI发布了⼀个标准——ANSI C\n * 1990年ISO接受了ANSI的标准——C89\n * C的标准在1995年和1999年两次更新——C95和C99\n * 所有的当代编译器都⽀持C99了\n\n\n# C语⾔⽤在哪⾥？\n\n * 操作系统\n * 嵌⼊式系统\n * 驱动程序\n * 底层驱动\n * 图形引擎、图像处理、声⾳效果\n\n\n# C语言编译软件（IDE）\n\n * Dev C++（4.9 for Win7, 5.0 for Win8）\n * MS Visual Studio Express（Windows）\n * Xcode（Mac OS X）\n * Eclipse-CDT\n * Geany（和MinGW⼀起）\n * Sublime（和MinGW⼀起）\n * vim/emacs（和MinGW⼀起）",normalizedContent:"# c语言发展历程\n\n\n# 历史介绍及环境搭建\n\n * c语⾔是从b语⾔发展⽽来的，b语⾔是从bcpl发展⽽来的，bcpl是从 fortran发展⽽来的。\n * bcpl和b都⽀持指针间接⽅式，所以c也⽀持了。\n * c语⾔还受到了pl/1的影响，还和pdp-11的机器语⾔有很⼤的关系。\n * 1973年3⽉，第三版的unix上出现了c语⾔的编译器。\n * 1973年11⽉，第四版的unix（system four）发布了，这个版本是完全用c语言重新编写的。\n\n\n# c的发展与版本-k&r\n\n * 经典 c ----\x3e ⼜被叫做 “k&r the c”\n * the c programming language, by brian kernighan and dennis ritchie, 2nd edition, prentice hall\n\n\n# c的发展与版本-标准\n\n * 1989年ansi发布了⼀个标准——ansi c\n * 1990年iso接受了ansi的标准——c89\n * c的标准在1995年和1999年两次更新——c95和c99\n * 所有的当代编译器都⽀持c99了\n\n\n# c语⾔⽤在哪⾥？\n\n * 操作系统\n * 嵌⼊式系统\n * 驱动程序\n * 底层驱动\n * 图形引擎、图像处理、声⾳效果\n\n\n# c语言编译软件（ide）\n\n * dev c++（4.9 for win7, 5.0 for win8）\n * ms visual studio express（windows）\n * xcode（mac os x）\n * eclipse-cdt\n * geany（和mingw⼀起）\n * sublime（和mingw⼀起）\n * vim/emacs（和mingw⼀起）",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第七章 对文件的输入输出",frontmatter:{title:"第七章 对文件的输入输出",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note7/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/08.%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html",relativePath:"50.C语言/08.第七章对文件的输入输出.md",key:"v-a1b67a0a",path:"/c/note7/",headers:[{level:2,title:"1. C文件的有关基本知识",slug:"_1-c文件的有关基本知识",normalizedTitle:"1. c文件的有关基本知识",charIndex:19},{level:2,title:"2. 打开与关闭文件",slug:"_2-打开与关闭文件",normalizedTitle:"2. 打开与关闭文件",charIndex:2610},{level:2,title:"3. 顺序读写数据文件",slug:"_3-顺序读写数据文件",normalizedTitle:"3. 顺序读写数据文件",charIndex:6213}],headersStr:"1. C文件的有关基本知识 2. 打开与关闭文件 3. 顺序读写数据文件",content:'# 第七章 对文件的输入输出\n\n\n# 1. C文件的有关基本知识\n\n什么是文件\n\n文件有不同的类型,在程序设计中,主要用到两种文件:\n\n(1)程序文件。包括源程序文件(后缀为.c)、目标文件(后缀为.obj)、可执行文件(后缀为.exe)等。这种文件的内容是程序代码。\n\n(2)数据文件。文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读人的数据。如一批学生的成绩数据、货物交易的数据等。\n\n * 文件(file)是程序设计中一个重要的概念。所谓“文件”一般指存储在外部介质上数据的集合。一批数据是以文件的形式存放在外部介质(如磁盘)上的。\n\n * 输人输出是数据传送的过程，数据如流水一样从一处流向另一处，因此常将输人输出形象地称为流（stream） ,即数据流。\n\n * C语言把文件看作一个字符（或字节）的序列，即由一个一个字符（或字节）的数据顺序组成。一个输入输出流就是一个字符流或字节（内容为二进制数据）流。\n\n * C的数据文件由一连串的字符（或字节）组成，而不考虑行的界限，两行数据间不会自动加分隔符，对文件的存取是以字符（字节）为单位的。输人输出数据流的开始和结束仅受程序控制而不受物理符号（如回车换行符）控制，这就增加了处理的灵活性。这种文件称为流式文件。\n\n----------------------------------------\n\n文件名\n\n一个文件要有一个唯一的文件标识，以便用户识别和引用。\n\n文件标识包括3部分: (1)文件路径; (2)文件名主干; (3)文件后缀。\n\n文件路径表示文件在外部存储设备中的位置。如:\n\nD:\\CC\\temp\\filel.dat\n---------- ----- ------\n\t↑\t\t ↑\t\t↑\n文件路径  文件名主干 文件后缀\n\n\n1\n2\n3\n4\n\n\n表示filel.dat文件存放在D盘中的CC目录下的temp子目录下面。\n\n文件名主干的命名规则遵循标识符的命名规则。\n\n后缀 用来表示文件的性质，如：\n\ndoc\t\t(Word生成的文件)\ntxt\t\t(文本文件)\ndat\t\t(数据文件)\nc\t\t(C语 言源程序文件)\ncpp \t(C++源程序文件)\nfor\t\t(FORTRAN语言源程序文件)\npas\t\t(Pascal语 言源程序文件)\nobj\t\t(目标文件)\nexe\t\t(可执行文件)\nppt\t\t(电子幻灯文件)\nbmp\t\t(图形文件)\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n文件的分类\n\n根据数据的组织形式，数据文件可分为ASCII文件和二进制文件。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件(imagefile)。如果要求在外存上以ASCII代码形式存储,则需要在存储前进行转换。ASCII文件又称文本文件(text file),每一个字节存放一个字符的ASCII代码。\n\n一个数据在磁盘上怎样存储呢?\n\n字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以用二进制形式存储。\n\n\n\n----------------------------------------\n\n文件缓冲区\n\nANSI C标准采用“缓冲文件系统”处理数据文件，所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。如果从磁盘向计算机读人数据，则一次从磁盘文件将一批数据输人到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量)，见图10.2。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的C编译系统确定。\n\n说明：每一个文件在内存中只有一个缓冲区，在向文件输出数据时，它就作为输出缓冲区,在从文件输入数据时，它就作为输入缓冲区。\n\n\n\n文件类型指针\n\n缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息(如文件的名字、文件状态及文件当前位置等)。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为FILE。例如有一种C编译环境提供的stdio.h头文仵中有以下的文件类型声明：\n\ntypedef struct{ \n    short level;\t\t\t //缓冲区“满”或“空”的程度\n    unsigned flags; \t\t //文件状态标志\n    char fd;\t\t\t \t //文件描述符\n    unsigned char hold; \t //如缓冲区无内容不读取字符\n    short bsize;\t\t\t //缓冲区的大小\n    unsigned char * buffer;\t //数据缓冲区的位置\n    unsigned char * curp; \t //文件位置标记指针当前的指向\n    unsigned istemp;\t\t //临时文件指示器\n\tshort token;\t\t\t //用于有效性检查\n}FILE;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不同的C编译系统的FILE类型包含的内容不完全相同，但大同小异。对以上结构体中的成员及其含义可不深究，只须知道其中存放文件的有关信息即可。\n\n定义一个指向文件型数据的指针变量：\n\nFILE * fp; \n\n\n1\n\n\n定义fp是一个指向FILE类型数据的指针变量。可以使fp指向某一个文件的文件信息区(是一个结构体变量)，通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。如果有n个文件，应设n个指针变量，分别指向n个FILE类型变量，以实现对n个文件的访问，见图10. 3。\n\n\n\n为方便起见，通常将这种指向文件信息区的指针变量简称为指向文件的指针变量。\n\n注意：指向文件的指针变量并不是指向外部介质上的数据文件的开头，而是指向内存中的文件信息区的开头。\n\n\n# 2. 打开与关闭文件\n\n实际上，所谓 “打开” 是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）。\n\n在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系，这样，就可以通过该指针变量对文件进行读写了。所谓“关闭”是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法进行对文件的读写了。\n\n用fopen函数打开数据文件\n\nANSIC规定了用标准输人输出函数fopen来实现打开文件。\n\nfopen函数的调用方式为：\n\nfopen(文件名,使用文件方式);\n\n\n1\n\n\n例如:\n\nfopen("al","r");\n\n\n1\n\n\n表示要打开名字为al的文件，使用文件方式为 “读入”(r代表read，即读人)。\n\nfopen 函数的返回值是指向al文件的指针(即al文件信息区的起始地址)。\n\n通常将fopen函数的返回值赋给一个指向文件的指针变量。如：\n\nFILE* fp;\t\t\t\t//定义一个指向文件的指针变量fp\nfp= fopen("al","r");\t//将fopen函数的返回值赋给指针变量fp\n\n\n1\n2\n\n\n这样fp就和文件al相联系了,或者说，fp指向了al文件。可以看出，在打开一个文件时，通知编译系统以下3个信息：\n\n①需要打开文件的名字，也就是准备访问的文件的名字;\n\n②使用文件的方式(“读”还是“写”等);\n\n③让哪一个指针变量指向被打开的文件。\n\n表10. 1 使用文件方式\n\n文件使用方式      含义                    如果指定的文件不存在\nr（只读）       为了输入数据，打开一个已存在的文本文件   出错\nw（只写）       为了输出数据，打开一个文本文件       建立新文件\na（追加）       向文本文件尾添加数据            出错\nrb（只读）      为了输人数据，打开一个二进制文件      出错\nwb（只写）      为了输出数据，打开一个二进制文件      建立新文件\nab（追加）      向二进制文件尾添加数据           出错\n"r+"（读写）    为了读和写，打开一个文本文件        出错\n"w+"（读写）    为了读和写，建立一个新的文本文件      建立新文件\n"a+"（读写）    为了读和写，打开一个文本文件        出错\n"rb+"（读写）   为了读和写，打开一个二进制文件       出错\n"wb+"（读写）   为了读和写，建立一个新的二进制文件     建立新文件\n"ab+"（读写）   为读写打开一个二进制文件          出错\n\n(1)用 r 方式打开的文件只能用于向计算机输入而不能用作向该文件输出数据，而且该文件应该已经存在，并存有数据，这样程序才能从文件中读数据。不能用 r 方式打开一个并不存在的文件，否则出错。\n\n(2)用 w 方式打开的文件只能用于向该文件写数据（即输出文件），而不能用来向计算机输入。如果原来不存在该文件，则在打开文件前新建立一个以指定的名字命名的文件。如果原来已存在一个以该文件名命名的文件，则在打开文件前先将该文件删去，然后重新建立一个新文件。\n\n(3)如果希望向文件末尾添加新的数据（不希望删除原有数据），则应该用a方式打开。但此时应保证该文件已存在；否则将得到出错信息。打开文件时，文件读写位置标记移到文件末尾。\n\n(4)用“r十”、“w+”、“a+”方式打开的文件既可用来输人数据，也可用来输出数据。用 “r+” 方式时该文件应该已经存在，以便计算机从中读数据。用 “w十” 方式则新建立一个文件，先向此文件写数据，然后可以读此文件中的数据。用 “a+” 方式打开的文件，原来的文件不被删去，文件读写位置标记移到文件末尾，可以添加，也可以读。\n\n(5)如果不能实现 “打开” 的任务，fopen函数将会带回一个出错信息。出错的原因可能是：用 r 方式打开一个并不存在的文件；磁盘出故障；磁盘已满无法建立新文件等。此时fopen函数将带回一个空指针值NULL(在stdio.h头文件中，NULL已被定义为0)。\n\n常用下面的方法打开一个文件:\n\nif ((fp= fopen("filel","r"))== NULL){\n    printf("cannot open this file\\n");\n    exit(0);\n}\n\n\n1\n2\n3\n4\n\n\n即先检查打开文件的操作有否出错，如果有错就在终端上输出cannot open this file。\n\nexit函数的作用是关闭所有文件，终止正在执行的程序，待用户检查出错误，修改后重新运行。\n\n(7)在表10.1中，有12种文件使用方式，其中有6种是在第一个字母后面加了字母b 的(如rb,wb,ab,rb+ ,wb+ ,ab+)，b表示二进制方式。其实，带b和不带b只有一个区别，即对换行的处理。由于在C语言用一个\'\\n\'即可实现换行，而在Windows系统中为实现换行必须要用“回车”和“换行”两个字符，即\'\\r\'和\'\\n\'。因此,如果使用的是文本文件并且用w方式打开，在向文件输出时，遇到换行符\'\\n\'时，系统就把它转换为\'\\r\'和\'\'\\n\'两个字符，否则在Windows系统中查看文件时，各行连成一片，无法阅读。同样，如果有文本文件且用r方式打开，从文件读人时，遇到\'\\r\'和\'\\n\'两个连续的字符，就把它们转换为\'\\n\'一个字符。如果使用的是二进制文件，在向文件读写时，不需要这种转换。加b表示使用的是二进制文件，系统就不进行转换。\n\n(8)如果用wb的文件使用方式，并不意味着在文件输出时把内存中按ASCII形式保存的数据自动转换成二进制形式存储。输出的数据形式是由程序中采用什么读写语句决定的。例如，用fscanf和fprintf函数是按ASCII方式进行输人输出，而fread和fwrite函数是 按二进制进行输人输出。各种对文件的输人输出语句，详见下一节（3.顺序读写数据文件）。\n\n在打开一个输出文件时，是选w还是wb方式，完全根据需要，如果需要对回车符进行转换的，就用w，如果不需要转换的，就用wb。带b只是通知编译系统：不必进行回车符的转换。如果是文本文件（例如一篇文章），显然需要转换，应该用w方式。如果是用二进制形式保存的一批数据，并不准备供人阅读，只是为了保存数据，就不必进行上述转换。可以用wb方式。一般情况下，带b的用于二进制文件，常称为二进制方式，不带b的用于文本文件，常称为文本方式，从理论上说，文本文件也可以wb方式打开，但无必要。\n\n(9)程序中可以使用3个标准的流文件——标准输入流、标准输出流和标准出错输出流。系统已对这3个文件指定了与终端的对应关系。标准输人流是从终端的输人，标准输出流是向终端的输出，标准出错输出流是当程序出错时将出错信息发送到终端。\n\n程序开始运行时系统自动打开这3个标准流文件。因此，程序编写者不需要在程序中用fopen函数打开它们。所以以前我们用到的从终端输人或输出到终端都不需要打开终端 文件。系统定义了3个文件指针变量stdin，stdout和stderr,分别指向标准输人流、标准输出流和标准出错输出流,可以通过这3个指针变量对以上3种流进行操作，它们都以终端作为输人输出对象。例如程序中指定要从stdin所指的文件输人数据，就是指从终端键盘输人数据。\n\n----------------------------------------\n\n用fcolse函数关闭数据文件\n\n在使用完一个文件后应该关闭它，以防止它再被误用。“关闭”就是撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，也就是文件指针变量与文件‘‘脱钩”，此后不能再通过该指针对原来与其相联系的文件进行读写操作，除非再次打开，使该指针变量重新指向该文件。\n\n关闭文件用fclose函数。fclose函数调用的一般形式为：\n\nfclose(文件指针);\n\n\n1\n\n\n如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。用fclose 函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撤销文件信息区。有的编译系统在程序结束前会自动先将缓冲区中的数据写到文件，从而避免了这个问题，但还是应当养成在程序终止之前关闭所有文件的习惯。\n\nfclose函数也带回一个值，当成功地执行了关闭操作，则返回值为0；否则返回EOF(-1)。\n\n\n# 3. 顺序读写数据文件\n\n在顺序写时，先写入的数据存放在文件的中前面的位置，后写入的数据存放在文件中后面的数据。\n\n在顺序读时，先读文件中最前面的数据，后读文件中后面的数据。\n\n顺序读写需要用函数库来实现。使用前需要导入#include<stdib.h>\n\n怎么向文件读写字符\n\n读写一个字符的函数\n\n函数名     调用形式           功能                      返回值\nfgtc    fgetc(fp)      从fp指向的文件中读入一个字符         读成功，带回所读的字符，失败则返回文件结束标志EOF（即-1）\nfputc   fputc(ch,fp)   把字符ch写文件指针变量fp所指向的文件中   输入成功，返回值就是输出的字符；输出失败，则返回EOF（即-1）\n\n说明：fgetc 的第1个字母f代表文件（file），中间的get表示“获取”，最后一个字母c表示字符（character），fgetc的含义很清楚：从文件读取一个字符。fputc也类似。\n\n此节未完，将于2022年6月后继续更新……',normalizedContent:'# 第七章 对文件的输入输出\n\n\n# 1. c文件的有关基本知识\n\n什么是文件\n\n文件有不同的类型,在程序设计中,主要用到两种文件:\n\n(1)程序文件。包括源程序文件(后缀为.c)、目标文件(后缀为.obj)、可执行文件(后缀为.exe)等。这种文件的内容是程序代码。\n\n(2)数据文件。文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读人的数据。如一批学生的成绩数据、货物交易的数据等。\n\n * 文件(file)是程序设计中一个重要的概念。所谓“文件”一般指存储在外部介质上数据的集合。一批数据是以文件的形式存放在外部介质(如磁盘)上的。\n\n * 输人输出是数据传送的过程，数据如流水一样从一处流向另一处，因此常将输人输出形象地称为流（stream） ,即数据流。\n\n * c语言把文件看作一个字符（或字节）的序列，即由一个一个字符（或字节）的数据顺序组成。一个输入输出流就是一个字符流或字节（内容为二进制数据）流。\n\n * c的数据文件由一连串的字符（或字节）组成，而不考虑行的界限，两行数据间不会自动加分隔符，对文件的存取是以字符（字节）为单位的。输人输出数据流的开始和结束仅受程序控制而不受物理符号（如回车换行符）控制，这就增加了处理的灵活性。这种文件称为流式文件。\n\n----------------------------------------\n\n文件名\n\n一个文件要有一个唯一的文件标识，以便用户识别和引用。\n\n文件标识包括3部分: (1)文件路径; (2)文件名主干; (3)文件后缀。\n\n文件路径表示文件在外部存储设备中的位置。如:\n\nd:\\cc\\temp\\filel.dat\n---------- ----- ------\n\t↑\t\t ↑\t\t↑\n文件路径  文件名主干 文件后缀\n\n\n1\n2\n3\n4\n\n\n表示filel.dat文件存放在d盘中的cc目录下的temp子目录下面。\n\n文件名主干的命名规则遵循标识符的命名规则。\n\n后缀 用来表示文件的性质，如：\n\ndoc\t\t(word生成的文件)\ntxt\t\t(文本文件)\ndat\t\t(数据文件)\nc\t\t(c语 言源程序文件)\ncpp \t(c++源程序文件)\nfor\t\t(fortran语言源程序文件)\npas\t\t(pascal语 言源程序文件)\nobj\t\t(目标文件)\nexe\t\t(可执行文件)\nppt\t\t(电子幻灯文件)\nbmp\t\t(图形文件)\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n文件的分类\n\n根据数据的组织形式，数据文件可分为ascii文件和二进制文件。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件(imagefile)。如果要求在外存上以ascii代码形式存储,则需要在存储前进行转换。ascii文件又称文本文件(text file),每一个字节存放一个字符的ascii代码。\n\n一个数据在磁盘上怎样存储呢?\n\n字符一律以ascii形式存储，数值型数据既可以用ascii形式存储，也可以用二进制形式存储。\n\n\n\n----------------------------------------\n\n文件缓冲区\n\nansi c标准采用“缓冲文件系统”处理数据文件，所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。如果从磁盘向计算机读人数据，则一次从磁盘文件将一批数据输人到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量)，见图10.2。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的c编译系统确定。\n\n说明：每一个文件在内存中只有一个缓冲区，在向文件输出数据时，它就作为输出缓冲区,在从文件输入数据时，它就作为输入缓冲区。\n\n\n\n文件类型指针\n\n缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息(如文件的名字、文件状态及文件当前位置等)。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为file。例如有一种c编译环境提供的stdio.h头文仵中有以下的文件类型声明：\n\ntypedef struct{ \n    short level;\t\t\t //缓冲区“满”或“空”的程度\n    unsigned flags; \t\t //文件状态标志\n    char fd;\t\t\t \t //文件描述符\n    unsigned char hold; \t //如缓冲区无内容不读取字符\n    short bsize;\t\t\t //缓冲区的大小\n    unsigned char * buffer;\t //数据缓冲区的位置\n    unsigned char * curp; \t //文件位置标记指针当前的指向\n    unsigned istemp;\t\t //临时文件指示器\n\tshort token;\t\t\t //用于有效性检查\n}file;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不同的c编译系统的file类型包含的内容不完全相同，但大同小异。对以上结构体中的成员及其含义可不深究，只须知道其中存放文件的有关信息即可。\n\n定义一个指向文件型数据的指针变量：\n\nfile * fp; \n\n\n1\n\n\n定义fp是一个指向file类型数据的指针变量。可以使fp指向某一个文件的文件信息区(是一个结构体变量)，通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。如果有n个文件，应设n个指针变量，分别指向n个file类型变量，以实现对n个文件的访问，见图10. 3。\n\n\n\n为方便起见，通常将这种指向文件信息区的指针变量简称为指向文件的指针变量。\n\n注意：指向文件的指针变量并不是指向外部介质上的数据文件的开头，而是指向内存中的文件信息区的开头。\n\n\n# 2. 打开与关闭文件\n\n实际上，所谓 “打开” 是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）。\n\n在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系，这样，就可以通过该指针变量对文件进行读写了。所谓“关闭”是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法进行对文件的读写了。\n\n用fopen函数打开数据文件\n\nansic规定了用标准输人输出函数fopen来实现打开文件。\n\nfopen函数的调用方式为：\n\nfopen(文件名,使用文件方式);\n\n\n1\n\n\n例如:\n\nfopen("al","r");\n\n\n1\n\n\n表示要打开名字为al的文件，使用文件方式为 “读入”(r代表read，即读人)。\n\nfopen 函数的返回值是指向al文件的指针(即al文件信息区的起始地址)。\n\n通常将fopen函数的返回值赋给一个指向文件的指针变量。如：\n\nfile* fp;\t\t\t\t//定义一个指向文件的指针变量fp\nfp= fopen("al","r");\t//将fopen函数的返回值赋给指针变量fp\n\n\n1\n2\n\n\n这样fp就和文件al相联系了,或者说，fp指向了al文件。可以看出，在打开一个文件时，通知编译系统以下3个信息：\n\n①需要打开文件的名字，也就是准备访问的文件的名字;\n\n②使用文件的方式(“读”还是“写”等);\n\n③让哪一个指针变量指向被打开的文件。\n\n表10. 1 使用文件方式\n\n文件使用方式      含义                    如果指定的文件不存在\nr（只读）       为了输入数据，打开一个已存在的文本文件   出错\nw（只写）       为了输出数据，打开一个文本文件       建立新文件\na（追加）       向文本文件尾添加数据            出错\nrb（只读）      为了输人数据，打开一个二进制文件      出错\nwb（只写）      为了输出数据，打开一个二进制文件      建立新文件\nab（追加）      向二进制文件尾添加数据           出错\n"r+"（读写）    为了读和写，打开一个文本文件        出错\n"w+"（读写）    为了读和写，建立一个新的文本文件      建立新文件\n"a+"（读写）    为了读和写，打开一个文本文件        出错\n"rb+"（读写）   为了读和写，打开一个二进制文件       出错\n"wb+"（读写）   为了读和写，建立一个新的二进制文件     建立新文件\n"ab+"（读写）   为读写打开一个二进制文件          出错\n\n(1)用 r 方式打开的文件只能用于向计算机输入而不能用作向该文件输出数据，而且该文件应该已经存在，并存有数据，这样程序才能从文件中读数据。不能用 r 方式打开一个并不存在的文件，否则出错。\n\n(2)用 w 方式打开的文件只能用于向该文件写数据（即输出文件），而不能用来向计算机输入。如果原来不存在该文件，则在打开文件前新建立一个以指定的名字命名的文件。如果原来已存在一个以该文件名命名的文件，则在打开文件前先将该文件删去，然后重新建立一个新文件。\n\n(3)如果希望向文件末尾添加新的数据（不希望删除原有数据），则应该用a方式打开。但此时应保证该文件已存在；否则将得到出错信息。打开文件时，文件读写位置标记移到文件末尾。\n\n(4)用“r十”、“w+”、“a+”方式打开的文件既可用来输人数据，也可用来输出数据。用 “r+” 方式时该文件应该已经存在，以便计算机从中读数据。用 “w十” 方式则新建立一个文件，先向此文件写数据，然后可以读此文件中的数据。用 “a+” 方式打开的文件，原来的文件不被删去，文件读写位置标记移到文件末尾，可以添加，也可以读。\n\n(5)如果不能实现 “打开” 的任务，fopen函数将会带回一个出错信息。出错的原因可能是：用 r 方式打开一个并不存在的文件；磁盘出故障；磁盘已满无法建立新文件等。此时fopen函数将带回一个空指针值null(在stdio.h头文件中，null已被定义为0)。\n\n常用下面的方法打开一个文件:\n\nif ((fp= fopen("filel","r"))== null){\n    printf("cannot open this file\\n");\n    exit(0);\n}\n\n\n1\n2\n3\n4\n\n\n即先检查打开文件的操作有否出错，如果有错就在终端上输出cannot open this file。\n\nexit函数的作用是关闭所有文件，终止正在执行的程序，待用户检查出错误，修改后重新运行。\n\n(7)在表10.1中，有12种文件使用方式，其中有6种是在第一个字母后面加了字母b 的(如rb,wb,ab,rb+ ,wb+ ,ab+)，b表示二进制方式。其实，带b和不带b只有一个区别，即对换行的处理。由于在c语言用一个\'\\n\'即可实现换行，而在windows系统中为实现换行必须要用“回车”和“换行”两个字符，即\'\\r\'和\'\\n\'。因此,如果使用的是文本文件并且用w方式打开，在向文件输出时，遇到换行符\'\\n\'时，系统就把它转换为\'\\r\'和\'\'\\n\'两个字符，否则在windows系统中查看文件时，各行连成一片，无法阅读。同样，如果有文本文件且用r方式打开，从文件读人时，遇到\'\\r\'和\'\\n\'两个连续的字符，就把它们转换为\'\\n\'一个字符。如果使用的是二进制文件，在向文件读写时，不需要这种转换。加b表示使用的是二进制文件，系统就不进行转换。\n\n(8)如果用wb的文件使用方式，并不意味着在文件输出时把内存中按ascii形式保存的数据自动转换成二进制形式存储。输出的数据形式是由程序中采用什么读写语句决定的。例如，用fscanf和fprintf函数是按ascii方式进行输人输出，而fread和fwrite函数是 按二进制进行输人输出。各种对文件的输人输出语句，详见下一节（3.顺序读写数据文件）。\n\n在打开一个输出文件时，是选w还是wb方式，完全根据需要，如果需要对回车符进行转换的，就用w，如果不需要转换的，就用wb。带b只是通知编译系统：不必进行回车符的转换。如果是文本文件（例如一篇文章），显然需要转换，应该用w方式。如果是用二进制形式保存的一批数据，并不准备供人阅读，只是为了保存数据，就不必进行上述转换。可以用wb方式。一般情况下，带b的用于二进制文件，常称为二进制方式，不带b的用于文本文件，常称为文本方式，从理论上说，文本文件也可以wb方式打开，但无必要。\n\n(9)程序中可以使用3个标准的流文件——标准输入流、标准输出流和标准出错输出流。系统已对这3个文件指定了与终端的对应关系。标准输人流是从终端的输人，标准输出流是向终端的输出，标准出错输出流是当程序出错时将出错信息发送到终端。\n\n程序开始运行时系统自动打开这3个标准流文件。因此，程序编写者不需要在程序中用fopen函数打开它们。所以以前我们用到的从终端输人或输出到终端都不需要打开终端 文件。系统定义了3个文件指针变量stdin，stdout和stderr,分别指向标准输人流、标准输出流和标准出错输出流,可以通过这3个指针变量对以上3种流进行操作，它们都以终端作为输人输出对象。例如程序中指定要从stdin所指的文件输人数据，就是指从终端键盘输人数据。\n\n----------------------------------------\n\n用fcolse函数关闭数据文件\n\n在使用完一个文件后应该关闭它，以防止它再被误用。“关闭”就是撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，也就是文件指针变量与文件‘‘脱钩”，此后不能再通过该指针对原来与其相联系的文件进行读写操作，除非再次打开，使该指针变量重新指向该文件。\n\n关闭文件用fclose函数。fclose函数调用的一般形式为：\n\nfclose(文件指针);\n\n\n1\n\n\n如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。用fclose 函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撤销文件信息区。有的编译系统在程序结束前会自动先将缓冲区中的数据写到文件，从而避免了这个问题，但还是应当养成在程序终止之前关闭所有文件的习惯。\n\nfclose函数也带回一个值，当成功地执行了关闭操作，则返回值为0；否则返回eof(-1)。\n\n\n# 3. 顺序读写数据文件\n\n在顺序写时，先写入的数据存放在文件的中前面的位置，后写入的数据存放在文件中后面的数据。\n\n在顺序读时，先读文件中最前面的数据，后读文件中后面的数据。\n\n顺序读写需要用函数库来实现。使用前需要导入#include<stdib.h>\n\n怎么向文件读写字符\n\n读写一个字符的函数\n\n函数名     调用形式           功能                      返回值\nfgtc    fgetc(fp)      从fp指向的文件中读入一个字符         读成功，带回所读的字符，失败则返回文件结束标志eof（即-1）\nfputc   fputc(ch,fp)   把字符ch写文件指针变量fp所指向的文件中   输入成功，返回值就是输出的字符；输出失败，则返回eof（即-1）\n\n说明：fgetc 的第1个字母f代表文件（file），中间的get表示“获取”，最后一个字母c表示字符（character），fgetc的含义很清楚：从文件读取一个字符。fputc也类似。\n\n此节未完，将于2022年6月后继续更新……',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"变量的存储类别及作用域",frontmatter:{title:"变量的存储类别及作用域",date:"2022-03-23T14:30:00.000Z",permalink:"/c/note8/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/09.%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F.html",relativePath:"50.C语言/09.变量的存储类别及作用域.md",key:"v-f4040932",path:"/c/note8/",headers:[{level:2,title:"一、变量的作用域：存在空间性指变量在程序中的有效范围",slug:"一、变量的作用域-存在空间性指变量在程序中的有效范围",normalizedTitle:"一、变量的作用域：存在空间性指变量在程序中的有效范围",charIndex:18},{level:2,title:"二、变量的生存期：存在的时间性",slug:"二、变量的生存期-存在的时间性",normalizedTitle:"二、变量的生存期：存在的时间性",charIndex:605},{level:2,title:"三、C语言的存储类别",slug:"三、c语言的存储类别",normalizedTitle:"三、c语言的存储类别",charIndex:952}],headersStr:"一、变量的作用域：存在空间性指变量在程序中的有效范围 二、变量的生存期：存在的时间性 三、C语言的存储类别",content:"# 变量的存储类别及作用域\n\n\n# 一、变量的作用域：存在空间性指变量在程序中的有效范围\n\n局部变量、全局变量\n\n1、局（内）部变量：在函数内（复合语句内）定义的变量、它只在本函数内（复合语句内）有效。\n\n知识点：\n\n * 生存期是该语块、进入语块时获得内存，仅能由语块语句访问，退出语句块时释放内存，不再有效；【随用随分配，用完就释放】\n * 定义时不会自动初始化，除非程序员指定初值；\n * 并列语句块各自定义的同名变量互不干扰，不同函数可以有相同变量名；\n * 形参和实参可以同名；\n * 形参也是局部变量；\n * 主函数里的变量也是局部变量；\n * 复合语句里定义的变量也是局部变量；复合语句的局部变量和本函数的局部变量同名时，本函数的局部变量不起作用。【内部的优先】\n\n2、全（外）局变量：在所有函数之外定义的变量\n\n * 生存期是整个程序，从程序运行起占内存，程序退出时释放内存；\n * 有效范围是从定义变量的位置开始到本程序结束；\n * 全局变量必须在所有函数之外定义，且只能定义一次，默认初值为0；\n * 可以通过声明一个extern的全局变量扩张全局变量的作用域，也可以通过定义一个static的全局变量限制这种扩展；\n * 全局变量增加函数间数据联系、函数只能返回一个值，可用影响全局变量的方式带回给主函数多个值；\n * 全局变量会降低程序的清晰性；因为所有函数都能影响变量的值；\n\n\n# 二、变量的生存期：存在的时间性\n\n静态存储和动态存储\n\n静态存储区：全局变量、局部静态变量；编译时分配内存，初值为0；初始化只有一次，执行完不释放，程序结束释放。\n\n动态存储区：局部变量；随用随分配，用完就释放；初值为随机数，初始化可以多次\n\n1、动态存储变量：数据类型 变量名表；\n\n * 进入语句块时自动申请内存，退出时自动释放内存；\n * 未赋初值时，其值不确定，每次调用重新赋值；\n * 局部变量（不含静态局部变量）、形参\n\n2、静态存储变量（static）：static 数据类型 变量名表；\n\n * 局部静态变量编译时赋初值一次，以后每次调用不再重新赋初值，而是保留上一次函数调用结束时的值；\n * 局部静态变量定义时不赋初值则自动赋初值0；\n * 全局变量、静态局部变量\n\n\n# 三、C语言的存储类别\n\n1、auto型（自动变量）【缺省】\n\n2、static型（静态变量） 3、register型（寄存器变量）：为了提高某些变量和函数形参的存取速度，c允许将局部变量的值存在CPU寄存器中，不用去内存取数据\n\n4、extern型（外部变量）：如果需要用它文件中的全局变量，则需在文本中使用extern int x;说明一下。【扩展作用域】\n\n注意：\n\n * 只有局部自动变量和形参能作为寄存器变量，静态变量不可以；\n * 寄存器数目有限，不能定义任意多个寄存器变量；\n * 只有int、char和指针类型变量可以定义为寄存器型；\n * 一个变量只能声明一个存储类别；\n * extern只能用来说明变量，不能用来定义变量。extern int a=1;×错误\n\n此节未完，将于2022年6月后继续更新……",normalizedContent:"# 变量的存储类别及作用域\n\n\n# 一、变量的作用域：存在空间性指变量在程序中的有效范围\n\n局部变量、全局变量\n\n1、局（内）部变量：在函数内（复合语句内）定义的变量、它只在本函数内（复合语句内）有效。\n\n知识点：\n\n * 生存期是该语块、进入语块时获得内存，仅能由语块语句访问，退出语句块时释放内存，不再有效；【随用随分配，用完就释放】\n * 定义时不会自动初始化，除非程序员指定初值；\n * 并列语句块各自定义的同名变量互不干扰，不同函数可以有相同变量名；\n * 形参和实参可以同名；\n * 形参也是局部变量；\n * 主函数里的变量也是局部变量；\n * 复合语句里定义的变量也是局部变量；复合语句的局部变量和本函数的局部变量同名时，本函数的局部变量不起作用。【内部的优先】\n\n2、全（外）局变量：在所有函数之外定义的变量\n\n * 生存期是整个程序，从程序运行起占内存，程序退出时释放内存；\n * 有效范围是从定义变量的位置开始到本程序结束；\n * 全局变量必须在所有函数之外定义，且只能定义一次，默认初值为0；\n * 可以通过声明一个extern的全局变量扩张全局变量的作用域，也可以通过定义一个static的全局变量限制这种扩展；\n * 全局变量增加函数间数据联系、函数只能返回一个值，可用影响全局变量的方式带回给主函数多个值；\n * 全局变量会降低程序的清晰性；因为所有函数都能影响变量的值；\n\n\n# 二、变量的生存期：存在的时间性\n\n静态存储和动态存储\n\n静态存储区：全局变量、局部静态变量；编译时分配内存，初值为0；初始化只有一次，执行完不释放，程序结束释放。\n\n动态存储区：局部变量；随用随分配，用完就释放；初值为随机数，初始化可以多次\n\n1、动态存储变量：数据类型 变量名表；\n\n * 进入语句块时自动申请内存，退出时自动释放内存；\n * 未赋初值时，其值不确定，每次调用重新赋值；\n * 局部变量（不含静态局部变量）、形参\n\n2、静态存储变量（static）：static 数据类型 变量名表；\n\n * 局部静态变量编译时赋初值一次，以后每次调用不再重新赋初值，而是保留上一次函数调用结束时的值；\n * 局部静态变量定义时不赋初值则自动赋初值0；\n * 全局变量、静态局部变量\n\n\n# 三、c语言的存储类别\n\n1、auto型（自动变量）【缺省】\n\n2、static型（静态变量） 3、register型（寄存器变量）：为了提高某些变量和函数形参的存取速度，c允许将局部变量的值存在cpu寄存器中，不用去内存取数据\n\n4、extern型（外部变量）：如果需要用它文件中的全局变量，则需在文本中使用extern int x;说明一下。【扩展作用域】\n\n注意：\n\n * 只有局部自动变量和形参能作为寄存器变量，静态变量不可以；\n * 寄存器数目有限，不能定义任意多个寄存器变量；\n * 只有int、char和指针类型变量可以定义为寄存器型；\n * 一个变量只能声明一个存储类别；\n * extern只能用来说明变量，不能用来定义变量。extern int a=1;×错误\n\n此节未完，将于2022年6月后继续更新……",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"vue",frontmatter:{title:"vue",date:"2021-09-21T10:30:00.000Z",permalink:"/vue/note0/",author:{name:"wfmiss",href:"git.wfmiss.cn"}},regularPath:"/70.vue/01.vue.html",relativePath:"70.vue/01.vue.md",key:"v-30d162f2",path:"/vue/note0/",headers:[{level:2,title:"起步：",slug:"起步",normalizedTitle:"起步：",charIndex:220},{level:2,title:"本地应用",slug:"本地应用",normalizedTitle:"本地应用",charIndex:639},{level:2,title:"小黑记事本",slug:"小黑记事本",normalizedTitle:"小黑记事本",charIndex:3576}],headersStr:"起步： 本地应用 小黑记事本",content:'time: 2021/9/21\nauthor: wfmiss\nContact: git.wfmiss.cn\nsynopsis: \n\t个人vue学习笔记\n\tvue官网：https://cn.vuejs.org \n\t学习视频地址（黑马程序员）：https://www.bilibili.com/video/BV12J411m7MG?spm_id_from=333.999.0.0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vue 入门\n\n\n# 起步：\n\n创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n\x3c!-- 开发环境版本，包含了有帮助的命令行警告 --\x3e\n<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"><\/script>\n或者：\n\n\x3c!-- 生产环境版本，优化了尺寸和速度 --\x3e\n<script src="https://cdn.jsdelivr.net/npm/vue@2"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n在页面中写入：\n\n<div id="app">\n  {{ message }}\n</div>\n\n<script>\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 本地应用\n\n1.内容事件绑定 v-text :设置标签的文本值（textContent） 代码：\n\n<div id="app">\n\t<h2 v-text="message"></h2> //会把h2标签中所有内容都替换掉\n\t<h2>深圳{{message}}</h2>\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdate:{\n\t\t\tmessage:"黑马程序员"\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nv-html :设置标签的innerHTML 代码：\n\n<div id="app">\n\t<p v-html="content"></p>\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdate:{\n\t\t\tcontent:"<a href="#">黑马程序员</a>"\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nv-on基础 :为元素绑定事件 代码：\n\n<div id="app">\n\t<input type="button" value="事件绑定" v-on:事件名="方法">\n\t<input type="button" value="事件绑定" v-on:click="dolt"> //单击事件\n\t<input type="button" value="事件绑定" v-on:monseenter="dolt"> //鼠标移动事件\n\t<input type="button" value="事件绑定" v-on:dblclick="dolt"> //双击事件\n\t<input type="button" value="事件绑定" @dblclick="dolt"> //v-on简写\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tmethods:{\n\t\t\tdolt:function(){\n\t\t\t\t//逻辑\n\t\t\t}\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n2.显示切换、属性绑定： v-show :根据表达式真假，切换元素的显示和隐藏 代码：\n\n<div id="app">\n\t<img src="地址" v-show="true">\n\t<img src="地址" v-show="isShow">\n\t<img src="地址" v-show="age>=18">\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tisShow:false,\n\t\t\tage:18\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nv-if :根据表达式的真假，切换元素显示的和隐藏（操纵dom元素） 代码：\n\n<div id="app">\n\t<p v-if="true">我是一个p标签</p>\n\t<p v-if="isShow">我是一个p标签</p>\n\t<p v-if="表达式">我是一个p标签</p>\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tisShow:false\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nv-bind :设置元素的属性（比如：src，title，class） 代码：\n\n<div id="app">\n\t<img v-bing:属性="方法名">\n\t<img v-bing:src="imgSrc">\n\t<img v-bing:title="imgTitle+\'!!!\'">\n\t<img v-bing:class="isActive?\'acive\':\'\'">\n\t<img v-bing:class="{active:isActive}">\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\timgSrc:"图片地址",\n\t\t\timgTitle:"黑马程序员",\n\t\t\tisActive:false,\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n3.列表循环、表单元素绑定： v-for :根据数据生成列表结构 代码：\n\n语法为：(item,index) in 数据\n\n<div id="app">\n\t<ul>\n\t\t<li v-for="(item,index) in arr">\n\t\t\t{{index}{item}}\n\t\t</li>\n\t\t<li v-for="(item,index) in objArr">\n\t\t\t{{item.name}}\n\t\t</li>\n\t</ul>\n</div>\n\n<script>\n\tvar app = new Vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tarr:[1,2,3,4,5],\n\t\t\tobjArr:[{name:"jack"},{name:"rose"}]\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nv-on补充 :自定义参数，事件修饰符 代码：\n\n<div>\n\t<input type="button" @click="dolt(p1,p2)"/>\n\t<input type="text" @click="sayHi"/>\n</div>\n\n<script>\n\tvar app = new Vue({ \n\t\tel:"#app",\n\t\tmethods{\n\t\tdolt:function(p1,p2){},\n\t\tsayHi:function(){}\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n更多：https://cn.vuejs.org/v2/api/#v-on\n\nv-model :获取和设置表单元素的值（双向数据绑定） 代码：\n\n<div>\n\t<input type="text" v-model="message"/>\n</div>\n\n<script>\n\tvar app = new Vue({\n\tel:"#app",\n\tdata:{\n\t\tmessage:"黑马程序员"\n\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：绑定的值会和表单元素值相关联（绑定的数据<——>表单元素的值）\n\n\n# 小黑记事本',normalizedContent:'time: 2021/9/21\nauthor: wfmiss\ncontact: git.wfmiss.cn\nsynopsis: \n\t个人vue学习笔记\n\tvue官网：https://cn.vuejs.org \n\t学习视频地址（黑马程序员）：https://www.bilibili.com/video/bv12j411m7mg?spm_id_from=333.999.0.0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vue 入门\n\n\n# 起步：\n\n创建一个 .html 文件，然后通过如下方式引入 vue：\n\n\x3c!-- 开发环境版本，包含了有帮助的命令行警告 --\x3e\n<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"><\/script>\n或者：\n\n\x3c!-- 生产环境版本，优化了尺寸和速度 --\x3e\n<script src="https://cdn.jsdelivr.net/npm/vue@2"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n在页面中写入：\n\n<div id="app">\n  {{ message }}\n</div>\n\n<script>\nvar app = new vue({\n  el: \'#app\',\n  data: {\n    message: \'hello vue!\'\n  }\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 本地应用\n\n1.内容事件绑定 v-text :设置标签的文本值（textcontent） 代码：\n\n<div id="app">\n\t<h2 v-text="message"></h2> //会把h2标签中所有内容都替换掉\n\t<h2>深圳{{message}}</h2>\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdate:{\n\t\t\tmessage:"黑马程序员"\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nv-html :设置标签的innerhtml 代码：\n\n<div id="app">\n\t<p v-html="content"></p>\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdate:{\n\t\t\tcontent:"<a href="#">黑马程序员</a>"\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nv-on基础 :为元素绑定事件 代码：\n\n<div id="app">\n\t<input type="button" value="事件绑定" v-on:事件名="方法">\n\t<input type="button" value="事件绑定" v-on:click="dolt"> //单击事件\n\t<input type="button" value="事件绑定" v-on:monseenter="dolt"> //鼠标移动事件\n\t<input type="button" value="事件绑定" v-on:dblclick="dolt"> //双击事件\n\t<input type="button" value="事件绑定" @dblclick="dolt"> //v-on简写\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tmethods:{\n\t\t\tdolt:function(){\n\t\t\t\t//逻辑\n\t\t\t}\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n2.显示切换、属性绑定： v-show :根据表达式真假，切换元素的显示和隐藏 代码：\n\n<div id="app">\n\t<img src="地址" v-show="true">\n\t<img src="地址" v-show="isshow">\n\t<img src="地址" v-show="age>=18">\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tisshow:false,\n\t\t\tage:18\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nv-if :根据表达式的真假，切换元素显示的和隐藏（操纵dom元素） 代码：\n\n<div id="app">\n\t<p v-if="true">我是一个p标签</p>\n\t<p v-if="isshow">我是一个p标签</p>\n\t<p v-if="表达式">我是一个p标签</p>\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tisshow:false\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nv-bind :设置元素的属性（比如：src，title，class） 代码：\n\n<div id="app">\n\t<img v-bing:属性="方法名">\n\t<img v-bing:src="imgsrc">\n\t<img v-bing:title="imgtitle+\'!!!\'">\n\t<img v-bing:class="isactive?\'acive\':\'\'">\n\t<img v-bing:class="{active:isactive}">\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\timgsrc:"图片地址",\n\t\t\timgtitle:"黑马程序员",\n\t\t\tisactive:false,\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n3.列表循环、表单元素绑定： v-for :根据数据生成列表结构 代码：\n\n语法为：(item,index) in 数据\n\n<div id="app">\n\t<ul>\n\t\t<li v-for="(item,index) in arr">\n\t\t\t{{index}{item}}\n\t\t</li>\n\t\t<li v-for="(item,index) in objarr">\n\t\t\t{{item.name}}\n\t\t</li>\n\t</ul>\n</div>\n\n<script>\n\tvar app = new vue({\n\t\tel:"#app",\n\t\tdata:{\n\t\t\tarr:[1,2,3,4,5],\n\t\t\tobjarr:[{name:"jack"},{name:"rose"}]\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nv-on补充 :自定义参数，事件修饰符 代码：\n\n<div>\n\t<input type="button" @click="dolt(p1,p2)"/>\n\t<input type="text" @click="sayhi"/>\n</div>\n\n<script>\n\tvar app = new vue({ \n\t\tel:"#app",\n\t\tmethods{\n\t\tdolt:function(p1,p2){},\n\t\tsayhi:function(){}\n\t\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n更多：https://cn.vuejs.org/v2/api/#v-on\n\nv-model :获取和设置表单元素的值（双向数据绑定） 代码：\n\n<div>\n\t<input type="text" v-model="message"/>\n</div>\n\n<script>\n\tvar app = new vue({\n\tel:"#app",\n\tdata:{\n\t\tmessage:"黑马程序员"\n\t}\n\t})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：绑定的值会和表单元素值相关联（绑定的数据<——>表单元素的值）\n\n\n# 小黑记事本',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"微型计算机原理及应用",frontmatter:{title:"微型计算机原理及应用",date:"2021-05-16T15:30:00.000Z",permalink:"/smc/0/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/60.SMC/01.%E5%89%8D%E8%A8%80.html",relativePath:"60.SMC/01.前言.md",key:"v-556e5941",path:"/smc/0/",headers:[{level:2,title:"绪论",slug:"绪论",normalizedTitle:"绪论",charIndex:17},{level:2,title:"1.计算机系统的组成",slug:"_1-计算机系统的组成",normalizedTitle:"1.计算机系统的组成",charIndex:1244},{level:2,title:"2. 微型计算机的一般工作过程",slug:"_2-微型计算机的一般工作过程",normalizedTitle:"2. 微型计算机的一般工作过程",charIndex:2129},{level:2,title:"3. 冯·诺依曼计算机",slug:"_3-冯·诺依曼计算机",normalizedTitle:"3. 冯·诺依曼计算机",charIndex:3692},{level:2,title:"4. 哈弗结构",slug:"_4-哈弗结构",normalizedTitle:"4. 哈弗结构",charIndex:3963}],headersStr:"绪论 1.计算机系统的组成 2. 微型计算机的一般工作过程 3. 冯·诺依曼计算机 4. 哈弗结构",content:"# 微型计算机原理及应用\n\n\n# 绪论\n\n本笔记适用于河北专接本考试，个人理解仅供参考，不喜勿喷！！！\n\n * 世界上第一台可以由程序控制的计算机称为电子数字积分器与计算器(electronic numerical integrator and calculator , ENIAC)。它是在1946年为了弹道设计的需要而由 美国宾夕法尼亚大学研制出来的。\n\n * 第一代是电子管数字计算机,其发展年代大约为1946年——1958年。此时计算机的逻辑元件采用电子管,主存储器采用磁鼓、磁芯,外存储器已开始采用磁带,软件主要用机器语言来编制程序,后期逐步发展了汇编语言。当时主要用作科学计算。\n\n * 第二代是晶体管计算机。其发展年代大致为1958年一1964年。计算机的逻辑元件为晶体管,主存储器仍用磁芯,外存储器已开始使用磁盘,软件已开始有很大的发展,出现了各种高级语言及编译程序。此时计算机的应用已发展至各种事务的数据处理,并开始用于工业控制。\n\n * 第三代是集成电路计算机,其发展年代为1964年——1971年。此时的计算机,其逻辑元件已开始采用小规模和中规模的集成电路,即所谓SSI和MSI主存储器仍以磁芯为主。软件发展更快,已有分时操作系统。会话式的高级语言也已出现并有相当的发展。小型计算机也随着集成电路规模的增大而很快地发展起来。应用的范围也日益扩大,企事业管理与工业控制都逐步引入小型计算机。\n\n * 第四代是大规模集成电路发展起来之后的产物。这是从1971年之后发展起来的。 所谓大规模集成电路(LSD)是指在单片硅片，上可以集成1000至20000个晶体管的集成电路。由于LSI的体积小,耗能很少,可靠性很高,因而促使微型计算机以很快的速度在发展。\n\n * 20世纪80年代以来,微型计算机的类型已很多,体积越来越小,功能越来越强。\n\n * 微型计算机(microcomputer)的特点,与大、中、小型计算机的区别，就在于其中央处理器(CPU)是集中在一小块硅片上的，而大、中、小型计算机的CPU则是由相当多的电路(或集成电路)组成的。为了区别于大、中、小型计算机的CPU,而称微型计算机的 CPU芯片为微处理器( microprocessing unit或microprocesser , MPU)。\n\n微型计算机除有MPU作为中央处理器之外,还有以大规模集成电路制成的主存储器和输人输出接口电路。这三者之间是采用总线结构联系起来的。\n\n如果再配上相应的外围设备如显示器(CRT)、键盘及打印机等,这就成为微型计算机系统(microcomputersystem)。实际上作为数据处理的必须是较完备的微型计算机系统。作为工业控制,尤其是小型仪器仪表或小型设备的检测控制，则可只用微型计算机、单板计算机或单片计算机，甚至是一位计算机，这样可以尽量缩小机器的体积,不过此时又得增加相应的检测通道和控制通道,如放大器和A/D或D/A转换器之类的辅助元件或电路。\n\n\n# 1.计算机系统的组成\n\n\n\n微处理器：\n\n微处理器简称CPU，是计算机的核心。\n\n主要包括：\n\n * 运算器（算术逻辑运算器ALU）\n * 控制器\n * 寄存器组\n\n存储器：\n\n定义：计算机中的记忆装置。用于存放计算机工作过程中需要操作的数据和程序。\n\n存储器:\n\t- 内存储器\n\t\t+ 随机存取储存储器（RAM）\n\t\t+ 只读存储器（ROM）\n\t- 外存储器\n\t\t+ 联机外存---硬磁盘\n\t\t+ 脱机外存---各种移动存储设备\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n内存储器特点：\n\n * 存取速度较快，容量相对较小。\n * 内存按单元组织，每一个单元都对应一个唯一的地址。\n * 每一个存储单元中存放1Byte数据。\n * 内存单元个数称为内存容量。\n\n有关存储器的属于：\n\n * 存储容量\n   * 存放的数据量。用字节表示。\n * 对存储器的操作\n   * 读（出），写（入）\n   * 读：将内存单元的内容取入CPU，原单元内容不改变；\n   * 写：CPU将信息放入内存单元，单元中原来的内容被覆盖。\n\n接口：\n\n口是CPU与外部设备间的桥梁。\n\n主要功能：\n\n * 数据缓冲寄存器；\n * 信号电平或类型的装换；\n * 实现主机与外部设间的运行匹配。\n\n总线：\n\n * 是一组导线和相关的控制、驱动电路的集合。\n * 是计算机系统个部件之间传输地址、数据和控制信息的通路\n\n总线分为：地址总线（AB）、数据总线（DB）、控制总线（CB）\n\n软件系统：\n\n软件：为运行、管理和维护计算机系统或为实现某一功能而编写的各种程序的总和及其相关资料。\n\n软件：\n\t系统软件\n\t\t操作系统\n\t\t编译系统\n\t\t网络系统\n\t\t工具软件\n\t应用软件\n\t\t用户软件\n\t\t娱乐软件\n\t\t工作软件\n\t\t...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n主机系统特征\n\n * 能够与CPU直接进行信息换的部件属于主机系统\n * 不能够与CPU直接进行信息换的部件属于外部设备\n\n\n# 2. 微型计算机的一般工作过程\n\n计算机的工作就是执行程序\n\n程序是指令的序列\n\n计算机的工作就是按照一定的顺序，一条条地执行指令\n\n**指令：**由人向计算机发出的，能够被计算计所识别的命令\n\n计算机的工作是逐条执行由命令构成的程序\n\n * 程序是指令的序列\n   * 计算机的工作过程就是执行指令的过程\n\n指令的执行过程：\n\n取指令 -----\x3e 分析指令 -------\x3e 读取操作数 ------\x3e 执行指令 ------\x3e 存放结果\n\n\n1\n\n * 顺序执行：一条指令执行完了再执行下一条指令。\n   * 执行时间=取指令+分析指令+执行指令\n   * 设：三个部分执行的时间均为x，则：执行n条指令时间为y为：y=3n*x\n * 并行指令：同时执行两条或多条指令。\n   * 仅第1条指令需要3x时间，之后每经过1x，就有一条指令执行结束\n   * 执行时间：y=3x+(n-1)x\n\n----------------------------------------\n\n并行：更高的效率，更高的复杂度\n\n相对于顺序执行方式，指令并行执行的优势用加速比S表示：\n\n * S=顺序执行花费的时间/并行执行花费的时间\n\n微机系统主要技术指标\n\n常用名词术语：\n\n * 位（bit或b）：最小的信息单位，二进制的一位数。\n\n * 字节（byte或B）：是计算机的最小存储单元。\n   \n   * 1 byte = 8 bit,从00000000~11111111\n     可表示255个状态（数值）；\n     一般数字、字母、普通字符用一个字节就可表示，但汉字、特殊符号等需要两个或多个字节来表示。\n     \n     \n     1\n     2\n     3\n     \n\n * 字（word或w）：是计算机进行数据交换、加工、存储的基本运算单位、一个字由一个或若干个字节构成，通常将组成一个字的位数叫作该字的字长。\n   \n   * 字长越长，在相同时间内能传送更多的信息，从而运算速度更快；计算机有更大的寻址空间，从而内存储容量更大；计算机系统支持的指令数量越多，功能就越强。\n\n主要技术指标\n\n * 机器字长：是指计算机内部ALU能够一次同时处理的二进制的位数。\n   * 字长越长，运算精度越高。通常字长都是字节（8位二进制数）的整数倍，如8位、16位、32位、64位等。\n * 主频：计算机的时钟频率，在一定程度上反映机器运算速度，主频越高，运算速度越快。主频的单位是MHz（兆赫）。\n   * 频率 = 1/周期\n * 内存容量：计算机可存储信息的多少，通常以字节为单位。一般用KB、MB、GB、TB、PB为单位。\n   * 容量越大存储的程序和数据越多，处理能力也越强。【2的10次方=1024】\n * 运算速度：运算速度的一种表示方式是MIPS（millions of instructions per second），即每秒百万条指令，它主要是对整数运算而言。对于浮点运算，一般使用MFLOPS（million floating point operations per second）表示，即每秒百万次浮点运算。\n\n----------------------------------------\n\n流水线技术\n\n计算机中的流水线就是把一个重复的过程与其他子过程并行进行。\n\n即：\n\n取指令 -----》分析指令 ------》执行指令\n\t\t\t 取指令  ------》分析指令 ------》执行指令\n\t\t\t \t\t\t\t取指令  ------》分析指令 ------》执行指令\n\t\t\t \t\t\t\t\t\t\t\t.....\n\n\n1\n2\n3\n4\n\n\n从本质上讲，流水线技术就是一种时间并行技术。\n\n\n# 3. 冯·诺依曼计算机\n\n * 冯·诺依曼计算机的工作原理\n   * 存储程序工作原理\n * 结构特点\n   * 运算器为核心\n   * 程序存储、共享数据、顺序执行\n   * 属于顺序处理机，适合于确定的算法和数值数据的处理。\n * 不足：\n   * 与存储器间有大量数据交互，对总线要求很高；\n   * 执行顺序由程序决定，对大型复杂任务较困难；\n   * 以运算器为核心，处理效率较低；\n   * 由PC控制执行顺序，难以进行真正的并行处理。\n\n----------------------------------------\n\n\n# 4. 哈弗结构\n\n * 指令和数据分别存放在两个独立的存储器模块中；\n\n * CPU与存储器间指令和数据的传送分别采用两组独立的总线；\n\n * 可以在一个机器周期内同时获得指令操作码和操作数。\n\n|-----------|-----\x3e（地址信号） |---------------|\n|\t\t\t|\t\t\t\t  |   程序存储器    |\n|\t\t\t|<---- （数据信号） |---------------|\n|\tCPU \t|==================================\n|\t\t\t|------\x3e（地址信号）|---------------|\n|\t\t\t|\t\t\t\t  |   数据存储器    | \n|-----------| <-----（数据信号）|---------------|\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 微型计算机原理及应用\n\n\n# 绪论\n\n本笔记适用于河北专接本考试，个人理解仅供参考，不喜勿喷！！！\n\n * 世界上第一台可以由程序控制的计算机称为电子数字积分器与计算器(electronic numerical integrator and calculator , eniac)。它是在1946年为了弹道设计的需要而由 美国宾夕法尼亚大学研制出来的。\n\n * 第一代是电子管数字计算机,其发展年代大约为1946年——1958年。此时计算机的逻辑元件采用电子管,主存储器采用磁鼓、磁芯,外存储器已开始采用磁带,软件主要用机器语言来编制程序,后期逐步发展了汇编语言。当时主要用作科学计算。\n\n * 第二代是晶体管计算机。其发展年代大致为1958年一1964年。计算机的逻辑元件为晶体管,主存储器仍用磁芯,外存储器已开始使用磁盘,软件已开始有很大的发展,出现了各种高级语言及编译程序。此时计算机的应用已发展至各种事务的数据处理,并开始用于工业控制。\n\n * 第三代是集成电路计算机,其发展年代为1964年——1971年。此时的计算机,其逻辑元件已开始采用小规模和中规模的集成电路,即所谓ssi和msi主存储器仍以磁芯为主。软件发展更快,已有分时操作系统。会话式的高级语言也已出现并有相当的发展。小型计算机也随着集成电路规模的增大而很快地发展起来。应用的范围也日益扩大,企事业管理与工业控制都逐步引入小型计算机。\n\n * 第四代是大规模集成电路发展起来之后的产物。这是从1971年之后发展起来的。 所谓大规模集成电路(lsd)是指在单片硅片，上可以集成1000至20000个晶体管的集成电路。由于lsi的体积小,耗能很少,可靠性很高,因而促使微型计算机以很快的速度在发展。\n\n * 20世纪80年代以来,微型计算机的类型已很多,体积越来越小,功能越来越强。\n\n * 微型计算机(microcomputer)的特点,与大、中、小型计算机的区别，就在于其中央处理器(cpu)是集中在一小块硅片上的，而大、中、小型计算机的cpu则是由相当多的电路(或集成电路)组成的。为了区别于大、中、小型计算机的cpu,而称微型计算机的 cpu芯片为微处理器( microprocessing unit或microprocesser , mpu)。\n\n微型计算机除有mpu作为中央处理器之外,还有以大规模集成电路制成的主存储器和输人输出接口电路。这三者之间是采用总线结构联系起来的。\n\n如果再配上相应的外围设备如显示器(crt)、键盘及打印机等,这就成为微型计算机系统(microcomputersystem)。实际上作为数据处理的必须是较完备的微型计算机系统。作为工业控制,尤其是小型仪器仪表或小型设备的检测控制，则可只用微型计算机、单板计算机或单片计算机，甚至是一位计算机，这样可以尽量缩小机器的体积,不过此时又得增加相应的检测通道和控制通道,如放大器和a/d或d/a转换器之类的辅助元件或电路。\n\n\n# 1.计算机系统的组成\n\n\n\n微处理器：\n\n微处理器简称cpu，是计算机的核心。\n\n主要包括：\n\n * 运算器（算术逻辑运算器alu）\n * 控制器\n * 寄存器组\n\n存储器：\n\n定义：计算机中的记忆装置。用于存放计算机工作过程中需要操作的数据和程序。\n\n存储器:\n\t- 内存储器\n\t\t+ 随机存取储存储器（ram）\n\t\t+ 只读存储器（rom）\n\t- 外存储器\n\t\t+ 联机外存---硬磁盘\n\t\t+ 脱机外存---各种移动存储设备\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n内存储器特点：\n\n * 存取速度较快，容量相对较小。\n * 内存按单元组织，每一个单元都对应一个唯一的地址。\n * 每一个存储单元中存放1byte数据。\n * 内存单元个数称为内存容量。\n\n有关存储器的属于：\n\n * 存储容量\n   * 存放的数据量。用字节表示。\n * 对存储器的操作\n   * 读（出），写（入）\n   * 读：将内存单元的内容取入cpu，原单元内容不改变；\n   * 写：cpu将信息放入内存单元，单元中原来的内容被覆盖。\n\n接口：\n\n口是cpu与外部设备间的桥梁。\n\n主要功能：\n\n * 数据缓冲寄存器；\n * 信号电平或类型的装换；\n * 实现主机与外部设间的运行匹配。\n\n总线：\n\n * 是一组导线和相关的控制、驱动电路的集合。\n * 是计算机系统个部件之间传输地址、数据和控制信息的通路\n\n总线分为：地址总线（ab）、数据总线（db）、控制总线（cb）\n\n软件系统：\n\n软件：为运行、管理和维护计算机系统或为实现某一功能而编写的各种程序的总和及其相关资料。\n\n软件：\n\t系统软件\n\t\t操作系统\n\t\t编译系统\n\t\t网络系统\n\t\t工具软件\n\t应用软件\n\t\t用户软件\n\t\t娱乐软件\n\t\t工作软件\n\t\t...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n主机系统特征\n\n * 能够与cpu直接进行信息换的部件属于主机系统\n * 不能够与cpu直接进行信息换的部件属于外部设备\n\n\n# 2. 微型计算机的一般工作过程\n\n计算机的工作就是执行程序\n\n程序是指令的序列\n\n计算机的工作就是按照一定的顺序，一条条地执行指令\n\n**指令：**由人向计算机发出的，能够被计算计所识别的命令\n\n计算机的工作是逐条执行由命令构成的程序\n\n * 程序是指令的序列\n   * 计算机的工作过程就是执行指令的过程\n\n指令的执行过程：\n\n取指令 -----\x3e 分析指令 -------\x3e 读取操作数 ------\x3e 执行指令 ------\x3e 存放结果\n\n\n1\n\n * 顺序执行：一条指令执行完了再执行下一条指令。\n   * 执行时间=取指令+分析指令+执行指令\n   * 设：三个部分执行的时间均为x，则：执行n条指令时间为y为：y=3n*x\n * 并行指令：同时执行两条或多条指令。\n   * 仅第1条指令需要3x时间，之后每经过1x，就有一条指令执行结束\n   * 执行时间：y=3x+(n-1)x\n\n----------------------------------------\n\n并行：更高的效率，更高的复杂度\n\n相对于顺序执行方式，指令并行执行的优势用加速比s表示：\n\n * s=顺序执行花费的时间/并行执行花费的时间\n\n微机系统主要技术指标\n\n常用名词术语：\n\n * 位（bit或b）：最小的信息单位，二进制的一位数。\n\n * 字节（byte或b）：是计算机的最小存储单元。\n   \n   * 1 byte = 8 bit,从00000000~11111111\n     可表示255个状态（数值）；\n     一般数字、字母、普通字符用一个字节就可表示，但汉字、特殊符号等需要两个或多个字节来表示。\n     \n     \n     1\n     2\n     3\n     \n\n * 字（word或w）：是计算机进行数据交换、加工、存储的基本运算单位、一个字由一个或若干个字节构成，通常将组成一个字的位数叫作该字的字长。\n   \n   * 字长越长，在相同时间内能传送更多的信息，从而运算速度更快；计算机有更大的寻址空间，从而内存储容量更大；计算机系统支持的指令数量越多，功能就越强。\n\n主要技术指标\n\n * 机器字长：是指计算机内部alu能够一次同时处理的二进制的位数。\n   * 字长越长，运算精度越高。通常字长都是字节（8位二进制数）的整数倍，如8位、16位、32位、64位等。\n * 主频：计算机的时钟频率，在一定程度上反映机器运算速度，主频越高，运算速度越快。主频的单位是mhz（兆赫）。\n   * 频率 = 1/周期\n * 内存容量：计算机可存储信息的多少，通常以字节为单位。一般用kb、mb、gb、tb、pb为单位。\n   * 容量越大存储的程序和数据越多，处理能力也越强。【2的10次方=1024】\n * 运算速度：运算速度的一种表示方式是mips（millions of instructions per second），即每秒百万条指令，它主要是对整数运算而言。对于浮点运算，一般使用mflops（million floating point operations per second）表示，即每秒百万次浮点运算。\n\n----------------------------------------\n\n流水线技术\n\n计算机中的流水线就是把一个重复的过程与其他子过程并行进行。\n\n即：\n\n取指令 -----》分析指令 ------》执行指令\n\t\t\t 取指令  ------》分析指令 ------》执行指令\n\t\t\t \t\t\t\t取指令  ------》分析指令 ------》执行指令\n\t\t\t \t\t\t\t\t\t\t\t.....\n\n\n1\n2\n3\n4\n\n\n从本质上讲，流水线技术就是一种时间并行技术。\n\n\n# 3. 冯·诺依曼计算机\n\n * 冯·诺依曼计算机的工作原理\n   * 存储程序工作原理\n * 结构特点\n   * 运算器为核心\n   * 程序存储、共享数据、顺序执行\n   * 属于顺序处理机，适合于确定的算法和数值数据的处理。\n * 不足：\n   * 与存储器间有大量数据交互，对总线要求很高；\n   * 执行顺序由程序决定，对大型复杂任务较困难；\n   * 以运算器为核心，处理效率较低；\n   * 由pc控制执行顺序，难以进行真正的并行处理。\n\n----------------------------------------\n\n\n# 4. 哈弗结构\n\n * 指令和数据分别存放在两个独立的存储器模块中；\n\n * cpu与存储器间指令和数据的传送分别采用两组独立的总线；\n\n * 可以在一个机器周期内同时获得指令操作码和操作数。\n\n|-----------|-----\x3e（地址信号） |---------------|\n|\t\t\t|\t\t\t\t  |   程序存储器    |\n|\t\t\t|<---- （数据信号） |---------------|\n|\tcpu \t|==================================\n|\t\t\t|------\x3e（地址信号）|---------------|\n|\t\t\t|\t\t\t\t  |   数据存储器    | \n|-----------| <-----（数据信号）|---------------|\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第六章 自定数据类型",frontmatter:{title:"第六章 自定数据类型",date:"2021-05-11T14:30:00.000Z",permalink:"/c/note6/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/50.C%E8%AF%AD%E8%A8%80/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"50.C语言/07.第六章自定数据类型.md",key:"v-334cc282",path:"/c/note6/",headers:[{level:2,title:"1. 定义和使用结构体变量",slug:"_1-定义和使用结构体变量",normalizedTitle:"1. 定义和使用结构体变量",charIndex:17},{level:2,title:"2. 使用结构体数组",slug:"_2-使用结构体数组",normalizedTitle:"2. 使用结构体数组",charIndex:3313},{level:2,title:"3. 结构体指针",slug:"_3-结构体指针",normalizedTitle:"3. 结构体指针",charIndex:3687},{level:2,title:"4. 用指针处理链表",slug:"_4-用指针处理链表",normalizedTitle:"4. 用指针处理链表",charIndex:5912},{level:2,title:"5. 共同体类型",slug:"_5-共同体类型",normalizedTitle:"5. 共同体类型",charIndex:6733},{level:2,title:"6. 使用枚举类型",slug:"_6-使用枚举类型",normalizedTitle:"6. 使用枚举类型",charIndex:8521},{level:2,title:"7. 用typedef声明新类型名",slug:"_7-用typedef声明新类型名",normalizedTitle:"7. 用typedef声明新类型名",charIndex:9887}],headersStr:"1. 定义和使用结构体变量 2. 使用结构体数组 3. 结构体指针 4. 用指针处理链表 5. 共同体类型 6. 使用枚举类型 7. 用typedef声明新类型名",content:'# 第六章 自定数据类型\n\n\n# 1. 定义和使用结构体变量\n\n由不同类型数据组成的的组合型的数据结构，它称为结构体（structre）。\n\n声明一个结构体类型的一般形式为：\n\nstruct 结构体名{\n    成员列表\n};\n\n\n1\n2\n3\n\n\nstruct是声明结构体类型时必须使用的关键字，不能省略。\n\n注意：结构体类型的名字是由一个关键字struct和结构体名组成的。结构体名是由用户指定的，又称“结构体标记”（structure tag），以区别于其他结构体类型。上面的结构体声明中Student 就是结构体名（结构体标记）。\n\n花括号内是该结构体所包括的子项，称为结构体的成员（member）。对各成员都应进行类型声明，即：\n\n类型名 成员名;\n\n\n1\n\n\n“成员表列”（member list）也称为“域表”（field list），每一个成员是结构体中的一个域。成员名命名规则与变量名相同。\n\n说明：\n\n(1)结构体类型并非只有一种，而是可以设计出许多种结构体类型，还可以根据需要建立结构体类型，各自包含不同的成员。\n\n(2)成员可以属于另一个结构体类型。\n\n例如：\n\nstruct Date\t\t\t\t\t//声明一个结构体类型struct Date\n{ \n    int month;\t\t\t\t//月\n    int day;\t\t\t\t//日\n    int year;\t\t\t\t//年\n};\nstruct Student\t\t\t\t//声明一个结构体类型struct Student\n{ \n    int num;\n    char name[20]; \n    char sex;\n    int age;\n    struct Date birthday; \t//成员birthday属于struct Date类型\n    char addr[30];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n定义结构体类型变量\n\n 1. 先声明结构体类型，再定义该类型的变量\n\n上面已声明了一个结构体类型struct Student，可以用它来定义变量。例如:\n\nstruct Student student1,student2;\n-------------  -------- --------\n    |\t\t\t\t|\t\t|\n结构体类型名\t\t    结构体变量名\n\n\n1\n2\n3\n4\n\n\n这种方式是声明类型和定义变量分离，在声明类型后可以随时定义变量，比较灵活。\n\n 2. 在声明类型的同时定义变量\n\n例如：\n\nstruct Student\n{ \n    int num;\n    char name[20];\n    char sex;\n    int age;\n    float score;\n    char addr[30];\n}studentl,student2;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n它的作用与第一种方法相同，但是在定义struct Student 类型的同时定义两个struct Student类型的变量studentl 和student2。\n\n这种定义方法的一般形式为：\n\nstruct 结构体名{\n    成员列表\n}变量名表列;\n\n\n1\n2\n3\n\n\n声明类型和定义变量放在一起进行，能直接看到结构体的结构，比较直观，在写小程序时用此方式比较方便,但写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以使程序结构清晰，便于维护，所以一般不多用这种方式。\n\n 3. 不指定类型名而直接定义结构体类型变量\n\n其一般形式为：\n\nstruct{\n    成员表列\n}变量名表列;\n\n\n1\n2\n3\n\n\n指定了一个无名的结构体类型,它没有名字（不出现结构体名）。显然不能再以此结构体类型去定义其他变量。这种方式用得不多。\n\n说明：\n\n(1)结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的,只对变量分配空间。\n\n(2)结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。 例如，程序中可以另定义一个变量num，它与struct Student中的num是两回事，互不干扰。\n\n(3)对结构体变量中的成员（即“域”），可以单独使用，它的作用与地位相当于普通变量。关于对成员的引用方法见下节。\n\n结构体变量的初始化和引用\n\n在定义结构体变量时,可以对它初始化.即赋予初始值。然后可以引用这个变量，例如输出它的成员的值。\n\n(1)在定义结构体变量时可以对它的成员初始化。初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。\n\n注意：是对结构体变量初始化，而不是对结构体类型初始化。\n\nC99标准允许对某一成员初始化，如:\n\nstruct Student b= {.name=\' "Zhang Fang \'};//在成员名前有成员运算符"."\n\n\n1\n\n\n“. name”隐含代表结构体变量b中的成员b.name。其他未被指定初始化的数值型成员被系统初始化为0，字符型成员被系统初始化为\'\\0\'，指针型成员被系统初始化为NULL。\n\n(2)可以引用结构体变量中成员的值，引用方式为：\n\n结构体变量名.成员名\n\n\n1\n\n\n“.”是成员运算符,它在所有的运算符中优先级最高，因此可以把b.name作为一个整体来看待，相当于一个变量。\n\n注意：不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值。\n\n下面用法不正确：\n\nprintf("%s\\n",b);//企图用结构体变量名输出所有成员的值\n\n\n1\n\n\n只能对结构体变量中的各个成员分别进行输人和输出。\n\n(3)如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。如果在结构体struct Student类型的成员中包含另一个结构体struct date类型的成员birthday(为一个结构体) ,则引用成员的方式为：\n\nstudentl.num\t\t\t//(结构体变量studentl中的成员num)\nstudentl.birthday.month //(结构体变量studentl中的成员birthday中的成员month)\n\n\n1\n2\n\n\n不能用student1. birthday来访问student1 变量中的成员birthday, 因为birthday 本身是一个结构体成员。\n\n(4)对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。\n\n例如:\n\nstudent2.score = studentl.score;\t\t //(赋值运算)\nsum = student1.score+student2.score;\t //(加法运算) \nstudentl.age++;\t\t\t\t\t\t\t //(自加运算)\n\n\n1\n2\n3\n\n\n由于“.”运算符的优先级最高，因此studentl.age++是对(student1.age)进行自加运算，而不是先对age进行自加运算。\n\n(5)同类的结构体变量可以互相赋值，如：\n\nstudentl = student2;//假设student1和student2已定义为同类型的结构体变量\n\n\n1\n\n\n(6)可以引用结构体变量成员的地址，也可以引用结构体变量的地址。\n\n例如:\n\nscanf("%d",&student1.num); //(输人studentl. num的值)\nprintf("%o",&student1);    //(输出结构体变量studentl的起始地址)\n\n\n1\n2\n\n\n但不能用以下语句整体读人结构体变量，例如：\n\nscanf("%d,%s,%c,%d,%f,%s\\n",&.studentl); \n\n\n1\n\n\n说明：结构体变量的地址主要用作函数参数，传递结构体变量的地址。\n\n\n# 2. 使用结构体数组\n\n(1)定义结构体数组一般形式是：\n\nstruct结构体名{\n    成员表列\n}数组名[数组长度];\n\n\n1\n2\n3\n\n\n先声明一个结构体类型(如struct Person)，然后再用此类型定义结构体数组:\n\n结构体类型 数组名[数组长度];\n\nstruct Person{\n    char name[20];\n    int age;\n};\n\nstruct Person leader[3]; //leader是结构体数组名\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n(2)对结构体数组初始化的形式是在定义数组的后面加上：\n\n结构体类型 数组名[数组长度]= {初值表列};\n\n\n1\n\n\n如：\n\nstruct Person leader[3]= {"Li",0,"Zhang",0,"Sun",0}; \n\n\n1\n\n\n\n# 3. 结构体指针\n\n指向结构体变量的指针\n\n指向结构体对象的指针变量既可指向结构体变量，也可指向结构体数组中的元素。指针变量的基类型必须与结构体变量的类型相同。\n\n例如:\n\nstruct Student* pt;\t\t//pt可以指向structStudent类型的变量或数组元素\n\n\n1\n\n\n说明：为了使用方便和直观，C语言允许把(*p).num用p->num代替，“->”代表 一个箭头，p->num表示p所指向的结构体变量中的num成员。同样，(*p).name等价于p->name。“->”称为指向运算符。\n\n如果p指向一个结构体变量stu,以下3种用法等价：\n\n①stu.成员名 (如stu. num);\n\n②(*p).成员名 (如(*p).num);\n\n③p->成员名 (如p->num)。\n\n指向结构体数组的指针\n\n可以用指针变量指向结构体数组的元素。\n\n例如：有3个学生的信息，放在结构体变量中，要求输出全部学生的信息。\n\n(1)声明结构体类型 struct Student，并定义结构体数组，同时初始化；\n\n(2)定义一个指向struct Student 类型数据的指针变量p;\n\n(3)使P指向结构体数组的首元素，输出它指向的元素中的有关信息;\n\n(4)使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息;\n\n(5)再使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息。\n\n编写程序:\n\n#include<stdio.h>\nstruct Student{\t\t//声明结构体类型structStudent\n    int num;\n    char name[20];\n    char sex;\n    int age;\n};\nstruct Student stu[3]={{10101,"Li Lin",\'M\',18},{10102,"Zhang Fang",\'M\',19},{10104,"Wang Min",\'F\',20}}; //定 义结构体数组并初始化\nint main(){\n    struct Student* p;//定义指向structStudent结构体变量的指针变量\n    printf(" No. Name           sex age\\n");\n    for (p= stu;p<stu+3;p++){\n        printf(" %5d %-20s %2c %4d\\n",p->num,p->name,p->sex,p->age);//输出结果\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n\n注意：\n\n(1)如果p的初值为stu,即指向stu的序号为0的元素，p加1后，就指向下一个元素。\n\n例如：\n\n(++p)->num\t//先使p自加1，然后得到p指向的元素中的num成员值(10102) \n(p++)->num\t//先求得p->num的值(即10101)，然后再使p自加1，指向stu[1]\n\n\n1\n2\n\n\n请注意以上二者的不同。\n\n(2)程序定义了p是一个指向struct Student类型对象的指针变量,它用来指向一个 struct Student类型的对象(p的值是stu数组的一个元素(如stu[0]或stu[1])的起始地址),不应用来指向stu数组元素中的某一成员。\n\n例如，下面的用法是不对的:\n\np= stu[1].name; //stu[1].name是stu[1]元素中的成员name 的首字符的地址\n\n\n1\n\n\n编译时将给出“警告”信息，表示地址的类型不匹配。不要认为反正p是存放地址的，可以将任何地址赋给它。如果一定要将某一成员的地址赋给p，可以用强制类型转换，先将成员的地址转换成p的类型。例如:\n\np= (struct Student * )stu[0].name;\n\n\n1\n\n\n此时，p的值是stu[0]元素的name成员的起始地址。可以用“printf("%s",p);"输出 stu[0]中成员name的值。但是,p仍保持原来的类型。如果执行“printf("%s\',p+1);,则 会输出stu[1]中name 的值。执行p++时,p的值的增量是结构体struct Student的长度。\n\n用结构体变量和结构体变量的指针作函数参数\n\n将一个结构体变量的值传递给另一个函数，有3个方法:\n\n(1)用结构体变量的成员作参数。例如,用stu[1]. num或stu[2].name作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于“值传递”方式。应当注意实参与形参的类型保持一致。\n\n(2)用结构体变量作实参。用结构体变量作实参时,采取的也是“值传递”的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参(也是结构体变量)的值,该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。\n\n(3)用指向结构体变量(或数组元素)的指针作实参，将结构体变量(或数组元素)的地址传给形参。\n\n\n# 4. 用指针处理链表\n\n什么是链表？\n\n链表是动态地进行存储分配的一种结构。 作用是为了避免内存的浪费，它是根据需要开辟内存单元设定的。\n\n单向链表 由 head 的 next 指向下个节点 头指针：head （整个链表都必须包含head） 结点 ：必须包含两部分（1）用户需要用的实际数据 （2）下一个节点的地址 空指针（表尾）：NULL\n\n建立链表（利用结构体）\n\nstruct Student\n{\tint num;\n\tfloat score;\n\tstruct Student *next; //next是指针变量，指向下一个结构体的地址\n};\n\n\n1\n2\n3\n4\n5\n\n\n输出链表\n\nvoid output(struct student *head)  // 定义一个链表输出的函数\n{\n    struct student *p;  // 定义结构体指针变量p1，用于结点的后移，以实现输出操作\n    p = head;  // 将head赋给p1，以实现对该链表的操作\n    if (p != NULL) // 建立一个while循环，结束条件是到达尾结点\n    do\n    {\n        printf("%d\\n%f\\n", p1->num, p1->score);  // 输出结点中的数值部分\n        p1 = p1->next;  // 将下一个结点的位置赋给p1\n    }while(p != NULL);//当p不是空地址时循环\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意： malloc()分配内存后最后记得free()释放内存。\n\n可以参看以下博客学习：\n\nhttps://blog.csdn.net/linwh8/article/details/49648601\n\n----------------------------------------\n\n\n# 5. 共同体类型\n\n使几个不同的变量公享同一段内存的结构，称为"共同体"类型结构。\n\n定义共同体类型变量的的一般形式为：\n\nunion 共用体名{\n    成员列表\n}变量列表;\n\n\n1\n2\n3\n\n\n例如：\n\nunion Data{\t\t//表示不同类型的变量i,ch,f可以存放到同一段存储单元中\n    int t;\n    char ch;\n    float f;\n}a,b,c;\t\t\t//在声明类型同时定义变量\n\n\n1\n2\n3\n4\n5\n\n\n也可以将类型声明与变量定义分开：\n\nunion Data{ \t\t//声明共用体类型\n    int I;\n    char ch;\n    float f;\n};\nunion Data a,b,c;\t//用共用体类型定义变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n即先声明一个union Data类型，再将a,b,c定义为union Data类型的变量。\n\n当然也可以直接定义共用体变量，例如:\n\nunion{ \t\t\t//没有定义共用体类型名\n\tint i;\n    char ch;\n    float f;\n}a,b,c;\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，“共用体” 与 “结构体” 的定义形式相似。但它们的含义是不同的。\n\n结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。例如，上面定义的“共用 体”变量a，b，c各占4个字节（因为一个float 型变量占4个字节），而不是各占4+1+4=9个字节。\n\n引用共用体变量的方式\n\n只有先定义了共同体变量才能引用它，但应注意，不能引用共同变量，而只能引用共同体变量中的成员。\n\n例如：【上面定义的a,b,c共用体】\n\na.i\t\t//引用共同体变量中的整型变量i\na.ch\t//引用共同体变量中的整型变量i\na.f\t\t//引用共同体变量中的整型变量i\n\n//不能只引用共同体变量,下面的引用就是错误的\nprintf("%d",a);\n\n//正确的写法为\nprintf("%d",a.i);\nprintf("%c",a.ch);\nprintf("%f",a.f);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n共用体类型数据的特点\n\n在使用共用体型数据时要主要以下特点：\n\n * 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。\n * 可以对共用体变量初始化，但初始化表中只能有一个常量。\n   * 以下用法为错误的：\n\nunion Data{\n    int i;\n    char ch;\n    float f;\n}a={1,\'a\',1.5};\t\t\t//不能初始化3个成员变量，它们占用同一段存储单元\nunion Data a={16};\t\t//正确，对第1个成员初始化\nunion Data a={.ch=\'j\'};\t//C99允许对指定的一个成员初始化\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值之后，原变量存储单元中的值就被取代了。\n * 共同体变量的地址和它的各成员的地址都是同一地址。\n   * 例如：\n\n&a.i,&a.ch,&a.f \t\t//都是同一地址\n\n\n1\n\n * 不能对共同变量名赋值，也不能企图引用变量名来得到一个值。\n   * 例如，下面这些都是不对的：\n\ni = 1;\t//不能对共同体变量赋值，赋给谁？\nm = a;\t//企图引用共同体变量名以得到一个值赋给整型变量m\n**************************************\n//C99允许同类型的共同体变量相互赋值。\nb = a;\t//a和b是同类型的共同变量，合法\n\n\n1\n2\n3\n4\n5\n\n * 以前的C规定不能把共同体变量作为函数参数，但是可以使用指向共同体变量的指针作函数参数。C99允许用共同体变量作为函数参数。\n * 共同体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型中，数组也可以作为共用体的成员。\n\n\n# 6. 使用枚举类型\n\n如果一个变量只有几种可能的值，则可以定义为枚举（enumeration）类型，所谓 “枚举” 就是指把可能的值一一列举出来，变量的值只限制于列举出来的值的范围内。\n\n例如:\n\nenum Weekday{sun,mon,tue,wed,thu,fri,sat};\n\n\n1\n\n\n以上声明了一个枚举类型enum Weekday然后可以用此类型来定义变量。\n\n例如:\n\nenum Weekday workday,weekend; \n-----------   --------------\n    |\t\t\t\t|\n 枚举类型\t\t  枚举变量\n\n\n1\n2\n3\n4\n\n\nworkday和weekend被定义为枚举变量,花括号中的sun,mon,..，sat称为枚举元素或枚举常量。它们是用户指定的名字。枚举变量和其他数值型量不同,它们的值只限于花括号中指定的值之一。例如枚举变量workday和weekend的值只能是sun到sat之一。\n\nworkday= mon; //正确,mon是指定的枚举常量之一\n\nweekend= sun;//正确,sun是指定的枚举常量之一\n\nweekday = monday;//不正确,monday不是指定的枚举常量之一\n\n\n1\n2\n3\n4\n5\n\n\n枚举常量是由程序设计者命名的,用什么名字代表什么含义,完全由程序员根据自己的需要而定,并在程序中作相应处理。\n\n也可以不声明有名字的枚举类型,而直接定义枚举变量,例如:\n\nenum{sun,mon,tue,wed,thu,fri,sat} workday,weekend;\n\n\n1\n\n\n声明枚举类型用 enum 开头。\n\n声明枚举类型的一般形式为：\n\nenum [枚举名]{枚举元素……};\n\n\n1\n\n\n说明:\n\n(1) C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符（有名字）而把它们看作变量，不能对它们赋值。\n\n(2) 每一个枚举元素都代表一个整数,C语言编译按定义时的顺序默认它们的值为0,1,2,3,4,5...。在上面的定义中,sun的值自动设为0,mon的值为1,.,sat的值为6。如果有赋值语句:\n\nworkday= mon;//相当于\nworkday= 1;//枚举常量是可以引用和输出的。例如:\nprintf("%d",workday);//将输出整數1。\n\n\n1\n2\n3\n\n\n也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：\n\nenum Weekday{sun=7,mon=1,tue,wed,thu,fri,sat} workday,week_end;\n\n\n1\n\n\n指定枚举常量sun的值为7,mon为1,以后顺序加1,sat为6。\n\n由于枚举型变量的值是整数，因此C99把枚举类型也作为整型数据中的一种，即用户自行定义的整数类型。\n\n(3)枚举元素可以用来作判断比较。例如:\n\nif( workday= = mon).. \nif( workday> sun)... \n\n\n1\n2\n\n\n枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。如果定义时未人为 指定，则按上面的默认规则处理，即第1个枚举元素的值为0，故mon > sun，sat > fri。\n\n\n# 7. 用typedef声明新类型名\n\n用typedef指定新的类型名来代替已有的类型名。\n\n有以下两种情况：\n\n 1. 简单地用一个新的类型名代替原有的类型名\n\n例如：\n\ntypedef int Integer;\t//指定用Integer为类型名,作用与int相同\ntypedef float Real;\t\t//指定用Real为类型名,作用与float相同\n\n\n1\n2\n\n\n指定用Integer代表int类型,Real代表float。 这样，以下两行等价：\n\n①int i,j;\nfloat a,b;\n\n②Integer i,j;\nReal a,b;\n\n\n1\n2\n3\n4\n5\n\n 2. 命名一个简单的类型名代替复杂的类型表示方法\n\n从前面已知，除了简单的类型（如int，float等）、C程序中还会用到许多看起来比较复杂的类型，包括结构体类型、共用体类型枚举类型、指针类型、数组类型等，如：\n\nfloat*[](指针数组)\nfloat( * )[5](指向5个元素的-维数组的指针)\ndouble * (double * )(定义函数，函数的參数是double*型数据,即指向double数据的指针,函数返回值也是指向double数据的指针)\ndouble( * )()(指向函数的指针，函数返回值类型为double)\nint * ( * ( * )[10])(void)(指向包含10个元素的一维数组的指针,数组元素的类型为函数指针(函数的地址)，函数没有参数，函数返回值是int 指针)\n\n\n1\n2\n3\n4\n5\n\n\n有些类型形式复杂，难以理解，容易写错。C允许程序设计者用一个简单的名字代替复杂的类型形式。\n\n例如：\n\n(1)命名一个新的类型名代表结构体类型:\n\ntypedef struct int month;\nint year;\n} Date;\n\n\n1\n2\n3\n\n\n以上声明了一个新类型名Date，代表上面的一个结构体类型。然后可以用新的类型名Date去定义变量，如：\n\nDate birthday;\t//定义结构体类型变量birthday ,不要写成struct Date birthday;\nDate* P;\t\t//定义结构体指针变量p.指向此结构体类型数据\n\n\n1\n2\n\n\n(2)命名一个新的类型名代表数组类型：\n\ntypedef int Num[ 100];\t//声明Num为整型数组类型名\nNuma;\t\t\t\t\t//定义a为整型数组名,它有100个元素\n\n\n1\n2\n\n\n(3)命名一个新的类型名代表指针类型：\n\ntypedef char * String;\t//声明String为字符指针类型\nString p,s[10]; \t\t//定义p为字符指针变量,s为字符指针数组\n\n\n1\n2\n\n\n(4)命名一个新的类型名代表指向函数的指针类型：\n\ntypedefint(*Pointer)();\t//声明Pointer为指向函数的指针类型,该函数返回整型值\nPointer pl,p2;\t\t\t//p1,p2为Pointer类型的指针变量\n\n\n1\n2\n\n\n归纳起来，声明一个新的类型名的方法是：\n\n①先按定义变量的方法写出定义体(如:int i;)。\n②将变量名换成新类型名(例如:将i换成Count)。\n③在最前面加typedef(例如:typedef int Count)。\n④然后可以用新类型名去定义变量。\n\n\n1\n2\n3\n4\n\n\n简单地说，就是按定义变量的方式，把变量名换上新类型名，并且在最前面加typedef，就声明了新类型名代表原来的类型。\n\n以定义上述的数组类型为例来说明：\n\n①先按定义数组变量形式书泻: int a[100]。\n②将变量名a换成自己命名的类型名:int Num[100]。\n③在前面加上typedef,得到typedef int Num[100]。\n④用来定义变量:Num a;\n相当于定义了:int a[100];\n同样,对字符指针类型,也是:\n①char * p; \t\t\t\t//定义变量p的方式\n②char * String;\t\t\t//用新类型名String 取代变量名p\n③typedef char * String;\t//加typedef\n④String p;\t\t\t\t//用新类型名String定义变量,相当char*p;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别。',normalizedContent:'# 第六章 自定数据类型\n\n\n# 1. 定义和使用结构体变量\n\n由不同类型数据组成的的组合型的数据结构，它称为结构体（structre）。\n\n声明一个结构体类型的一般形式为：\n\nstruct 结构体名{\n    成员列表\n};\n\n\n1\n2\n3\n\n\nstruct是声明结构体类型时必须使用的关键字，不能省略。\n\n注意：结构体类型的名字是由一个关键字struct和结构体名组成的。结构体名是由用户指定的，又称“结构体标记”（structure tag），以区别于其他结构体类型。上面的结构体声明中student 就是结构体名（结构体标记）。\n\n花括号内是该结构体所包括的子项，称为结构体的成员（member）。对各成员都应进行类型声明，即：\n\n类型名 成员名;\n\n\n1\n\n\n“成员表列”（member list）也称为“域表”（field list），每一个成员是结构体中的一个域。成员名命名规则与变量名相同。\n\n说明：\n\n(1)结构体类型并非只有一种，而是可以设计出许多种结构体类型，还可以根据需要建立结构体类型，各自包含不同的成员。\n\n(2)成员可以属于另一个结构体类型。\n\n例如：\n\nstruct date\t\t\t\t\t//声明一个结构体类型struct date\n{ \n    int month;\t\t\t\t//月\n    int day;\t\t\t\t//日\n    int year;\t\t\t\t//年\n};\nstruct student\t\t\t\t//声明一个结构体类型struct student\n{ \n    int num;\n    char name[20]; \n    char sex;\n    int age;\n    struct date birthday; \t//成员birthday属于struct date类型\n    char addr[30];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n定义结构体类型变量\n\n 1. 先声明结构体类型，再定义该类型的变量\n\n上面已声明了一个结构体类型struct student，可以用它来定义变量。例如:\n\nstruct student student1,student2;\n-------------  -------- --------\n    |\t\t\t\t|\t\t|\n结构体类型名\t\t    结构体变量名\n\n\n1\n2\n3\n4\n\n\n这种方式是声明类型和定义变量分离，在声明类型后可以随时定义变量，比较灵活。\n\n 2. 在声明类型的同时定义变量\n\n例如：\n\nstruct student\n{ \n    int num;\n    char name[20];\n    char sex;\n    int age;\n    float score;\n    char addr[30];\n}studentl,student2;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n它的作用与第一种方法相同，但是在定义struct student 类型的同时定义两个struct student类型的变量studentl 和student2。\n\n这种定义方法的一般形式为：\n\nstruct 结构体名{\n    成员列表\n}变量名表列;\n\n\n1\n2\n3\n\n\n声明类型和定义变量放在一起进行，能直接看到结构体的结构，比较直观，在写小程序时用此方式比较方便,但写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以使程序结构清晰，便于维护，所以一般不多用这种方式。\n\n 3. 不指定类型名而直接定义结构体类型变量\n\n其一般形式为：\n\nstruct{\n    成员表列\n}变量名表列;\n\n\n1\n2\n3\n\n\n指定了一个无名的结构体类型,它没有名字（不出现结构体名）。显然不能再以此结构体类型去定义其他变量。这种方式用得不多。\n\n说明：\n\n(1)结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的,只对变量分配空间。\n\n(2)结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。 例如，程序中可以另定义一个变量num，它与struct student中的num是两回事，互不干扰。\n\n(3)对结构体变量中的成员（即“域”），可以单独使用，它的作用与地位相当于普通变量。关于对成员的引用方法见下节。\n\n结构体变量的初始化和引用\n\n在定义结构体变量时,可以对它初始化.即赋予初始值。然后可以引用这个变量，例如输出它的成员的值。\n\n(1)在定义结构体变量时可以对它的成员初始化。初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。\n\n注意：是对结构体变量初始化，而不是对结构体类型初始化。\n\nc99标准允许对某一成员初始化，如:\n\nstruct student b= {.name=\' "zhang fang \'};//在成员名前有成员运算符"."\n\n\n1\n\n\n“. name”隐含代表结构体变量b中的成员b.name。其他未被指定初始化的数值型成员被系统初始化为0，字符型成员被系统初始化为\'\\0\'，指针型成员被系统初始化为null。\n\n(2)可以引用结构体变量中成员的值，引用方式为：\n\n结构体变量名.成员名\n\n\n1\n\n\n“.”是成员运算符,它在所有的运算符中优先级最高，因此可以把b.name作为一个整体来看待，相当于一个变量。\n\n注意：不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值。\n\n下面用法不正确：\n\nprintf("%s\\n",b);//企图用结构体变量名输出所有成员的值\n\n\n1\n\n\n只能对结构体变量中的各个成员分别进行输人和输出。\n\n(3)如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。如果在结构体struct student类型的成员中包含另一个结构体struct date类型的成员birthday(为一个结构体) ,则引用成员的方式为：\n\nstudentl.num\t\t\t//(结构体变量studentl中的成员num)\nstudentl.birthday.month //(结构体变量studentl中的成员birthday中的成员month)\n\n\n1\n2\n\n\n不能用student1. birthday来访问student1 变量中的成员birthday, 因为birthday 本身是一个结构体成员。\n\n(4)对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。\n\n例如:\n\nstudent2.score = studentl.score;\t\t //(赋值运算)\nsum = student1.score+student2.score;\t //(加法运算) \nstudentl.age++;\t\t\t\t\t\t\t //(自加运算)\n\n\n1\n2\n3\n\n\n由于“.”运算符的优先级最高，因此studentl.age++是对(student1.age)进行自加运算，而不是先对age进行自加运算。\n\n(5)同类的结构体变量可以互相赋值，如：\n\nstudentl = student2;//假设student1和student2已定义为同类型的结构体变量\n\n\n1\n\n\n(6)可以引用结构体变量成员的地址，也可以引用结构体变量的地址。\n\n例如:\n\nscanf("%d",&student1.num); //(输人studentl. num的值)\nprintf("%o",&student1);    //(输出结构体变量studentl的起始地址)\n\n\n1\n2\n\n\n但不能用以下语句整体读人结构体变量，例如：\n\nscanf("%d,%s,%c,%d,%f,%s\\n",&.studentl); \n\n\n1\n\n\n说明：结构体变量的地址主要用作函数参数，传递结构体变量的地址。\n\n\n# 2. 使用结构体数组\n\n(1)定义结构体数组一般形式是：\n\nstruct结构体名{\n    成员表列\n}数组名[数组长度];\n\n\n1\n2\n3\n\n\n先声明一个结构体类型(如struct person)，然后再用此类型定义结构体数组:\n\n结构体类型 数组名[数组长度];\n\nstruct person{\n    char name[20];\n    int age;\n};\n\nstruct person leader[3]; //leader是结构体数组名\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n(2)对结构体数组初始化的形式是在定义数组的后面加上：\n\n结构体类型 数组名[数组长度]= {初值表列};\n\n\n1\n\n\n如：\n\nstruct person leader[3]= {"li",0,"zhang",0,"sun",0}; \n\n\n1\n\n\n\n# 3. 结构体指针\n\n指向结构体变量的指针\n\n指向结构体对象的指针变量既可指向结构体变量，也可指向结构体数组中的元素。指针变量的基类型必须与结构体变量的类型相同。\n\n例如:\n\nstruct student* pt;\t\t//pt可以指向structstudent类型的变量或数组元素\n\n\n1\n\n\n说明：为了使用方便和直观，c语言允许把(*p).num用p->num代替，“->”代表 一个箭头，p->num表示p所指向的结构体变量中的num成员。同样，(*p).name等价于p->name。“->”称为指向运算符。\n\n如果p指向一个结构体变量stu,以下3种用法等价：\n\n①stu.成员名 (如stu. num);\n\n②(*p).成员名 (如(*p).num);\n\n③p->成员名 (如p->num)。\n\n指向结构体数组的指针\n\n可以用指针变量指向结构体数组的元素。\n\n例如：有3个学生的信息，放在结构体变量中，要求输出全部学生的信息。\n\n(1)声明结构体类型 struct student，并定义结构体数组，同时初始化；\n\n(2)定义一个指向struct student 类型数据的指针变量p;\n\n(3)使p指向结构体数组的首元素，输出它指向的元素中的有关信息;\n\n(4)使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息;\n\n(5)再使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息。\n\n编写程序:\n\n#include<stdio.h>\nstruct student{\t\t//声明结构体类型structstudent\n    int num;\n    char name[20];\n    char sex;\n    int age;\n};\nstruct student stu[3]={{10101,"li lin",\'m\',18},{10102,"zhang fang",\'m\',19},{10104,"wang min",\'f\',20}}; //定 义结构体数组并初始化\nint main(){\n    struct student* p;//定义指向structstudent结构体变量的指针变量\n    printf(" no. name           sex age\\n");\n    for (p= stu;p<stu+3;p++){\n        printf(" %5d %-20s %2c %4d\\n",p->num,p->name,p->sex,p->age);//输出结果\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n\n注意：\n\n(1)如果p的初值为stu,即指向stu的序号为0的元素，p加1后，就指向下一个元素。\n\n例如：\n\n(++p)->num\t//先使p自加1，然后得到p指向的元素中的num成员值(10102) \n(p++)->num\t//先求得p->num的值(即10101)，然后再使p自加1，指向stu[1]\n\n\n1\n2\n\n\n请注意以上二者的不同。\n\n(2)程序定义了p是一个指向struct student类型对象的指针变量,它用来指向一个 struct student类型的对象(p的值是stu数组的一个元素(如stu[0]或stu[1])的起始地址),不应用来指向stu数组元素中的某一成员。\n\n例如，下面的用法是不对的:\n\np= stu[1].name; //stu[1].name是stu[1]元素中的成员name 的首字符的地址\n\n\n1\n\n\n编译时将给出“警告”信息，表示地址的类型不匹配。不要认为反正p是存放地址的，可以将任何地址赋给它。如果一定要将某一成员的地址赋给p，可以用强制类型转换，先将成员的地址转换成p的类型。例如:\n\np= (struct student * )stu[0].name;\n\n\n1\n\n\n此时，p的值是stu[0]元素的name成员的起始地址。可以用“printf("%s",p);"输出 stu[0]中成员name的值。但是,p仍保持原来的类型。如果执行“printf("%s\',p+1);,则 会输出stu[1]中name 的值。执行p++时,p的值的增量是结构体struct student的长度。\n\n用结构体变量和结构体变量的指针作函数参数\n\n将一个结构体变量的值传递给另一个函数，有3个方法:\n\n(1)用结构体变量的成员作参数。例如,用stu[1]. num或stu[2].name作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于“值传递”方式。应当注意实参与形参的类型保持一致。\n\n(2)用结构体变量作实参。用结构体变量作实参时,采取的也是“值传递”的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参(也是结构体变量)的值,该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。\n\n(3)用指向结构体变量(或数组元素)的指针作实参，将结构体变量(或数组元素)的地址传给形参。\n\n\n# 4. 用指针处理链表\n\n什么是链表？\n\n链表是动态地进行存储分配的一种结构。 作用是为了避免内存的浪费，它是根据需要开辟内存单元设定的。\n\n单向链表 由 head 的 next 指向下个节点 头指针：head （整个链表都必须包含head） 结点 ：必须包含两部分（1）用户需要用的实际数据 （2）下一个节点的地址 空指针（表尾）：null\n\n建立链表（利用结构体）\n\nstruct student\n{\tint num;\n\tfloat score;\n\tstruct student *next; //next是指针变量，指向下一个结构体的地址\n};\n\n\n1\n2\n3\n4\n5\n\n\n输出链表\n\nvoid output(struct student *head)  // 定义一个链表输出的函数\n{\n    struct student *p;  // 定义结构体指针变量p1，用于结点的后移，以实现输出操作\n    p = head;  // 将head赋给p1，以实现对该链表的操作\n    if (p != null) // 建立一个while循环，结束条件是到达尾结点\n    do\n    {\n        printf("%d\\n%f\\n", p1->num, p1->score);  // 输出结点中的数值部分\n        p1 = p1->next;  // 将下一个结点的位置赋给p1\n    }while(p != null);//当p不是空地址时循环\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意： malloc()分配内存后最后记得free()释放内存。\n\n可以参看以下博客学习：\n\nhttps://blog.csdn.net/linwh8/article/details/49648601\n\n----------------------------------------\n\n\n# 5. 共同体类型\n\n使几个不同的变量公享同一段内存的结构，称为"共同体"类型结构。\n\n定义共同体类型变量的的一般形式为：\n\nunion 共用体名{\n    成员列表\n}变量列表;\n\n\n1\n2\n3\n\n\n例如：\n\nunion data{\t\t//表示不同类型的变量i,ch,f可以存放到同一段存储单元中\n    int t;\n    char ch;\n    float f;\n}a,b,c;\t\t\t//在声明类型同时定义变量\n\n\n1\n2\n3\n4\n5\n\n\n也可以将类型声明与变量定义分开：\n\nunion data{ \t\t//声明共用体类型\n    int i;\n    char ch;\n    float f;\n};\nunion data a,b,c;\t//用共用体类型定义变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n即先声明一个union data类型，再将a,b,c定义为union data类型的变量。\n\n当然也可以直接定义共用体变量，例如:\n\nunion{ \t\t\t//没有定义共用体类型名\n\tint i;\n    char ch;\n    float f;\n}a,b,c;\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，“共用体” 与 “结构体” 的定义形式相似。但它们的含义是不同的。\n\n结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。例如，上面定义的“共用 体”变量a，b，c各占4个字节（因为一个float 型变量占4个字节），而不是各占4+1+4=9个字节。\n\n引用共用体变量的方式\n\n只有先定义了共同体变量才能引用它，但应注意，不能引用共同变量，而只能引用共同体变量中的成员。\n\n例如：【上面定义的a,b,c共用体】\n\na.i\t\t//引用共同体变量中的整型变量i\na.ch\t//引用共同体变量中的整型变量i\na.f\t\t//引用共同体变量中的整型变量i\n\n//不能只引用共同体变量,下面的引用就是错误的\nprintf("%d",a);\n\n//正确的写法为\nprintf("%d",a.i);\nprintf("%c",a.ch);\nprintf("%f",a.f);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n共用体类型数据的特点\n\n在使用共用体型数据时要主要以下特点：\n\n * 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。\n * 可以对共用体变量初始化，但初始化表中只能有一个常量。\n   * 以下用法为错误的：\n\nunion data{\n    int i;\n    char ch;\n    float f;\n}a={1,\'a\',1.5};\t\t\t//不能初始化3个成员变量，它们占用同一段存储单元\nunion data a={16};\t\t//正确，对第1个成员初始化\nunion data a={.ch=\'j\'};\t//c99允许对指定的一个成员初始化\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值之后，原变量存储单元中的值就被取代了。\n * 共同体变量的地址和它的各成员的地址都是同一地址。\n   * 例如：\n\n&a.i,&a.ch,&a.f \t\t//都是同一地址\n\n\n1\n\n * 不能对共同变量名赋值，也不能企图引用变量名来得到一个值。\n   * 例如，下面这些都是不对的：\n\ni = 1;\t//不能对共同体变量赋值，赋给谁？\nm = a;\t//企图引用共同体变量名以得到一个值赋给整型变量m\n**************************************\n//c99允许同类型的共同体变量相互赋值。\nb = a;\t//a和b是同类型的共同变量，合法\n\n\n1\n2\n3\n4\n5\n\n * 以前的c规定不能把共同体变量作为函数参数，但是可以使用指向共同体变量的指针作函数参数。c99允许用共同体变量作为函数参数。\n * 共同体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型中，数组也可以作为共用体的成员。\n\n\n# 6. 使用枚举类型\n\n如果一个变量只有几种可能的值，则可以定义为枚举（enumeration）类型，所谓 “枚举” 就是指把可能的值一一列举出来，变量的值只限制于列举出来的值的范围内。\n\n例如:\n\nenum weekday{sun,mon,tue,wed,thu,fri,sat};\n\n\n1\n\n\n以上声明了一个枚举类型enum weekday然后可以用此类型来定义变量。\n\n例如:\n\nenum weekday workday,weekend; \n-----------   --------------\n    |\t\t\t\t|\n 枚举类型\t\t  枚举变量\n\n\n1\n2\n3\n4\n\n\nworkday和weekend被定义为枚举变量,花括号中的sun,mon,..，sat称为枚举元素或枚举常量。它们是用户指定的名字。枚举变量和其他数值型量不同,它们的值只限于花括号中指定的值之一。例如枚举变量workday和weekend的值只能是sun到sat之一。\n\nworkday= mon; //正确,mon是指定的枚举常量之一\n\nweekend= sun;//正确,sun是指定的枚举常量之一\n\nweekday = monday;//不正确,monday不是指定的枚举常量之一\n\n\n1\n2\n3\n4\n5\n\n\n枚举常量是由程序设计者命名的,用什么名字代表什么含义,完全由程序员根据自己的需要而定,并在程序中作相应处理。\n\n也可以不声明有名字的枚举类型,而直接定义枚举变量,例如:\n\nenum{sun,mon,tue,wed,thu,fri,sat} workday,weekend;\n\n\n1\n\n\n声明枚举类型用 enum 开头。\n\n声明枚举类型的一般形式为：\n\nenum [枚举名]{枚举元素……};\n\n\n1\n\n\n说明:\n\n(1) c编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符（有名字）而把它们看作变量，不能对它们赋值。\n\n(2) 每一个枚举元素都代表一个整数,c语言编译按定义时的顺序默认它们的值为0,1,2,3,4,5...。在上面的定义中,sun的值自动设为0,mon的值为1,.,sat的值为6。如果有赋值语句:\n\nworkday= mon;//相当于\nworkday= 1;//枚举常量是可以引用和输出的。例如:\nprintf("%d",workday);//将输出整數1。\n\n\n1\n2\n3\n\n\n也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：\n\nenum weekday{sun=7,mon=1,tue,wed,thu,fri,sat} workday,week_end;\n\n\n1\n\n\n指定枚举常量sun的值为7,mon为1,以后顺序加1,sat为6。\n\n由于枚举型变量的值是整数，因此c99把枚举类型也作为整型数据中的一种，即用户自行定义的整数类型。\n\n(3)枚举元素可以用来作判断比较。例如:\n\nif( workday= = mon).. \nif( workday> sun)... \n\n\n1\n2\n\n\n枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。如果定义时未人为 指定，则按上面的默认规则处理，即第1个枚举元素的值为0，故mon > sun，sat > fri。\n\n\n# 7. 用typedef声明新类型名\n\n用typedef指定新的类型名来代替已有的类型名。\n\n有以下两种情况：\n\n 1. 简单地用一个新的类型名代替原有的类型名\n\n例如：\n\ntypedef int integer;\t//指定用integer为类型名,作用与int相同\ntypedef float real;\t\t//指定用real为类型名,作用与float相同\n\n\n1\n2\n\n\n指定用integer代表int类型,real代表float。 这样，以下两行等价：\n\n①int i,j;\nfloat a,b;\n\n②integer i,j;\nreal a,b;\n\n\n1\n2\n3\n4\n5\n\n 2. 命名一个简单的类型名代替复杂的类型表示方法\n\n从前面已知，除了简单的类型（如int，float等）、c程序中还会用到许多看起来比较复杂的类型，包括结构体类型、共用体类型枚举类型、指针类型、数组类型等，如：\n\nfloat*[](指针数组)\nfloat( * )[5](指向5个元素的-维数组的指针)\ndouble * (double * )(定义函数，函数的參数是double*型数据,即指向double数据的指针,函数返回值也是指向double数据的指针)\ndouble( * )()(指向函数的指针，函数返回值类型为double)\nint * ( * ( * )[10])(void)(指向包含10个元素的一维数组的指针,数组元素的类型为函数指针(函数的地址)，函数没有参数，函数返回值是int 指针)\n\n\n1\n2\n3\n4\n5\n\n\n有些类型形式复杂，难以理解，容易写错。c允许程序设计者用一个简单的名字代替复杂的类型形式。\n\n例如：\n\n(1)命名一个新的类型名代表结构体类型:\n\ntypedef struct int month;\nint year;\n} date;\n\n\n1\n2\n3\n\n\n以上声明了一个新类型名date，代表上面的一个结构体类型。然后可以用新的类型名date去定义变量，如：\n\ndate birthday;\t//定义结构体类型变量birthday ,不要写成struct date birthday;\ndate* p;\t\t//定义结构体指针变量p.指向此结构体类型数据\n\n\n1\n2\n\n\n(2)命名一个新的类型名代表数组类型：\n\ntypedef int num[ 100];\t//声明num为整型数组类型名\nnuma;\t\t\t\t\t//定义a为整型数组名,它有100个元素\n\n\n1\n2\n\n\n(3)命名一个新的类型名代表指针类型：\n\ntypedef char * string;\t//声明string为字符指针类型\nstring p,s[10]; \t\t//定义p为字符指针变量,s为字符指针数组\n\n\n1\n2\n\n\n(4)命名一个新的类型名代表指向函数的指针类型：\n\ntypedefint(*pointer)();\t//声明pointer为指向函数的指针类型,该函数返回整型值\npointer pl,p2;\t\t\t//p1,p2为pointer类型的指针变量\n\n\n1\n2\n\n\n归纳起来，声明一个新的类型名的方法是：\n\n①先按定义变量的方法写出定义体(如:int i;)。\n②将变量名换成新类型名(例如:将i换成count)。\n③在最前面加typedef(例如:typedef int count)。\n④然后可以用新类型名去定义变量。\n\n\n1\n2\n3\n4\n\n\n简单地说，就是按定义变量的方式，把变量名换上新类型名，并且在最前面加typedef，就声明了新类型名代表原来的类型。\n\n以定义上述的数组类型为例来说明：\n\n①先按定义数组变量形式书泻: int a[100]。\n②将变量名a换成自己命名的类型名:int num[100]。\n③在前面加上typedef,得到typedef int num[100]。\n④用来定义变量:num a;\n相当于定义了:int a[100];\n同样,对字符指针类型,也是:\n①char * p; \t\t\t\t//定义变量p的方式\n②char * string;\t\t\t//用新类型名string 取代变量名p\n③typedef char * string;\t//加typedef\n④string p;\t\t\t\t//用新类型名string定义变量,相当char*p;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别。',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第二章、80X86微处理器",frontmatter:{title:"第二章、80X86微处理器",date:"2021-05-16T15:30:00.000Z",permalink:"/smc/2/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/60.SMC/03.%E7%AC%AC%E4%BA%8C%E7%AB%A080X86%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8.html",relativePath:"60.SMC/03.第二章80X86微处理器.md",key:"v-47c172c3",path:"/smc/2/",headers:[{level:2,title:"1. 16位微处理器概述",slug:"_1-16位微处理器概述",normalizedTitle:"1. 16位微处理器概述",charIndex:318},{level:2,title:"2. 8086/8088微型处理器结构（CPU）",slug:"_2-8086-8088微型处理器结构-cpu",normalizedTitle:"2. 8086/8088微型处理器结构（cpu）",charIndex:568},{level:3,title:"2.1 8086 CPU内部结构",slug:"_2-1-8086-cpu内部结构",normalizedTitle:"2.1 8086 cpu内部结构",charIndex:597},{level:3,title:"2.2指令执行部件（EU）",slug:"_2-2指令执行部件-eu",normalizedTitle:"2.2指令执行部件（eu）",charIndex:899},{level:3,title:"2.3总线接口部件（BIU）",slug:"_2-3总线接口部件-biu",normalizedTitle:"2.3总线接口部件（biu）",charIndex:2982},{level:3,title:"2.4 8086 CPU的寄存器结构",slug:"_2-4-8086-cpu的寄存器结构",normalizedTitle:"2.4 8086 cpu的寄存器结构",charIndex:5428},{level:2,title:"3.8086 CPU引脚的功能",slug:"_3-8086-cpu引脚的功能",normalizedTitle:"3.8086 cpu引脚的功能",charIndex:8387},{level:3,title:"1.8086总线周期",slug:"_1-8086总线周期",normalizedTitle:"1.8086总线周期",charIndex:8537},{level:3,title:"2.8086 CPU的引脚及功能",slug:"_2-8086-cpu的引脚及功能",normalizedTitle:"2.8086 cpu的引脚及功能",charIndex:9185},{level:2,title:"4.8086的存储及I/O组织",slug:"_4-8086的存储及i-o组织",normalizedTitle:"4.8086的存储及i/o组织",charIndex:11544},{level:3,title:"1.8086系统的存储结构",slug:"_1-8086系统的存储结构",normalizedTitle:"1.8086系统的存储结构",charIndex:11564},{level:3,title:"2.8086系统存储器的地址",slug:"_2-8086系统存储器的地址",normalizedTitle:"2.8086系统存储器的地址",charIndex:12090},{level:3,title:"3.8086系统内存地址的一些专用区域",slug:"_3-8086系统内存地址的一些专用区域",normalizedTitle:"3.8086系统内存地址的一些专用区域",charIndex:12372},{level:3,title:"4.8086 I/O组织",slug:"_4-8086-i-o组织",normalizedTitle:"4.8086 i/o组织",charIndex:12589},{level:2,title:"5.8086系统配置",slug:"_5-8086系统配置",normalizedTitle:"5.8086系统配置",charIndex:12843},{level:3,title:"1.最小模式和最大模式的的概述",slug:"_1-最小模式和最大模式的的概述",normalizedTitle:"1.最小模式和最大模式的的概述",charIndex:12858},{level:3,title:"2.最小模式系统",slug:"_2-最小模式系统",normalizedTitle:"2.最小模式系统",charIndex:13256},{level:3,title:"3.最小模式下的系统控制信号",slug:"_3-最小模式下的系统控制信号",normalizedTitle:"3.最小模式下的系统控制信号",charIndex:14569},{level:3,title:"4.8086 CPU的工作时序",slug:"_4-8086-cpu的工作时序",normalizedTitle:"4.8086 cpu的工作时序",charIndex:16157}],headersStr:"1. 16位微处理器概述 2. 8086/8088微型处理器结构（CPU） 2.1 8086 CPU内部结构 2.2指令执行部件（EU） 2.3总线接口部件（BIU） 2.4 8086 CPU的寄存器结构 3.8086 CPU引脚的功能 1.8086总线周期 2.8086 CPU的引脚及功能 4.8086的存储及I/O组织 1.8086系统的存储结构 2.8086系统存储器的地址 3.8086系统内存地址的一些专用区域 4.8086 I/O组织 5.8086系统配置 1.最小模式和最大模式的的概述 2.最小模式系统 3.最小模式下的系统控制信号 4.8086 CPU的工作时序",content:"# 第二章、80X86微处理器\n\n二、80X86微处理器\n（一）知识范围\n8086/8088CPU的内部结构和外部引线； \n8086/8088CPU的工作方式；\n8086/8088CPU系统总线的形成；\n8086/8088的存储器结构；\n总线操作及时序。\n（二）考核要求\n1.\t掌握8086/8088CPU的功能构成及流水线技术，理解流水线管理规则。\n2.\t掌握 8086/8088CPU寄存器的组成及其应用。\n3.\t理解8086/8088CPU的内存分配，掌握实地址模式下的存储器地址变换方法。\n4.\t掌握8086/8088CPU的引脚构成，理解其引脚复用的特性。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1. 16位微处理器概述\n\n8086和8088 CPU的内部基本相同，但它们的外部性能是有区别的。\n\n8086 是16位数据总线，而8088是8位数据总线，在处理一个16位数据字时，8088需要两步操作而8086只需要一步。\n\n8086和8088 CPU的内部都采用16位字进行操作及存储器寻址，两者的软件完全兼容，程序的执行也完全相同。\n\n然而，由于8088要比8086有较多的外部存取操作。所以，对相同的程序，它将执行得较慢。这两种微处理器都封装在相同的40脚双列直插组件(DIP)中。\n\n\n# 2. 8086/8088微型处理器结构（CPU）\n\n\n# 2.1 8086 CPU内部结构\n\n8086 CPU从功能上可分两部分，即总线接口部件（BIU）和指令执行部件（EU）。8086的内部结构如图。\n\n\n\n指令执行部件（EU）主要由算数运逻辑运算单元（ALU）、标志寄存器（FR）、通用寄存器组和EU控制电路4个部件组成，其主要功能就是负责指令执行。将指令译码并利用内部的寄存器和ALU对数据进行所需处理。\n\n总线接口部件（BIU）主要由地址加法器、专用寄存器组、指令队列和总线控制电路4个部件组成，其主要功能是形成访问存储器的物理地址、访问存储器并存取指令暂存到指令队列中等待执行，访问存储器或I/O端口读取操作数来参加EU运算或存放运算结果等。\n\n\n# 2.2指令执行部件（EU）\n\n指令执行部件由下列部分组成：\n\n * 寄存器：\n   * 4个16位通用寄存器，这些寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊用途。\n     * AX（累加器）：一般用来存放参加运算的数据和结果，在乘，除法运算、I/O操作、BCD数运算中有不可替代的作用。\n     * BX（基址寄存器）：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而AX，CX，DX不能。\n     * CX（奇数寄存器）：既可以作为数据寄存器，又可串指令和位移指令中作为计数用。\n     * DX（数据寄存器）：除可作为通用数据寄存器外，还在乘、除法运算、带符号数的扩张指令中有特殊用途。\n     * 通用寄存器既可以用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为AL、BL、CL和DL、，高八位被命名为AH、BH、CH和DH。这些寄存器一般存放8位数据。\n   * 4个16位专用寄存器，主要用来存放存储器或I/O端口的地址。\n     * SI（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n     * DI（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n     * BP（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n     * SP（堆栈指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n * 标志寄存器（FR）\n * 算数逻辑部件（ALU）\n * 内部控制逻辑\n\n----------------------------------------\n\n8086/8088 的EU有以下特点：\n\n8个16位通用寄存器：\n\n * 数据寄存器（AX、BX、CX、DX）\n   * 可用来存放16位的数据地址，又可分为8个8位寄存器(只能存放数据而不能存放地址)，即：\n\n寄存器特有的习惯用法：\nAX ——> AH,AL\tAX:所有I/O指令都通过AX或AL与接口传输信息，中间运算结果也多放于AX中。\nBX ——> BH,BL \tBX:在间接寻址中用于存放基地址。\nCX ——> CH,CL \tCX:可以用作数据寄存器，在字符串操作、循环操作和位移操作时用作计数器，存放计数值。\nDX ——> DH,DL \tDX:在间接寻址的I/O指令中存放I/O端地址；在32位乘除法运算时，存放高16位数。\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n指针和变址寄存器（SP、BP、SI、DI）：\n\n4个16位寄存器，主要用来存放操作数的偏移地址（即操作数的段内地址）。\n\n * SP（堆栈指针寄存器）：在堆栈操作中存放栈顶的偏移地址。（不能寻址，路标）\n * BP（基址指针寄存器）：常用于在访问内存时存放内存单元的偏移地址，还用作堆栈区的基地址寄存器。（可以寻址）\n\n注意BX与BP在应用上的区别：\n\n  - 作为通用寄存器（16位寄存器），二者均可用于存放数据\n  - 作为基址寄存器，用BX表示所寻找的数据在数据段；用BP则表示数据在堆栈段\n\n\n1\n2\n3\n4\n\n\n * SI（源变址寄存器）：主要用于存放地址，在字符串操作中存放源操作数的偏移地址。\n\n * DI（目的变址寄存器）：主要用于存放地址，在字符串操作中存放目的操作数的偏移地址。\n\n变址寄存器常用于指令的间接寻址或变址寻址。\n在串操作中变址寄存器内存放的地址在数据传送完成后，具有自动修改的功能。\n例如:传送1字节数据之后地址自动加1，为下次传送做好准备，变址寄存器因此得名。\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n算数逻辑单元（ALU）及标志寄存器（FR）\n\n * 算数逻辑运算单元ALU：\n   * 可完成16位或8位的算数逻辑运算，运算结果通过内部总线送到通用寄存器，或者送往BIU的内部寄存器中，等待写入存储器。ALU运算后的结果特征（有无进位，溢出等）置入标志寄存器FLAGS中保存。\n * 标志寄存器FLAGS：（FLAGS=FR=PSW）\n   * 16位寄存器，用来存放运算结果的特征和控制标志。\n\n根据功能，8086的标志可以分为两类：\n\n * 状态标志：6个，用来表示运算结果的特征。包括CF、PF、AF、ZF、SF和OF\n * 控制标志：3个，用来控制CPU的操作。包括IF、DF和TF。\n\n\n\n\n\n----------------------------------------\n\n内部控制逻辑电路\n\n主要功能：从指令队列缓冲器中取出指令，对指令进行译码。并产生各种控制信号，控制各种部件的协同工作以完成指令的过程。\n\n\n# 2.3总线接口部件（BIU）\n\n功能：\n\n * 形成访问存储器的物理地址（实际地址）；\n * 访问存储器取得指令并暂存到指令队列中等待执行；\n * 访问存储器或I/O端口以读取操作参数与EU运算，或存放运算结果等。\n * 逻辑地址形式——段地址:偏移地址(有效地址)\n\n总线接口部件由下列各部分组成：\n\n * 4个段地址寄存器，即:\n\nCS —— 16位代码段寄存器;\nDS —— 16位数据段寄存器;\nES —— 16位附加段寄存器;\nSS —— 16位堆栈段寄存器。\n\n\n1\n2\n3\n4\n\n * 16位指令指针寄存器 IP。\n * 20位地址加法器。\n * 6字节的队列指令。\n * 总线控制逻辑\n\n8086/8088的 BIU有如下特点：\n\n * 8086 的指令队列为6个字节，8088的指令队列为4个字节。不管是8086还是8088，都会在执行指令的同时，从内存中取下一条指令或下几条指令，取来的指令就放在指令列中。这样，一般情况下，CPU执行完一条指令就可以立即执行下一条指令，而不需要像以往的计算机那样，让CPU轮番进行取指令和执行指令的操作，从而提高了CPU的效率。\n * 20位地址加法器专门用来完成由逻辑地址变换成物理地址的功能，实际上是进行一次地址加法，将两个16位的逻辑地址变换为20位的物理地址从而使可寻址的存储空间达到1 MB。\n * 物理地址转换方法：\n\n物理地址（20）=段地址（高16位）+偏移地址(有效地址，低16位)\n例如：\n段地址为：\t0001 0010 0011 0100\n偏移地址为:\t0000 1010 1111 1011\n物理地址计算：\n\t0001 0010 0011 0100 0000（后补四个0）\n+\t     0000 1010 1111 1011\n-----------------------------\n    0001 0010 1110 0011 1011\n物理地址：0001 0010 1110 0011 1011（20位）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n只有寻址的时候用的是物理地址，在内部交换数据时用的是逻辑地址形式——段地址:偏移地址(有效地址)\n\n----------------------------------------\n\n**段基址：**表示一个段的起始地址的高16位。\n\n段首地址 = 段基址 *16\n\n**偏移地址：**表示段内的一个单元距离段开始位置的距离，因此，偏移地址也称为段内地址。\n\n例如：\n\n2345H:1100H\n段基址为（段的起始地址）：2345H\n段内偏移地址为：1100H的存储单元地址。\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n地址加法器\n\n功能：完成逻辑地址向物理地址的变换。\n\n物理地址：访问存储器的实际地址，用20位2进制表示。\n\n方法：物理地址=段基址*16(即左移4位)+偏移地址\n\n----------------------------------------\n\n指令指针寄存器IP——16位\n\n功能：用来存放将要执行的下一条指令在代码中的偏移地址。在程序运行过程中，BIU自动修改IP中的内容，使它始终指向将要执行的下一条命令。\n\n注意：程序不能直接访问IP，但是可以通过某些指令修改IP的内容。例如，执行转移指令时，会将转移的目标地址送入IP中，以实现程序转移。\n\n----------------------------------------\n\n指令队列缓冲器——6字节\n\nBIU从存储器中读出指令送入6字节（8086是6字节、8088是4字节）的指令队列。一旦指令队列中空出2个字节，BIU将自动进行读取指令的操作以填满指令队列。只要收到EU送来的操作数地址，BIU将立即形成这个操作数的物理地址，完成读/写操作。遇到转移类指令，BIU将指令对列中剩余的指令作废，重新从存储器新的地址单元中取指令并送指令队列。一般情况下应保证指令队列中填满指令，使得EU可以不断地得到等待执行指令。\n\n----------------------------------------\n\n总线控制逻辑\n\n是将CPU的内部总线与CPU引脚所连接的外部总线相连，是CPU与外部交换信息（数据、地址、状态、控制信息）的必经之路，包括16条数据线、20条地址线和若干条控制信号线。\n\n----------------------------------------\n\n总线接口部件和执行部件并不是同步工作的，它们是按以下流水线技术原则管理：\n\n * 每当8086 的指令队列中有两个空字节，或者8088的指令队列中有一个空字节时，总线接口部件就会自动把指令取到指令队列中。\n\n * 每当执行部件准备执行一条指令时，它会从总线接口部件的指令队列前部取出指令的代码，然后用几个时钟周期去执行指令。在执行指令的过程中，如果必须访问存储器或者输入/输出设备，那么，执行部件就会请求总线接口部件，进人总线周期，完成访问内存或者输人/输出端口的操作；如果此时总线接口部件正好处于空闲状态，那么，会立即响应执行部件的总线请求。但有时会遇到这样的情况，执行部件请求总线接口部件访问总线时，总线接口部件正在将某个指令字节取到指令队列中，此时总线接口部件将首先完成这个取指令的总线周期，然后再去响应执行部件发出的访问总线的请求。\n\n * 当指令队列已满，而且执行部件又没有总线访问时，总线接口部件便进人空闲状态。\n\n * 在执行转移指令、调用指令和返回指令时，下面要执行的指令就不是在程序中紧接着的那条指令了，而总线接口部件往指令队列装入指令时，总是按顺序进行的，这样，指令队列中已经装入的字节就没有用了。遇到这种情况，指令队列中的原有内容被自动消除，总线接口部件会接着往指令队列中装人另一个程序段中的指令。\n\n\n# 2.4 8086 CPU的寄存器结构\n\n一、通用寄存器\n\n微处理器的结构中存在着许多寄存器，其作用是让程序暂存数据和地址。8086 CPU指令执行部件EU中有8个16位通用寄存器，它们分成两组。\n\n一组由AX、BX、CX和DX构成，称为通用数据寄存器。这些通用数据寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊的用途。\n\n * AX (Accumulator Register，累加器): 一般用来存放参加运算的数据和结果，在乘、除法运 算、I/O 操作、BCD数运算中有不可替代的作用。\n\n * BX (Base Register，基址寄存器)：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而AX、CX、DX则不能。\n\n * CX (Counter Register ，数据寄存器)：既可作为数据寄存器，又可在串指令和移位指令中作为计数用。\n\n * DX (Data Register ，数据寄存器)：除可作为通用数据寄有器外，还在乘、除法运算、带符号数的扩展指令中有特殊用途。\n\n通用寄在器既可用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为AL、BL、CL和DL，高8位被命名为 AH、BH、CH和DH。这些寄存器一 般存放8位数据。\n\n另一组为4个16位寄存器，主要用来存放存储器或I/O端口的地址。\n\n * SI（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n * DI（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n * BP（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n * SP（堆栈指针寄存器）：多用于存放栈顶的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n\n为了更好地管理存储器，8086CPU把它所对应的存储空间分成几个逻辑段，而存放在上述指针或变址寄存器中的往往是在某逻辑段中寻址的偏移地址。例如，一条ADD指令可以在当前 数据段中指定它的一一个操作数，办法之一就 是把该操作数的偏移量放在一个指示 器或变址寄存器中。当然，这些寄存器也可以存放16位数据。\n\n这些通用寄存器对于一些指令来说，它们具有一致性。 例如，ADD指令可将任意两个8位或 16位通用寄存器的内容相加，结果可存放到这两个寄存器中的任何一个中。 为了缩短指令代码长度，8086 CPU的少数指令把某些通用寄存器作为专用。例如，串操作指令总是用CX寄存器存放串的长度，并在串操作指令执行过程中，CX寄存器专用于计数。这样，所有串操作指令就不必 再在指令中指定CX寄存器，因而缩短了串操作指令的代码长度。如果在指 令中没有明显标出，但指令中又需要使用这些寄存器，通常将其称为“隐含寻址”。隐含寻址实际上是在某类指令中指定某些通用寄存器作为特殊用法。程序设计者在编制程序时需遵循这些规定，将某些特殊数据放在特定的寄存器中，才能正确地执行这些指令。这样也许会给程序设计者带来一些麻烦，但因其采用“隐含”方式，能有效地缩短指令代码的长度。\n\n在8086 CPU中，有些寄存器具有上述隐含性质，即相应的指令中不必给出寄存器名；另有 一些寄存器虽也具有特殊用途， 但不能隐含寻址，指令中使用这些寄存器时，必须给出它们的寄存器名。表2-1给出了这些寄存器的特珠用途和隐含性质。\n\n\n\n----------------------------------------\n\n二、段寄存器\n\n8086 CPU总线接口部件（BIU）有如下4个16位段寄存器。\n\nCS （代码段寄存器）：存放程序代码段起始地址的高16位。\n\nDS（数据段寄存器）：存放数据段起始地址的高16位。\n\nSS（堆栈段寄存器）：存放堆栈段起始地址的高16位。\n\nES（扩展段寄存器）：存放扩展数据段起始地址的高16位。\n\n存储器的分段\n\n\t8086具有1 MB的存储空间，但放在指令指示器和变址寄存器中的地址都只有16位。仅16 位地址不能直接提供1 MB存储器寻址，只能在一个特定的64 KB段的偏移量中寻址。由此，划分地址段并且确定偏移量寻址是在哪段中进行的就变得至关重要了。在8086系统中，1 MB的存储空间可被分成许多逻辑段，每段最长为64 KB，这些逻辑段可在整个1 MB存储空间中浮动。同时，划分的各逻辑段首地址的高16位存放在该段寄存器中，这个高16位地址又称为段基址。 这样，代码段寄存器(CS) 用来存放当前代码段的段基址，数据段寄存器(DS)用来存放当前数据段的段基址，扩展段寄存器(ES) 用来存放扩展段的段基址，堆栈段寄存器(SS)用来存放堆栈段的段基址。\n\n\n将1 MB的存储空间分成若干块，称为 “逻辑段” ，每个逻辑段容量 <= 64 KB,存储空间可分成16个逻辑段（0~15）。在段内寻址人采用传统的16位地址寻址方法。在8086存储空间中，把16字节的存储空间称作一节。要求各个逻辑段从节的整数边界开始，即段首地址低4位应该是 ”0“ ，把首段地址的高16位称为 “段基址” ，存放在段寄存器DS或CS或SS或ES中。\n\n允许段在整个存储空间浮动，即段与段之间可以部分重叠、完全重叠、连续排列。在整个存储空间中可以设置若干个逻辑段。对于任何一个物理地址，可以唯一地被包含在一个逻辑段中，也可以包含在多个相互重叠段中，只要有段的地址就可以访问到这个物理逻辑地址所对应的存储空间。\n\n用于存放段基址有4个16位段寄存器，代码段寄存器CS，数据段寄存器DS，附加段寄存器ES和堆栈寄存器SS。\n\n * 代码段CS：存放程序代码，程序代码超过64 KB时，需要分成几个段存放。CS中存放的是现在正在执行的程序段的段基址。\n\n * 数据段DS：用于存放当前使用的数据。需要第二个数据段时可以使用附加段。\n\n * 堆栈段SS：是内存中的一块存储区，用来存放专用数据。如调用子程序是的入口参数，返回地址等，这些数据都按照 “后进先出” 的规则进行存取。SS存放堆栈段的段基址，SP存放当前堆栈栈顶的偏移地址。数据进出堆栈要使用专门的堆栈操作指令，SP的值在执行堆栈操作指令时根据规则自动地进行修改。\n\n在编程时，程序和各种不同类型的数据分别存放在不同的逻辑段中，它们的 “段基址” 存放在 “段寄存器” 中，段内的偏移地址存放在指针寄存器或变址寄存器中。\n\n----------------------------------------\n\n三、标志寄存器\n\n8086的标志可以分为两类：\n\n * 状态标志：6个，用来表示运算结果的特征。包括CF、PF、AF、ZF、SF和OF\n * 控制标志：3个，用来控制CPU的操作。包括IF、DF和TF。\n\n\n\n----------------------------------------\n\n四、指令指针寄存器\n\n指令指针寄存器IP，里面放置的是不是指令，而是一个指向下一个将要去获取的指令的内存地址（所以它是一个指针）。\n\n\n# 3.8086 CPU引脚的功能\n\n8086 CPU是16位的微处理器，它向外的信号应包含16条数据线，20条地址线，再加上其他一些必要的控制信号。为了减少芯片引脚数量对部分引脚采用了分时复用的方式，构成40条引脚的双列直插式封装。\n\n分时复用： 就是在同一根传输线上，在不同时间传不同信息。\n\n\n# 1.8086总线周期\n\n时钟周期： CPU的一切操作都是在系统主时钟CLK的控制下按节拍有序地进行。周期 = 1/频率。\n\n总线周期： CPU通过外部总线对存储器或I/O端口进行一次读/写操作的过程称为总线周期。为完成对存储或I/O端口访问的一次访问，CPU需要先后发出读或者写操作命令，进行数据传输。以上的每一个操作都需要延续一个或几个时钟周期。所以一个总线周期由若干个（一般为4个）时钟周期（T）组成。\n\n\n\n * T1状态：CPU向多路复用总线上发送地址信息（A19~A0）指出要寻址的内存单元地址或I/O端口地址。这期间CPU还要送出地址锁存信号ALE（正向脉冲），在ALE的下降沿将内存单元地址或I/O端口地址存入地址锁存器。\n\n * T2状态：CPU从总线上撤销地址，使总线低16位呈现高阻状态，为传输数据作准备。总线高4位（A19~A16）输出总线周期的状态信息，用以表示中断允许状态及正在使用的段寄存器名等。\n\n * T3状态：A19~A16上状态信息不变，总线低16位上出现CPU要写出的数据或准备读入数据。若外设或内存来不及与总线交换数据，以使在T4状态下结束该总线周期，则应通过CPU的READY信号，在T3前沿（下降沿）之前向CPU申请插入等待状态TW。在T3及TW的前沿查询READY线，查到高电平则结束等待状态，进入下一状态。否则继续插入等待状态。\n\n * T4状态：总线周期结束，若为总线读周期则在T4前沿将数据读入CPU。\n\n * TI状态：总线空闲周期\n\n\n# 2.8086 CPU的引脚及功能\n\n\n\n8086/8088 CPU有两种不同所谓工作模式（最小模式和最大模式），8条引脚（24~31）在两种工作模式中具有不同的功能。引脚图括号中是最大模式下被重新定义的控制信号。\n\n引脚信号的传输有以下几种类型：\n\n * 输出：信号从CPU向外部传送；\n * 输入：信号从外部送入CPU；\n * 双向：信号又时从外部送入CPU，有时从CPU向外部传送；\n * 三态：除了高电平、低电平两种状态之外，CPU内部还可以通过一个大的电阻阻断内外信号的传输，CPU内部的状态与外部相互隔离，称为”悬浮态“。\n\n----------------------------------------\n\n引脚信号和功能\n\n 1. GND（地）和VCC（电源）\n 2. AD15~AD0地址/数据复用引脚（双向，三态）：作为复用引脚，在总线周期的T1状态用来输出要访问的存储器或I/O端口地址。T2~T3状态，对读周期来说，处于浮空状态；对写周期来说，则是传输数据。\n 3. A19/S6~A16/S3地址/状态复用引脚（输出，三态）：在总线周期的T1状态，用来输出用地址的最高4位，A19~A16与AD15~AD0一起构成访问存储器的20位物理地址。CPU访问I/O端口时，A19~A16保持为“0“。在T2，T3，TW和T4状态时，S6~S3用来输出状态信息。\n\n其中：\nS6: S6=0表示8086CPU占用系统总线，在T2，T3，TW和T4状态时，8086总是使S6=0。\nS5: 反映标志寄存器的中断允许标志IF的设置情况\n\tIF=1，允许可屏蔽中断，则S5=1\n\tIF=0，禁止可屏蔽中断，则S5=0\nS4，S3: 指明正在使用的段寄存器情况。\n\n\n1\n2\n3\n4\n5\n6\n\n\nS4   S3   表示意义\n0    0    正在使用ES\n0    1    正在使用SS\n1    0    正在使用CS，或者未在使用任何寄存器\n1    1    正在使用DS\n\n 4. BHE/S7 高8位数据总线允许/状态复用引脚（输出，三态，低电平有效）：\n\n * 在T1状态，BHE/S7引脚输出BHE信号，表示高8位数据总线D15~D8上的数据有效。在T2，T3，TW和T4状态，BHE/S7输出状态信号S7。不过，在当前芯片（8086，8086-1，8086-2）设计中，S7并未被赋予任何实际意义。\n * 8086 CPU有16根数据线，低8位数据线总是和偶地址的储存器或I/O端口相连接，高8位的数据线与奇地址的存储器或I/O端口相连接。\n * BHE有效，表示CPU正在使用高8位的数据线对奇地址的存储单元或I/O端口进行访问。它与地址码最低位A0配合起来表示当前总线使用情况。\n\n 5.  NMI非屏蔽中断引脚（输入）：非屏蔽中断信号是一个由低到高的上升沿。这类中断不受中断标志IF的影响，也不能用软件进行屏蔽。每当NMI端进人一个正沿触发信号时，CPU就会在结束当前指令后，进入对应于中断类型号为2的非屏蔽中断处理程序。\n\n 6.  INTR可屏蔽中断请求信号引脚（输入）：可屏蔽中断请求信号为高电平有效，CPU在执行每条指令的最后一个时钟周期会对INTR信号进行采样，如果CPU中的中断允许标志为1，并且又接收到INTR信号，那么，CPU就会在结束当前指令后，响应中断请求，进人一个中断处理子程序。\n\n 7.  RD(read)读信号引脚（输出、三态、低电平有效）：此信号指出将要执行一个对内存或I/O端口的读操作。到底是读取内存单元中的数据还是I/O端口中的数据，这决定于M/IO信号。在一个执行读操作的总线周期中，RD信号在T2，T3和Tw状态均为低电平。在系统总线进人“保持响应”期间，RD引脚被浮置为高阻状态。\n\n 8.  CLK(clock)时钟引脚 (输入)：8086要求时钟信号的占空比为1/3，即1/3周期为高电平，2/3周期为低电平。CPU的所有操作均是在时钟同步下进行的。\n\n 9.  RESET(reset)复位信号引脚（输入、高电平有效）：8086/8088 要求复位信号至少维持4个时钟周期的高电平才有效。复位信号来到后，CPU便结束当前操作，对处理器标志寄存器（FR）、IP,DS,SS,ES及指令队列清零，而将CS设置为FFFFH。当复位信号变为低电平时，CPU从FFFF0H开始执行程序。系统程序一般在该物理地址单元放一条转移指令，转到引导程序的入口。\n\n 10. READY(ready)“准备好”信号引脚（输入）：“准备好”信号实际上是由所访问的存储器或I/O设备发来的响应信号，高电平有效。“准备好”信号有效时，表示内存或I/O设备准备就绪，马上就可进行一次数据传输。CPU在每个总线周期的T3状态开始对READY信号进行采样。如果检测到READY为低电平，则在T3状态之后插入等待状态Tw,在Tw状态，CPU也对READY进行采样，若READY仍为低电平，则会继续插人Tw，所以Tw可以插人一个或多个。直到READY变为高电平后，才进人T4状态，完成数据传送过程，从而结束当前总线周期。\n\n 11. TEST( test)测试信号引脚（输入、低电平有效）：测试信号为低电平有效。TEST信号是和指令WAIT结合起来使用的，在CPU执行WAIT指令时，CPU处于空转状态进行等待；当8086的TEST信号有效时，等待状态结束，CPU继续往下执行被暂停的指令。\n\n 12. MN/MX最小/最大模式控制信号引脚（输入）：它是最大模式及最小模式的选择控制端。此引脚固定接为+5V时，CPU处于最小模式；如果接地，则CPU处于最大模式。\n\n\n# 4.8086的存储及I/O组织\n\n\n# 1.8086系统的存储结构\n\n\n\n偶地址数据永远出现在数据总线的低8位上（即DB7~DB0），奇地址数据永远出现在数据总线的高8位上（即DB15~DB8）\n\n关于读写情况的说明：\n\n\n\n（1） 从偶地址上读写一个字节（BHE A0 = 10）如图a，AD15~AD8上的数据被忽略，字节容易通过AD7~AD0传送。\n\n（2） 从奇地址上读写一个字节（BHE A0 = 01）如图c，AD15~AD8上的数据被有效，AD7~AD0上数据被忽略。\n\n> A0 :地址总线的最低位【区分地址是奇数(A0=1,2⁰=1)还是偶数(A0=0,2⁰=0)】\n\n\n\n（3）从偶地址开始读写一个字（BHE A0 = 00）如图b，在AD15~AD8上传送的数据同时有效。\n\n（4）从奇地址开始读写一个字，占用两个总线周期。\n\n * 第一个总线周期BHE A0 = 01，从奇地址读写低字节，在AD15~AD8上传送的数据有效。【取奇字节】\n * 第二个总线周期BHE A0 = 10，从偶地址读写高字节，在AD7~AD0上传送的数据有效。【取偶字节】\n\n> （1）、（2）、（3）读/写只用了一个总线周期。\n> \n> （4）8086总是从偶地址开始读/写数据\n\n\n# 2.8086系统存储器的地址\n\n（1）物理地址的计算公式：\n\n物理地址=段地址*16+偏移地址\n\n\n1\n\n\n段地址由寄存器提供，偏移地址由IP、SP、BP、DI等寄存器提供，也可以通过计算而得。不同的组合方式。\n\n（2）段地址的引入，为程序在内存中浮动创造了条件，一般用户程序只涉及偏移地址。段地址在程序装入内存时由操作系统分配。所以一个程序可在内存中任何一个逻辑段（64 KB空间）中运行。\n\n（3）同一物理地址可以有不同的段地址和偏移地址表示。\n\n例如：\n\nCS= 2000H\tIP=21000H\nCS= 2000H\tIP=21000H\n\n\n1\n2\n\n\n\n# 3.8086系统内存地址的一些专用区域\n\n * 00000~003FFH 1 KB空间用于存放中断向量表，可存放256个中断服务程序的入口地址，每个地址占4个字节\n * 0FFFF0H 启动地址，一般用来存放一条无指令转移指令，转到系统初始化程序。\n\nB0000~B0FFFH 4KB为单色显示器显示缓冲区，存放当前屏幕像素代码。\nB8000~BBFFFH 16KB彩色显示器显示缓冲区，存放当前屏幕像素代码。\n\n\n1\n2\n\n\n\n# 4.8086 I/O组织\n\n * 8086系统有专用的输入（IN）、输出（OUT）指令，用于外设端口（即外设接口中的内部寄存器）的寻址。\n\n * I/O端口与内存分别独立编址。I/O端口使用16位地址A15~A0，I/O端口地址范围为：0000H~FFFFH，可寻址空间为64 KB。\n\n * 在以8086为CPU的PC/XT微机中，只使用了10位有效端口地址A9~A0，共1 KB空间。其中A9只用于指明外设端口是否在系统板上。A9=0为系统板上512个端口，A9=1为I/O通道上512个端口。\n\n\n# 5.8086系统配置\n\n\n# 1.最小模式和最大模式的的概述\n\n8086/8088 CPU为适应不同的应用环境，8086可工作于两种工作模式：最大模式和最小模式。\n\n**最小工作模式：**是指系统中只有一个8086/8088处理器，所有的总线控制信号都由控制逻辑部件最少，最小模式因此得名。最小模式也称为单处理器模式。\n\n**最大工作模式：**系统内可以有一个以上的处理器，除了8086/8088作为 “中央处理器” 之外，还可以配置用于数值计算的8087（数值协处处理器）和用于管理的8089（I/O协处理器）等。各个处理器发往总线的命令统一送往 “总线控制器” ，由它 “仲裁” 后发出。\n\n----------------------------------------\n\n两种工作模式由MN/MX引脚决定：\n\n * 接高电平（+5V），CPU工作在最小模式；\n\n * 接低电平（接地），CPU工作在最大模式。\n\n\n# 2.最小模式系统\n\n# 2.1典型配置：\n\n8086CPU\n1片时钟发生器8284\n3片地址锁存器8282\n2片总线驱动器8286（总线数据收发器）\n\n\n1\n2\n3\n4\n\n\nCPU及其外围芯片合称为CPU子系统。\n\n外围芯片的作用是：\n\n * 为CPU工作提供条件：提供适当的时钟信号，对外界输入的控制/联络信号进行同步处理；\n * 分离CPU输出的地址/数据分时复用信号，得到独立的地址总线和数据总线信号，同时还增强它们的驱动能力；\n * 对CPU的输出控制信号进行组合，产生稳定可靠、便于使用的系统信号。\n\n\n\n----------------------------------------\n\n# 2.2时钟发生器8284与8086的连接\n\n8284通过外接晶振芯片产生时钟信号，并对这个信号3分频，产生占空比为1/3的时钟信号CLK送往8086 CPU。\n\n8284还对外部输出的RESET和READY信号进行同步，产生与CLK同步的复位信号RESET和准备就绪信号READY送往8086。\n\n\n\n----------------------------------------\n\n# 2.3地址锁存器8282与8086的连接\n\n地址锁存器用锁存8086输出的地址信号。\n\n8282是一个8位锁存器，STB是它的数据锁存/宣统信号。STB为高电平时，DI7~DI0上输入的信号进入锁存器；STB由高变低出现下降沿时，输入数据被锁定，锁存器的状态不再改变。\n\n8282具有三态输出功能，OE是数据输出允许端，它为低电平时，锁存器的内容通过内部的三态缓冲器从引脚DO7~DO0输出。\n\n\n\n----------------------------------------\n\n# 2.4总线驱动器8286与8086的连接\n\n作用：总线数据收发器用来对CPU与系统数据总线的连接进行控制，同时它还有增加系统数据总线驱动能力的作用。\n\n8286是一种三态输出的8位双向收发器/驱动器，具有很强的总驱动能力。它有二组8位双向的输入/输出数据线A7~A0和B7~B0。\n\n\n\n8286有二个控制信号：数据传送方向控制信号T输出允许信号OE（低电平有效）。\n\n * 当OE=1时，缓冲器呈高阻状态，两个方向都不能传送数据。\n * 当OE=0，T=1时，A7~A0为输入端，B7~B0为输出端，实现A到B的传送；\n * 当OE=0，T=0时，A7~A0为输出端，B7~B0为输入端，实现B到A的传送。\n\n\n\n8286用作数据总线驱动器时，T与8086数据收发信号相连，用于控制数据传送方向；OE与8086数据允许信号相连，保证只有在CPU需要访问存储器或I/O端口时才允许数据通过8286。二片8286的A7~A0与8086的AD15~AD0相连，而二组B7~B0则成为系统数据总线。\n\n如果系统规模不大，并且不使用MDA传输（这意味着总线永远由8086独自控制），可以不使用总线收发器，将8086的引脚AD15~AD0直接用作系统数据总线。\n\n----------------------------------------\n\n\n# 3.最小模式下的系统控制信号\n\n# 3.1读写控制信号引脚\n\n读写控制信号用来控制CPU对存储和I/O设备的读写过程：控制数据传输方向（读/写）、传输种类（存储器还是I/O设备）；读写方式（奇地址字节/偶地址字节/字）；存储器I/O设备是否准好的状态信号；分时总线信号的类型等。\n\n（1）M/IO存储器或I/O端口访问选择信号，三态输出：\n\n * 为高电平时，表示当前CPU正在访问存储器；\n * 为低电平时，表示CPU当前正在访问I/O端。\n\n（2）RD(Read)读信号、三态输出：低电平有效，表示当前CPU正在读存储器或I/O端口。\n\n（3）MR（Write）写信号，三态输出：低电平有效，表示当前CPU正在写存储器或I/O端口。M/IO、WR及RD合起来决定系统中数据传输方向。\n\n（4）READY准备就绪信号：由外部设备输入\n\n * 高电平有效，表示CPU访问的存储器或I/O端口已准备好传送数据。\n * 当READY无效时，要求CPU插入一个或多个等待周期Tw，直到READY信号有效为止。\n\n（5）BHE/S7 总线高字节有效信号。三态输出，低电平有效。非数据传送期间，该引脚用作，输出状态信息。\n\n（6）ALE地址锁存器允许信号：输出，高电平有效。表示当前地址/数据分时使用的引脚上正在输出地址信号。向地址锁存器8282提供地址锁存信号。\n\n（7 ) DEN 数据允许信号。三态输出，低电平有效。表示当前地址/数据分时使用的引脚上正在传输数据信号。8286将它作为输出允许信号。进行DMA传输时，被置为高阻态。\n\n（8） DT/R 数据发送/接收控制信号，三态输出:\n\n * 当它为高电平时表示为数据发送，CPU写数据到存储器或IO端口；\n * 为低电平时表示为数据接收，CPU从存储器或I/O端口读取数据。\n * 该信号用来控制总线收发器8286的数据传送方向。\n\n# 3.2中断控制信号引脚\n\n中断是外部设备请求CPU进行数据传输的有效方法。这一组引脚传输中断的请求和应答信号。\n\n（1）INTR ：可屏蔽中断请求信号。\n\n（2）INTA 中断响应信号。输出，三态，低电平有效。该信号包含两个负脉冲。外设申请可屏蔽中断，CPU响应后，在两个连续的中断响应周期发出两个负脉冲信号。第一个通知外设，CPU已经收到并且响应外部发来的INTR信号(主要用于中断优先权排队)第二个要求申请中断的设备向CPU发送中断类型(代表该中断的一个编号)\n\n(3) NMI： 不可屏蔽中断请求信号。\n\n# 3.3DMA控制信号引脚\n\nDMA传输是一种不经过CPU，在内存和I/O设备之间直接传输数据的方法。进行DMA传输之前要向CPU申请使用总线并取得认可。\n\n（1）HOLD总线请求信号。输入，高电平有效，表示其他设备向CPU请求使用总线。\n\n（2）HLDA总线请求响应信号。输出，高电平有效。CPU在每个时钟周期都检测HOLD引脚，当检测到该信号，并且CPU允许其它部件占用总线，则在当前总线周期的T4状态发送HLDA信号，同时让出总线使用权（所有三态总线处于高阻态，从而不影响外部的存储器与I/O设备之间交换数据）。总线申请部件接到HLDA有效信号后即可接管总线进行操作，直到操作完成、撤销HOLD信号，CPU才重新接管总线。\n\n----------------------------------------\n\n# 3.4常用的最小模式控制总线信号归纳如下：\n\n * 控制存储器I/O端口读写的信号：\n   \n   * M/IO、RD、WR、BHE、DEN、DT/R、READY\n\n * 用于中断联络和控制的信号：INTR、INTA、NMI。\n\n * 用于DMA联络和控制的信号：HOLD，HLDA。\n\n以上这些信号是构建微型计算机系统的核心，后面会反复使用。\n\n\n# 4.8086 CPU的工作时序\n\n# 4.1 8086 CPU复位操作时序\n\nRESET信号\n\n当CPU接收到有效的RESET信号且至少维持4个时钟周期，不管之前在执行什么动作，只要正常供电，8086就结束现行操作，进入复位状态，直到RESET信号失效。在复位状态下，CPU内部的各寄存器被置为缺省值。\n\n寄存器        复位后默认值\nCS         FFFFH\nIP         0000H\nDS,SS,ES   0000H\nFLAGs      0000H\n指令队列       清空\n其他寄存器      0000H\n\n缺省的CS和IP的内容，通过地址加法器得到FFFF0H，这就是复位后的第一条指令地址。\n\nFFFF0H处存放了一条无条件转移指令，用来转移到固化在主板BIOS里的一段系统程序的入口。这样，系统一旦被启动仍自动进入程序，开始正常工作。\n\n复位时，FR被清空，IF = 0, 此时不接受INTR信号\n\n复位时，所有三态输出总线变为高阻状态。\n\n# 4.2最小模式下的总线读周期\n\n8086 CPU完成存储器外设端口读取数据的操作时序。\n\n",normalizedContent:"# 第二章、80x86微处理器\n\n二、80x86微处理器\n（一）知识范围\n8086/8088cpu的内部结构和外部引线； \n8086/8088cpu的工作方式；\n8086/8088cpu系统总线的形成；\n8086/8088的存储器结构；\n总线操作及时序。\n（二）考核要求\n1.\t掌握8086/8088cpu的功能构成及流水线技术，理解流水线管理规则。\n2.\t掌握 8086/8088cpu寄存器的组成及其应用。\n3.\t理解8086/8088cpu的内存分配，掌握实地址模式下的存储器地址变换方法。\n4.\t掌握8086/8088cpu的引脚构成，理解其引脚复用的特性。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1. 16位微处理器概述\n\n8086和8088 cpu的内部基本相同，但它们的外部性能是有区别的。\n\n8086 是16位数据总线，而8088是8位数据总线，在处理一个16位数据字时，8088需要两步操作而8086只需要一步。\n\n8086和8088 cpu的内部都采用16位字进行操作及存储器寻址，两者的软件完全兼容，程序的执行也完全相同。\n\n然而，由于8088要比8086有较多的外部存取操作。所以，对相同的程序，它将执行得较慢。这两种微处理器都封装在相同的40脚双列直插组件(dip)中。\n\n\n# 2. 8086/8088微型处理器结构（cpu）\n\n\n# 2.1 8086 cpu内部结构\n\n8086 cpu从功能上可分两部分，即总线接口部件（biu）和指令执行部件（eu）。8086的内部结构如图。\n\n\n\n指令执行部件（eu）主要由算数运逻辑运算单元（alu）、标志寄存器（fr）、通用寄存器组和eu控制电路4个部件组成，其主要功能就是负责指令执行。将指令译码并利用内部的寄存器和alu对数据进行所需处理。\n\n总线接口部件（biu）主要由地址加法器、专用寄存器组、指令队列和总线控制电路4个部件组成，其主要功能是形成访问存储器的物理地址、访问存储器并存取指令暂存到指令队列中等待执行，访问存储器或i/o端口读取操作数来参加eu运算或存放运算结果等。\n\n\n# 2.2指令执行部件（eu）\n\n指令执行部件由下列部分组成：\n\n * 寄存器：\n   * 4个16位通用寄存器，这些寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊用途。\n     * ax（累加器）：一般用来存放参加运算的数据和结果，在乘，除法运算、i/o操作、bcd数运算中有不可替代的作用。\n     * bx（基址寄存器）：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而ax，cx，dx不能。\n     * cx（奇数寄存器）：既可以作为数据寄存器，又可串指令和位移指令中作为计数用。\n     * dx（数据寄存器）：除可作为通用数据寄存器外，还在乘、除法运算、带符号数的扩张指令中有特殊用途。\n     * 通用寄存器既可以用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为al、bl、cl和dl、，高八位被命名为ah、bh、ch和dh。这些寄存器一般存放8位数据。\n   * 4个16位专用寄存器，主要用来存放存储器或i/o端口的地址。\n     * si（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n     * di（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n     * bp（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n     * sp（堆栈指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n * 标志寄存器（fr）\n * 算数逻辑部件（alu）\n * 内部控制逻辑\n\n----------------------------------------\n\n8086/8088 的eu有以下特点：\n\n8个16位通用寄存器：\n\n * 数据寄存器（ax、bx、cx、dx）\n   * 可用来存放16位的数据地址，又可分为8个8位寄存器(只能存放数据而不能存放地址)，即：\n\n寄存器特有的习惯用法：\nax ——> ah,al\tax:所有i/o指令都通过ax或al与接口传输信息，中间运算结果也多放于ax中。\nbx ——> bh,bl \tbx:在间接寻址中用于存放基地址。\ncx ——> ch,cl \tcx:可以用作数据寄存器，在字符串操作、循环操作和位移操作时用作计数器，存放计数值。\ndx ——> dh,dl \tdx:在间接寻址的i/o指令中存放i/o端地址；在32位乘除法运算时，存放高16位数。\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n指针和变址寄存器（sp、bp、si、di）：\n\n4个16位寄存器，主要用来存放操作数的偏移地址（即操作数的段内地址）。\n\n * sp（堆栈指针寄存器）：在堆栈操作中存放栈顶的偏移地址。（不能寻址，路标）\n * bp（基址指针寄存器）：常用于在访问内存时存放内存单元的偏移地址，还用作堆栈区的基地址寄存器。（可以寻址）\n\n注意bx与bp在应用上的区别：\n\n  - 作为通用寄存器（16位寄存器），二者均可用于存放数据\n  - 作为基址寄存器，用bx表示所寻找的数据在数据段；用bp则表示数据在堆栈段\n\n\n1\n2\n3\n4\n\n\n * si（源变址寄存器）：主要用于存放地址，在字符串操作中存放源操作数的偏移地址。\n\n * di（目的变址寄存器）：主要用于存放地址，在字符串操作中存放目的操作数的偏移地址。\n\n变址寄存器常用于指令的间接寻址或变址寻址。\n在串操作中变址寄存器内存放的地址在数据传送完成后，具有自动修改的功能。\n例如:传送1字节数据之后地址自动加1，为下次传送做好准备，变址寄存器因此得名。\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n算数逻辑单元（alu）及标志寄存器（fr）\n\n * 算数逻辑运算单元alu：\n   * 可完成16位或8位的算数逻辑运算，运算结果通过内部总线送到通用寄存器，或者送往biu的内部寄存器中，等待写入存储器。alu运算后的结果特征（有无进位，溢出等）置入标志寄存器flags中保存。\n * 标志寄存器flags：（flags=fr=psw）\n   * 16位寄存器，用来存放运算结果的特征和控制标志。\n\n根据功能，8086的标志可以分为两类：\n\n * 状态标志：6个，用来表示运算结果的特征。包括cf、pf、af、zf、sf和of\n * 控制标志：3个，用来控制cpu的操作。包括if、df和tf。\n\n\n\n\n\n----------------------------------------\n\n内部控制逻辑电路\n\n主要功能：从指令队列缓冲器中取出指令，对指令进行译码。并产生各种控制信号，控制各种部件的协同工作以完成指令的过程。\n\n\n# 2.3总线接口部件（biu）\n\n功能：\n\n * 形成访问存储器的物理地址（实际地址）；\n * 访问存储器取得指令并暂存到指令队列中等待执行；\n * 访问存储器或i/o端口以读取操作参数与eu运算，或存放运算结果等。\n * 逻辑地址形式——段地址:偏移地址(有效地址)\n\n总线接口部件由下列各部分组成：\n\n * 4个段地址寄存器，即:\n\ncs —— 16位代码段寄存器;\nds —— 16位数据段寄存器;\nes —— 16位附加段寄存器;\nss —— 16位堆栈段寄存器。\n\n\n1\n2\n3\n4\n\n * 16位指令指针寄存器 ip。\n * 20位地址加法器。\n * 6字节的队列指令。\n * 总线控制逻辑\n\n8086/8088的 biu有如下特点：\n\n * 8086 的指令队列为6个字节，8088的指令队列为4个字节。不管是8086还是8088，都会在执行指令的同时，从内存中取下一条指令或下几条指令，取来的指令就放在指令列中。这样，一般情况下，cpu执行完一条指令就可以立即执行下一条指令，而不需要像以往的计算机那样，让cpu轮番进行取指令和执行指令的操作，从而提高了cpu的效率。\n * 20位地址加法器专门用来完成由逻辑地址变换成物理地址的功能，实际上是进行一次地址加法，将两个16位的逻辑地址变换为20位的物理地址从而使可寻址的存储空间达到1 mb。\n * 物理地址转换方法：\n\n物理地址（20）=段地址（高16位）+偏移地址(有效地址，低16位)\n例如：\n段地址为：\t0001 0010 0011 0100\n偏移地址为:\t0000 1010 1111 1011\n物理地址计算：\n\t0001 0010 0011 0100 0000（后补四个0）\n+\t     0000 1010 1111 1011\n-----------------------------\n    0001 0010 1110 0011 1011\n物理地址：0001 0010 1110 0011 1011（20位）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n只有寻址的时候用的是物理地址，在内部交换数据时用的是逻辑地址形式——段地址:偏移地址(有效地址)\n\n----------------------------------------\n\n**段基址：**表示一个段的起始地址的高16位。\n\n段首地址 = 段基址 *16\n\n**偏移地址：**表示段内的一个单元距离段开始位置的距离，因此，偏移地址也称为段内地址。\n\n例如：\n\n2345h:1100h\n段基址为（段的起始地址）：2345h\n段内偏移地址为：1100h的存储单元地址。\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n地址加法器\n\n功能：完成逻辑地址向物理地址的变换。\n\n物理地址：访问存储器的实际地址，用20位2进制表示。\n\n方法：物理地址=段基址*16(即左移4位)+偏移地址\n\n----------------------------------------\n\n指令指针寄存器ip——16位\n\n功能：用来存放将要执行的下一条指令在代码中的偏移地址。在程序运行过程中，biu自动修改ip中的内容，使它始终指向将要执行的下一条命令。\n\n注意：程序不能直接访问ip，但是可以通过某些指令修改ip的内容。例如，执行转移指令时，会将转移的目标地址送入ip中，以实现程序转移。\n\n----------------------------------------\n\n指令队列缓冲器——6字节\n\nbiu从存储器中读出指令送入6字节（8086是6字节、8088是4字节）的指令队列。一旦指令队列中空出2个字节，biu将自动进行读取指令的操作以填满指令队列。只要收到eu送来的操作数地址，biu将立即形成这个操作数的物理地址，完成读/写操作。遇到转移类指令，biu将指令对列中剩余的指令作废，重新从存储器新的地址单元中取指令并送指令队列。一般情况下应保证指令队列中填满指令，使得eu可以不断地得到等待执行指令。\n\n----------------------------------------\n\n总线控制逻辑\n\n是将cpu的内部总线与cpu引脚所连接的外部总线相连，是cpu与外部交换信息（数据、地址、状态、控制信息）的必经之路，包括16条数据线、20条地址线和若干条控制信号线。\n\n----------------------------------------\n\n总线接口部件和执行部件并不是同步工作的，它们是按以下流水线技术原则管理：\n\n * 每当8086 的指令队列中有两个空字节，或者8088的指令队列中有一个空字节时，总线接口部件就会自动把指令取到指令队列中。\n\n * 每当执行部件准备执行一条指令时，它会从总线接口部件的指令队列前部取出指令的代码，然后用几个时钟周期去执行指令。在执行指令的过程中，如果必须访问存储器或者输入/输出设备，那么，执行部件就会请求总线接口部件，进人总线周期，完成访问内存或者输人/输出端口的操作；如果此时总线接口部件正好处于空闲状态，那么，会立即响应执行部件的总线请求。但有时会遇到这样的情况，执行部件请求总线接口部件访问总线时，总线接口部件正在将某个指令字节取到指令队列中，此时总线接口部件将首先完成这个取指令的总线周期，然后再去响应执行部件发出的访问总线的请求。\n\n * 当指令队列已满，而且执行部件又没有总线访问时，总线接口部件便进人空闲状态。\n\n * 在执行转移指令、调用指令和返回指令时，下面要执行的指令就不是在程序中紧接着的那条指令了，而总线接口部件往指令队列装入指令时，总是按顺序进行的，这样，指令队列中已经装入的字节就没有用了。遇到这种情况，指令队列中的原有内容被自动消除，总线接口部件会接着往指令队列中装人另一个程序段中的指令。\n\n\n# 2.4 8086 cpu的寄存器结构\n\n一、通用寄存器\n\n微处理器的结构中存在着许多寄存器，其作用是让程序暂存数据和地址。8086 cpu指令执行部件eu中有8个16位通用寄存器，它们分成两组。\n\n一组由ax、bx、cx和dx构成，称为通用数据寄存器。这些通用数据寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊的用途。\n\n * ax (accumulator register，累加器): 一般用来存放参加运算的数据和结果，在乘、除法运 算、i/o 操作、bcd数运算中有不可替代的作用。\n\n * bx (base register，基址寄存器)：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而ax、cx、dx则不能。\n\n * cx (counter register ，数据寄存器)：既可作为数据寄存器，又可在串指令和移位指令中作为计数用。\n\n * dx (data register ，数据寄存器)：除可作为通用数据寄有器外，还在乘、除法运算、带符号数的扩展指令中有特殊用途。\n\n通用寄在器既可用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为al、bl、cl和dl，高8位被命名为 ah、bh、ch和dh。这些寄存器一 般存放8位数据。\n\n另一组为4个16位寄存器，主要用来存放存储器或i/o端口的地址。\n\n * si（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n * di（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。\n * bp（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n * sp（堆栈指针寄存器）：多用于存放栈顶的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。\n\n为了更好地管理存储器，8086cpu把它所对应的存储空间分成几个逻辑段，而存放在上述指针或变址寄存器中的往往是在某逻辑段中寻址的偏移地址。例如，一条add指令可以在当前 数据段中指定它的一一个操作数，办法之一就 是把该操作数的偏移量放在一个指示 器或变址寄存器中。当然，这些寄存器也可以存放16位数据。\n\n这些通用寄存器对于一些指令来说，它们具有一致性。 例如，add指令可将任意两个8位或 16位通用寄存器的内容相加，结果可存放到这两个寄存器中的任何一个中。 为了缩短指令代码长度，8086 cpu的少数指令把某些通用寄存器作为专用。例如，串操作指令总是用cx寄存器存放串的长度，并在串操作指令执行过程中，cx寄存器专用于计数。这样，所有串操作指令就不必 再在指令中指定cx寄存器，因而缩短了串操作指令的代码长度。如果在指 令中没有明显标出，但指令中又需要使用这些寄存器，通常将其称为“隐含寻址”。隐含寻址实际上是在某类指令中指定某些通用寄存器作为特殊用法。程序设计者在编制程序时需遵循这些规定，将某些特殊数据放在特定的寄存器中，才能正确地执行这些指令。这样也许会给程序设计者带来一些麻烦，但因其采用“隐含”方式，能有效地缩短指令代码的长度。\n\n在8086 cpu中，有些寄存器具有上述隐含性质，即相应的指令中不必给出寄存器名；另有 一些寄存器虽也具有特殊用途， 但不能隐含寻址，指令中使用这些寄存器时，必须给出它们的寄存器名。表2-1给出了这些寄存器的特珠用途和隐含性质。\n\n\n\n----------------------------------------\n\n二、段寄存器\n\n8086 cpu总线接口部件（biu）有如下4个16位段寄存器。\n\ncs （代码段寄存器）：存放程序代码段起始地址的高16位。\n\nds（数据段寄存器）：存放数据段起始地址的高16位。\n\nss（堆栈段寄存器）：存放堆栈段起始地址的高16位。\n\nes（扩展段寄存器）：存放扩展数据段起始地址的高16位。\n\n存储器的分段\n\n\t8086具有1 mb的存储空间，但放在指令指示器和变址寄存器中的地址都只有16位。仅16 位地址不能直接提供1 mb存储器寻址，只能在一个特定的64 kb段的偏移量中寻址。由此，划分地址段并且确定偏移量寻址是在哪段中进行的就变得至关重要了。在8086系统中，1 mb的存储空间可被分成许多逻辑段，每段最长为64 kb，这些逻辑段可在整个1 mb存储空间中浮动。同时，划分的各逻辑段首地址的高16位存放在该段寄存器中，这个高16位地址又称为段基址。 这样，代码段寄存器(cs) 用来存放当前代码段的段基址，数据段寄存器(ds)用来存放当前数据段的段基址，扩展段寄存器(es) 用来存放扩展段的段基址，堆栈段寄存器(ss)用来存放堆栈段的段基址。\n\n\n将1 mb的存储空间分成若干块，称为 “逻辑段” ，每个逻辑段容量 <= 64 kb,存储空间可分成16个逻辑段（0~15）。在段内寻址人采用传统的16位地址寻址方法。在8086存储空间中，把16字节的存储空间称作一节。要求各个逻辑段从节的整数边界开始，即段首地址低4位应该是 ”0“ ，把首段地址的高16位称为 “段基址” ，存放在段寄存器ds或cs或ss或es中。\n\n允许段在整个存储空间浮动，即段与段之间可以部分重叠、完全重叠、连续排列。在整个存储空间中可以设置若干个逻辑段。对于任何一个物理地址，可以唯一地被包含在一个逻辑段中，也可以包含在多个相互重叠段中，只要有段的地址就可以访问到这个物理逻辑地址所对应的存储空间。\n\n用于存放段基址有4个16位段寄存器，代码段寄存器cs，数据段寄存器ds，附加段寄存器es和堆栈寄存器ss。\n\n * 代码段cs：存放程序代码，程序代码超过64 kb时，需要分成几个段存放。cs中存放的是现在正在执行的程序段的段基址。\n\n * 数据段ds：用于存放当前使用的数据。需要第二个数据段时可以使用附加段。\n\n * 堆栈段ss：是内存中的一块存储区，用来存放专用数据。如调用子程序是的入口参数，返回地址等，这些数据都按照 “后进先出” 的规则进行存取。ss存放堆栈段的段基址，sp存放当前堆栈栈顶的偏移地址。数据进出堆栈要使用专门的堆栈操作指令，sp的值在执行堆栈操作指令时根据规则自动地进行修改。\n\n在编程时，程序和各种不同类型的数据分别存放在不同的逻辑段中，它们的 “段基址” 存放在 “段寄存器” 中，段内的偏移地址存放在指针寄存器或变址寄存器中。\n\n----------------------------------------\n\n三、标志寄存器\n\n8086的标志可以分为两类：\n\n * 状态标志：6个，用来表示运算结果的特征。包括cf、pf、af、zf、sf和of\n * 控制标志：3个，用来控制cpu的操作。包括if、df和tf。\n\n\n\n----------------------------------------\n\n四、指令指针寄存器\n\n指令指针寄存器ip，里面放置的是不是指令，而是一个指向下一个将要去获取的指令的内存地址（所以它是一个指针）。\n\n\n# 3.8086 cpu引脚的功能\n\n8086 cpu是16位的微处理器，它向外的信号应包含16条数据线，20条地址线，再加上其他一些必要的控制信号。为了减少芯片引脚数量对部分引脚采用了分时复用的方式，构成40条引脚的双列直插式封装。\n\n分时复用： 就是在同一根传输线上，在不同时间传不同信息。\n\n\n# 1.8086总线周期\n\n时钟周期： cpu的一切操作都是在系统主时钟clk的控制下按节拍有序地进行。周期 = 1/频率。\n\n总线周期： cpu通过外部总线对存储器或i/o端口进行一次读/写操作的过程称为总线周期。为完成对存储或i/o端口访问的一次访问，cpu需要先后发出读或者写操作命令，进行数据传输。以上的每一个操作都需要延续一个或几个时钟周期。所以一个总线周期由若干个（一般为4个）时钟周期（t）组成。\n\n\n\n * t1状态：cpu向多路复用总线上发送地址信息（a19~a0）指出要寻址的内存单元地址或i/o端口地址。这期间cpu还要送出地址锁存信号ale（正向脉冲），在ale的下降沿将内存单元地址或i/o端口地址存入地址锁存器。\n\n * t2状态：cpu从总线上撤销地址，使总线低16位呈现高阻状态，为传输数据作准备。总线高4位（a19~a16）输出总线周期的状态信息，用以表示中断允许状态及正在使用的段寄存器名等。\n\n * t3状态：a19~a16上状态信息不变，总线低16位上出现cpu要写出的数据或准备读入数据。若外设或内存来不及与总线交换数据，以使在t4状态下结束该总线周期，则应通过cpu的ready信号，在t3前沿（下降沿）之前向cpu申请插入等待状态tw。在t3及tw的前沿查询ready线，查到高电平则结束等待状态，进入下一状态。否则继续插入等待状态。\n\n * t4状态：总线周期结束，若为总线读周期则在t4前沿将数据读入cpu。\n\n * ti状态：总线空闲周期\n\n\n# 2.8086 cpu的引脚及功能\n\n\n\n8086/8088 cpu有两种不同所谓工作模式（最小模式和最大模式），8条引脚（24~31）在两种工作模式中具有不同的功能。引脚图括号中是最大模式下被重新定义的控制信号。\n\n引脚信号的传输有以下几种类型：\n\n * 输出：信号从cpu向外部传送；\n * 输入：信号从外部送入cpu；\n * 双向：信号又时从外部送入cpu，有时从cpu向外部传送；\n * 三态：除了高电平、低电平两种状态之外，cpu内部还可以通过一个大的电阻阻断内外信号的传输，cpu内部的状态与外部相互隔离，称为”悬浮态“。\n\n----------------------------------------\n\n引脚信号和功能\n\n 1. gnd（地）和vcc（电源）\n 2. ad15~ad0地址/数据复用引脚（双向，三态）：作为复用引脚，在总线周期的t1状态用来输出要访问的存储器或i/o端口地址。t2~t3状态，对读周期来说，处于浮空状态；对写周期来说，则是传输数据。\n 3. a19/s6~a16/s3地址/状态复用引脚（输出，三态）：在总线周期的t1状态，用来输出用地址的最高4位，a19~a16与ad15~ad0一起构成访问存储器的20位物理地址。cpu访问i/o端口时，a19~a16保持为“0“。在t2，t3，tw和t4状态时，s6~s3用来输出状态信息。\n\n其中：\ns6: s6=0表示8086cpu占用系统总线，在t2，t3，tw和t4状态时，8086总是使s6=0。\ns5: 反映标志寄存器的中断允许标志if的设置情况\n\tif=1，允许可屏蔽中断，则s5=1\n\tif=0，禁止可屏蔽中断，则s5=0\ns4，s3: 指明正在使用的段寄存器情况。\n\n\n1\n2\n3\n4\n5\n6\n\n\ns4   s3   表示意义\n0    0    正在使用es\n0    1    正在使用ss\n1    0    正在使用cs，或者未在使用任何寄存器\n1    1    正在使用ds\n\n 4. bhe/s7 高8位数据总线允许/状态复用引脚（输出，三态，低电平有效）：\n\n * 在t1状态，bhe/s7引脚输出bhe信号，表示高8位数据总线d15~d8上的数据有效。在t2，t3，tw和t4状态，bhe/s7输出状态信号s7。不过，在当前芯片（8086，8086-1，8086-2）设计中，s7并未被赋予任何实际意义。\n * 8086 cpu有16根数据线，低8位数据线总是和偶地址的储存器或i/o端口相连接，高8位的数据线与奇地址的存储器或i/o端口相连接。\n * bhe有效，表示cpu正在使用高8位的数据线对奇地址的存储单元或i/o端口进行访问。它与地址码最低位a0配合起来表示当前总线使用情况。\n\n 5.  nmi非屏蔽中断引脚（输入）：非屏蔽中断信号是一个由低到高的上升沿。这类中断不受中断标志if的影响，也不能用软件进行屏蔽。每当nmi端进人一个正沿触发信号时，cpu就会在结束当前指令后，进入对应于中断类型号为2的非屏蔽中断处理程序。\n\n 6.  intr可屏蔽中断请求信号引脚（输入）：可屏蔽中断请求信号为高电平有效，cpu在执行每条指令的最后一个时钟周期会对intr信号进行采样，如果cpu中的中断允许标志为1，并且又接收到intr信号，那么，cpu就会在结束当前指令后，响应中断请求，进人一个中断处理子程序。\n\n 7.  rd(read)读信号引脚（输出、三态、低电平有效）：此信号指出将要执行一个对内存或i/o端口的读操作。到底是读取内存单元中的数据还是i/o端口中的数据，这决定于m/io信号。在一个执行读操作的总线周期中，rd信号在t2，t3和tw状态均为低电平。在系统总线进人“保持响应”期间，rd引脚被浮置为高阻状态。\n\n 8.  clk(clock)时钟引脚 (输入)：8086要求时钟信号的占空比为1/3，即1/3周期为高电平，2/3周期为低电平。cpu的所有操作均是在时钟同步下进行的。\n\n 9.  reset(reset)复位信号引脚（输入、高电平有效）：8086/8088 要求复位信号至少维持4个时钟周期的高电平才有效。复位信号来到后，cpu便结束当前操作，对处理器标志寄存器（fr）、ip,ds,ss,es及指令队列清零，而将cs设置为ffffh。当复位信号变为低电平时，cpu从ffff0h开始执行程序。系统程序一般在该物理地址单元放一条转移指令，转到引导程序的入口。\n\n 10. ready(ready)“准备好”信号引脚（输入）：“准备好”信号实际上是由所访问的存储器或i/o设备发来的响应信号，高电平有效。“准备好”信号有效时，表示内存或i/o设备准备就绪，马上就可进行一次数据传输。cpu在每个总线周期的t3状态开始对ready信号进行采样。如果检测到ready为低电平，则在t3状态之后插入等待状态tw,在tw状态，cpu也对ready进行采样，若ready仍为低电平，则会继续插人tw，所以tw可以插人一个或多个。直到ready变为高电平后，才进人t4状态，完成数据传送过程，从而结束当前总线周期。\n\n 11. test( test)测试信号引脚（输入、低电平有效）：测试信号为低电平有效。test信号是和指令wait结合起来使用的，在cpu执行wait指令时，cpu处于空转状态进行等待；当8086的test信号有效时，等待状态结束，cpu继续往下执行被暂停的指令。\n\n 12. mn/mx最小/最大模式控制信号引脚（输入）：它是最大模式及最小模式的选择控制端。此引脚固定接为+5v时，cpu处于最小模式；如果接地，则cpu处于最大模式。\n\n\n# 4.8086的存储及i/o组织\n\n\n# 1.8086系统的存储结构\n\n\n\n偶地址数据永远出现在数据总线的低8位上（即db7~db0），奇地址数据永远出现在数据总线的高8位上（即db15~db8）\n\n关于读写情况的说明：\n\n\n\n（1） 从偶地址上读写一个字节（bhe a0 = 10）如图a，ad15~ad8上的数据被忽略，字节容易通过ad7~ad0传送。\n\n（2） 从奇地址上读写一个字节（bhe a0 = 01）如图c，ad15~ad8上的数据被有效，ad7~ad0上数据被忽略。\n\n> a0 :地址总线的最低位【区分地址是奇数(a0=1,2⁰=1)还是偶数(a0=0,2⁰=0)】\n\n\n\n（3）从偶地址开始读写一个字（bhe a0 = 00）如图b，在ad15~ad8上传送的数据同时有效。\n\n（4）从奇地址开始读写一个字，占用两个总线周期。\n\n * 第一个总线周期bhe a0 = 01，从奇地址读写低字节，在ad15~ad8上传送的数据有效。【取奇字节】\n * 第二个总线周期bhe a0 = 10，从偶地址读写高字节，在ad7~ad0上传送的数据有效。【取偶字节】\n\n> （1）、（2）、（3）读/写只用了一个总线周期。\n> \n> （4）8086总是从偶地址开始读/写数据\n\n\n# 2.8086系统存储器的地址\n\n（1）物理地址的计算公式：\n\n物理地址=段地址*16+偏移地址\n\n\n1\n\n\n段地址由寄存器提供，偏移地址由ip、sp、bp、di等寄存器提供，也可以通过计算而得。不同的组合方式。\n\n（2）段地址的引入，为程序在内存中浮动创造了条件，一般用户程序只涉及偏移地址。段地址在程序装入内存时由操作系统分配。所以一个程序可在内存中任何一个逻辑段（64 kb空间）中运行。\n\n（3）同一物理地址可以有不同的段地址和偏移地址表示。\n\n例如：\n\ncs= 2000h\tip=21000h\ncs= 2000h\tip=21000h\n\n\n1\n2\n\n\n\n# 3.8086系统内存地址的一些专用区域\n\n * 00000~003ffh 1 kb空间用于存放中断向量表，可存放256个中断服务程序的入口地址，每个地址占4个字节\n * 0ffff0h 启动地址，一般用来存放一条无指令转移指令，转到系统初始化程序。\n\nb0000~b0fffh 4kb为单色显示器显示缓冲区，存放当前屏幕像素代码。\nb8000~bbfffh 16kb彩色显示器显示缓冲区，存放当前屏幕像素代码。\n\n\n1\n2\n\n\n\n# 4.8086 i/o组织\n\n * 8086系统有专用的输入（in）、输出（out）指令，用于外设端口（即外设接口中的内部寄存器）的寻址。\n\n * i/o端口与内存分别独立编址。i/o端口使用16位地址a15~a0，i/o端口地址范围为：0000h~ffffh，可寻址空间为64 kb。\n\n * 在以8086为cpu的pc/xt微机中，只使用了10位有效端口地址a9~a0，共1 kb空间。其中a9只用于指明外设端口是否在系统板上。a9=0为系统板上512个端口，a9=1为i/o通道上512个端口。\n\n\n# 5.8086系统配置\n\n\n# 1.最小模式和最大模式的的概述\n\n8086/8088 cpu为适应不同的应用环境，8086可工作于两种工作模式：最大模式和最小模式。\n\n**最小工作模式：**是指系统中只有一个8086/8088处理器，所有的总线控制信号都由控制逻辑部件最少，最小模式因此得名。最小模式也称为单处理器模式。\n\n**最大工作模式：**系统内可以有一个以上的处理器，除了8086/8088作为 “中央处理器” 之外，还可以配置用于数值计算的8087（数值协处处理器）和用于管理的8089（i/o协处理器）等。各个处理器发往总线的命令统一送往 “总线控制器” ，由它 “仲裁” 后发出。\n\n----------------------------------------\n\n两种工作模式由mn/mx引脚决定：\n\n * 接高电平（+5v），cpu工作在最小模式；\n\n * 接低电平（接地），cpu工作在最大模式。\n\n\n# 2.最小模式系统\n\n# 2.1典型配置：\n\n8086cpu\n1片时钟发生器8284\n3片地址锁存器8282\n2片总线驱动器8286（总线数据收发器）\n\n\n1\n2\n3\n4\n\n\ncpu及其外围芯片合称为cpu子系统。\n\n外围芯片的作用是：\n\n * 为cpu工作提供条件：提供适当的时钟信号，对外界输入的控制/联络信号进行同步处理；\n * 分离cpu输出的地址/数据分时复用信号，得到独立的地址总线和数据总线信号，同时还增强它们的驱动能力；\n * 对cpu的输出控制信号进行组合，产生稳定可靠、便于使用的系统信号。\n\n\n\n----------------------------------------\n\n# 2.2时钟发生器8284与8086的连接\n\n8284通过外接晶振芯片产生时钟信号，并对这个信号3分频，产生占空比为1/3的时钟信号clk送往8086 cpu。\n\n8284还对外部输出的reset和ready信号进行同步，产生与clk同步的复位信号reset和准备就绪信号ready送往8086。\n\n\n\n----------------------------------------\n\n# 2.3地址锁存器8282与8086的连接\n\n地址锁存器用锁存8086输出的地址信号。\n\n8282是一个8位锁存器，stb是它的数据锁存/宣统信号。stb为高电平时，di7~di0上输入的信号进入锁存器；stb由高变低出现下降沿时，输入数据被锁定，锁存器的状态不再改变。\n\n8282具有三态输出功能，oe是数据输出允许端，它为低电平时，锁存器的内容通过内部的三态缓冲器从引脚do7~do0输出。\n\n\n\n----------------------------------------\n\n# 2.4总线驱动器8286与8086的连接\n\n作用：总线数据收发器用来对cpu与系统数据总线的连接进行控制，同时它还有增加系统数据总线驱动能力的作用。\n\n8286是一种三态输出的8位双向收发器/驱动器，具有很强的总驱动能力。它有二组8位双向的输入/输出数据线a7~a0和b7~b0。\n\n\n\n8286有二个控制信号：数据传送方向控制信号t输出允许信号oe（低电平有效）。\n\n * 当oe=1时，缓冲器呈高阻状态，两个方向都不能传送数据。\n * 当oe=0，t=1时，a7~a0为输入端，b7~b0为输出端，实现a到b的传送；\n * 当oe=0，t=0时，a7~a0为输出端，b7~b0为输入端，实现b到a的传送。\n\n\n\n8286用作数据总线驱动器时，t与8086数据收发信号相连，用于控制数据传送方向；oe与8086数据允许信号相连，保证只有在cpu需要访问存储器或i/o端口时才允许数据通过8286。二片8286的a7~a0与8086的ad15~ad0相连，而二组b7~b0则成为系统数据总线。\n\n如果系统规模不大，并且不使用mda传输（这意味着总线永远由8086独自控制），可以不使用总线收发器，将8086的引脚ad15~ad0直接用作系统数据总线。\n\n----------------------------------------\n\n\n# 3.最小模式下的系统控制信号\n\n# 3.1读写控制信号引脚\n\n读写控制信号用来控制cpu对存储和i/o设备的读写过程：控制数据传输方向（读/写）、传输种类（存储器还是i/o设备）；读写方式（奇地址字节/偶地址字节/字）；存储器i/o设备是否准好的状态信号；分时总线信号的类型等。\n\n（1）m/io存储器或i/o端口访问选择信号，三态输出：\n\n * 为高电平时，表示当前cpu正在访问存储器；\n * 为低电平时，表示cpu当前正在访问i/o端。\n\n（2）rd(read)读信号、三态输出：低电平有效，表示当前cpu正在读存储器或i/o端口。\n\n（3）mr（write）写信号，三态输出：低电平有效，表示当前cpu正在写存储器或i/o端口。m/io、wr及rd合起来决定系统中数据传输方向。\n\n（4）ready准备就绪信号：由外部设备输入\n\n * 高电平有效，表示cpu访问的存储器或i/o端口已准备好传送数据。\n * 当ready无效时，要求cpu插入一个或多个等待周期tw，直到ready信号有效为止。\n\n（5）bhe/s7 总线高字节有效信号。三态输出，低电平有效。非数据传送期间，该引脚用作，输出状态信息。\n\n（6）ale地址锁存器允许信号：输出，高电平有效。表示当前地址/数据分时使用的引脚上正在输出地址信号。向地址锁存器8282提供地址锁存信号。\n\n（7 ) den 数据允许信号。三态输出，低电平有效。表示当前地址/数据分时使用的引脚上正在传输数据信号。8286将它作为输出允许信号。进行dma传输时，被置为高阻态。\n\n（8） dt/r 数据发送/接收控制信号，三态输出:\n\n * 当它为高电平时表示为数据发送，cpu写数据到存储器或io端口；\n * 为低电平时表示为数据接收，cpu从存储器或i/o端口读取数据。\n * 该信号用来控制总线收发器8286的数据传送方向。\n\n# 3.2中断控制信号引脚\n\n中断是外部设备请求cpu进行数据传输的有效方法。这一组引脚传输中断的请求和应答信号。\n\n（1）intr ：可屏蔽中断请求信号。\n\n（2）inta 中断响应信号。输出，三态，低电平有效。该信号包含两个负脉冲。外设申请可屏蔽中断，cpu响应后，在两个连续的中断响应周期发出两个负脉冲信号。第一个通知外设，cpu已经收到并且响应外部发来的intr信号(主要用于中断优先权排队)第二个要求申请中断的设备向cpu发送中断类型(代表该中断的一个编号)\n\n(3) nmi： 不可屏蔽中断请求信号。\n\n# 3.3dma控制信号引脚\n\ndma传输是一种不经过cpu，在内存和i/o设备之间直接传输数据的方法。进行dma传输之前要向cpu申请使用总线并取得认可。\n\n（1）hold总线请求信号。输入，高电平有效，表示其他设备向cpu请求使用总线。\n\n（2）hlda总线请求响应信号。输出，高电平有效。cpu在每个时钟周期都检测hold引脚，当检测到该信号，并且cpu允许其它部件占用总线，则在当前总线周期的t4状态发送hlda信号，同时让出总线使用权（所有三态总线处于高阻态，从而不影响外部的存储器与i/o设备之间交换数据）。总线申请部件接到hlda有效信号后即可接管总线进行操作，直到操作完成、撤销hold信号，cpu才重新接管总线。\n\n----------------------------------------\n\n# 3.4常用的最小模式控制总线信号归纳如下：\n\n * 控制存储器i/o端口读写的信号：\n   \n   * m/io、rd、wr、bhe、den、dt/r、ready\n\n * 用于中断联络和控制的信号：intr、inta、nmi。\n\n * 用于dma联络和控制的信号：hold，hlda。\n\n以上这些信号是构建微型计算机系统的核心，后面会反复使用。\n\n\n# 4.8086 cpu的工作时序\n\n# 4.1 8086 cpu复位操作时序\n\nreset信号\n\n当cpu接收到有效的reset信号且至少维持4个时钟周期，不管之前在执行什么动作，只要正常供电，8086就结束现行操作，进入复位状态，直到reset信号失效。在复位状态下，cpu内部的各寄存器被置为缺省值。\n\n寄存器        复位后默认值\ncs         ffffh\nip         0000h\nds,ss,es   0000h\nflags      0000h\n指令队列       清空\n其他寄存器      0000h\n\n缺省的cs和ip的内容，通过地址加法器得到ffff0h，这就是复位后的第一条指令地址。\n\nffff0h处存放了一条无条件转移指令，用来转移到固化在主板bios里的一段系统程序的入口。这样，系统一旦被启动仍自动进入程序，开始正常工作。\n\n复位时，fr被清空，if = 0, 此时不接受intr信号\n\n复位时，所有三态输出总线变为高阻状态。\n\n# 4.2最小模式下的总线读周期\n\n8086 cpu完成存储器外设端口读取数据的操作时序。\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第一章、计算机基础知识",frontmatter:{title:"第一章、计算机基础知识",date:"2021-05-16T15:30:00.000Z",permalink:"/smc/1/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/60.SMC/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"60.SMC/02.第一章计算机基础知识.md",key:"v-a66c34a6",path:"/smc/1/",headers:[{level:2,title:"1. 数制",slug:"_1-数制",normalizedTitle:"1. 数制",charIndex:288},{level:3,title:"1.1数制的基与权",slug:"_1-1数制的基与权",normalizedTitle:"1.1数制的基与权",charIndex:333},{level:3,title:"1.2编码",slug:"_1-2编码",normalizedTitle:"1.2编码",charIndex:1666},{level:3,title:"1.3ASCII奇偶校验",slug:"_1-3ascii奇偶校验",normalizedTitle:"1.3ascii奇偶校验",charIndex:11915},{level:3,title:"1.4计算机中的二进制数表示",slug:"_1-4计算机中的二进制数表示",normalizedTitle:"1.4计算机中的二进制数表示",charIndex:12126},{level:3,title:"1.5计算机能力的有限性",slug:"_1-5计算机能力的有限性",normalizedTitle:"1.5计算机能力的有限性",charIndex:13816},{level:2,title:"2. 逻辑电路",slug:"_2-逻辑电路",normalizedTitle:"2. 逻辑电路",charIndex:15031},{level:3,title:"2.1”与非“逻辑",slug:"_2-1-与非-逻辑",normalizedTitle:"2.1”与非“逻辑",charIndex:15234},{level:3,title:"2.2“或非”逻辑",slug:"_2-2-或非-逻辑",normalizedTitle:"2.2“或非”逻辑",charIndex:15311},{level:3,title:"2.3”异或“逻辑",slug:"_2-3-异或-逻辑",normalizedTitle:"2.3”异或“逻辑",charIndex:15636},{level:3,title:"2.4”同或“逻辑",slug:"_2-4-同或-逻辑",normalizedTitle:"2.4”同或“逻辑",charIndex:15751},{level:2,title:"3. 布尔代数",slug:"_3-布尔代数",normalizedTitle:"3. 布尔代数",charIndex:15870},{level:3,title:"3.1“或”运算（OR）",slug:"_3-1-或-运算-or",normalizedTitle:"3.1“或”运算（or）",charIndex:16153},{level:3,title:"3.2“与”运算（AND）",slug:"_3-2-与-运算-and",normalizedTitle:"3.2“与”运算（and）",charIndex:16932},{level:3,title:"3.3“反”运算",slug:"_3-3-反-运算",normalizedTitle:"3.3“反”运算",charIndex:17805},{level:3,title:"3.4布尔代数的基本运算规则",slug:"_3-4布尔代数的基本运算规则",normalizedTitle:"3.4布尔代数的基本运算规则",charIndex:18399},{level:3,title:"3.5摩根定理",slug:"_3-5摩根定理",normalizedTitle:"3.5摩根定理",charIndex:18775},{level:3,title:"3.6真值及布尔代数式的关系",slug:"_3-6真值及布尔代数式的关系",normalizedTitle:"3.6真值及布尔代数式的关系",charIndex:19439},{level:2,title:"4. 二进制数的运算及其加法电路",slug:"_4-二进制数的运算及其加法电路",normalizedTitle:"4. 二进制数的运算及其加法电路",charIndex:19902},{level:3,title:"4.1二进制数的相加",slug:"_4-1二进制数的相加",normalizedTitle:"4.1二进制数的相加",charIndex:19923},{level:3,title:"4.2半加器电路",slug:"_4-2半加器电路",normalizedTitle:"4.2半加器电路",charIndex:20426},{level:3,title:"4.3全加器电路",slug:"_4-3全加器电路",normalizedTitle:"4.3全加器电路",charIndex:20743},{level:3,title:"4.4半加器及全加器符号",slug:"_4-4半加器及全加器符号",normalizedTitle:"4.4半加器及全加器符号",charIndex:20994},{level:3,title:"4.5二进制数的加法电路",slug:"_4-5二进制数的加法电路",normalizedTitle:"4.5二进制数的加法电路",charIndex:21013},{level:3,title:"4.6二进制数的减法运算",slug:"_4-6二进制数的减法运算",normalizedTitle:"4.6二进制数的减法运算",charIndex:21245},{level:3,title:"4.7可控反相器及加法/减法电路",slug:"_4-7可控反相器及加法-减法电路",normalizedTitle:"4.7可控反相器及加法/减法电路",charIndex:21348}],headersStr:"1. 数制 1.1数制的基与权 1.2编码 1.3ASCII奇偶校验 1.4计算机中的二进制数表示 1.5计算机能力的有限性 2. 逻辑电路 2.1”与非“逻辑 2.2“或非”逻辑 2.3”异或“逻辑 2.4”同或“逻辑 3. 布尔代数 3.1“或”运算（OR） 3.2“与”运算（AND） 3.3“反”运算 3.4布尔代数的基本运算规则 3.5摩根定理 3.6真值及布尔代数式的关系 4. 二进制数的运算及其加法电路 4.1二进制数的相加 4.2半加器电路 4.3全加器电路 4.4半加器及全加器符号 4.5二进制数的加法电路 4.6二进制数的减法运算 4.7可控反相器及加法/减法电路",content:'# 第一章、计算机基础知识\n\n一、微型计算机基础\n（一）知识范围\n微型计算机的基本组成及各部分的功能与作用；\n微型机的基本工作过程；\n计算机中的编码、数制及其转换；\n无符号二进制数的算术运算和逻辑运算；\n运算中的溢出；\n机器数的表示及运算；\n基本逻辑门及常用逻辑部件。\n（二）考核要求\n1.\t理解微处理器、微型计算机和微型计算机系统的概念及其相互关系。\n2.\t理解微机系统各部件的功能分工及计算机的工作过程。\n3.\t掌握计算机中各种信息的表示及运算。\n4.\t熟悉基本逻辑门及常用逻辑部件的使用。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 1. 数制\n\n数制是人们用来记数的科学方法。如：十六进制、十进制、八进制、二进制\n\n\n# 1.1数制的基与权\n\n数制所使用的数码个数称为基；数制每一位所具有的值称为权。\n\n例如 ：\n\n * 二进制的基为 ：2，即其使用的数码为 0,1,共两个。\n * 二进制各位的权是以2为低的幂，如下面这个数：\n\n二进制 ：1 \t\t1 \t\t0 \t\t1 \t\t1 \t\t1\n\t(2^5)*1+(2^4)*1+(2^3)*0+(2^2)*1+(2^1)*1+(2^0)*1\n十进制 ：32\t\t16\t\t8\t\t4\t\t2\t\t1\n\n\n1\n2\n3\n\n\n其各位的权为1，2，4，8，16，32，即以2为底的0次幂，1次幂，2次幂等，故有时也依次称其各位为0权位，1权位，2权位等。\n\n其他进制同上。\n\n为什么要用二进制？\n\n电路通常只有两种稳态：导通与阻塞、饱和与截止、高电位与低电位等。具有两个稳态的电路称为二值电路。因此,用二值电路来计数时，只能代表两个数码：0和1。如以1代表高电位，则0代表低电位，所以，采用二进制，可以利用电路进行计数工作。而用电路来组成计算机，则有运算迅速、电路简便、成本低廉等优点。\n\n为什么要用十六进制\n\n用十六进制既可简化书写,又便于记忆。\n\n有用字母符号来表示这些数制的：\n\nB——二进制：0，1\n\nO——八进制：0，1，2，3，4，5，6，7\n\nD—— 十进制：0，1，2，3，4，5，6，7，8，9\n\nH——十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F\n\n数制的转换方法\n\n十进制数到非十进制数的转换\n\n * 对二进制的转换\n   * 对整数：除2取余\n   * 对小数：乘2取整\n * 对八进制的转换\n   * 对整数：除8取余\n   * 对小数：乘8取整\n * 对十六进制的转换\n   * 对整数：除16取整\n   * 对小数：乘16取整\n\n非十进制数与二进制数的转换\n\n * 十六进制数与二进制的转换\n   * 用4为二进制数表示一位十六进制数\n   * 整数部分，从小数点向左，每4位一组，不够4位的高位补0。\n   * 小数部分，从小数点向右，每4位一组，不够4位的高位补0。\n\n例：\n\n25.5D = 11001.1B\n11001.1B = 0001 1001.1000B\n\t\t   ---- ---- ----\n\t\t   \t 1\t  9  . 8 H\n\n\n1\n2\n3\n4\n\n * 八进制数与二进制的转换\n   * 用3为二进制数表示一位八进制数\n   * 整数部分，从小数点向左，每4位一组，不够3位的高位补0。\n   * 小数部分，从小数点向右，每4位一组，不够3位的高位补0。\n\n例：\n\n11001010.0110101B=011 001 010.011 010 100B\n\t\t\t\t  --- --- --- --- --- ---\n\t\t\t\t   3   1   2  . 3  2   4  O\n\n\n1\n2\n3\n\n\n注意事项： (1)一个二进制数可以准确地转换为十进制数，而一个带小数的十进制数不一定能够准确地用二进制数来表示。 (2)带小数的十进制数在转换为二进制数时，以小数点为界，整数和小数要分别转换。\n\n----------------------------------------\n\n\n# 1.2编码\n\n * 信息从一种形式或格式转换为另一种形式的过程\n * 用代码来表示各种信息，以便计算机处理\n\n计算机中的编码\n\n * 数值编码\n   * 二进制编码\n   * BCD编码\n * 西文字符编码\n   * ASCII编码\n\nBCD编码：\n\n * 用二进制表示十进制数\n * 特点：保留十进制的权，数字用0和1表示。\n * 8421BCD编码：\n   * 用4为二进制码表示一位十进制数，每4位之间有一个空格\n   * 注意：1010~1111是非法BCD码，只是合法的十六进制数\n * BCD码与十进制数之间存在直接对应关系，例如：\n\n(1001 1000 0110.0011)BCD = 986.3\n----- ---- ---- ----\n   |    |    |    |\n   9\t8\t 6\t. 3\n\n\n1\n2\n3\n4\n\n * BCD码与二进制的转换：先转换为十进制数，再转换为二进制数；反之同样。\n * 以压缩BCD码形式存放：\n   * 用4位二进制码表示1位BCD码\n   * 一个存储单元中存放2位BCD数\n * 以扩展BCD码形式存放\n   * 用8位二进制码表示1位BCD码，即高4位为0，第四位为有效位\n   * 每个存储单元存放1位BCD\n\n西文字符编码（ASCII编码）\n\n将每个字母、数字、标点、控制符用1Byte二进制码表示，其中：标准ASCII的有效位：7Byte，最高默认为0。\n\nASCII 编码一览表\n\n二进制        十进制   十六进制   字符/缩写                                          解释\n00000000   0     00     NUL (NULL)                                     空字符\n00000001   1     01     SOH (Start Of Headling)                        标题开始\n00000010   2     02     STX (Start Of Text)                            正文开始\n00000011   3     03     ETX (End Of Text)                              正文结束\n00000100   4     04     EOT (End Of Transmission)                      传输结束\n00000101   5     05     ENQ (Enquiry)                                  请求\n00000110   6     06     ACK (Acknowledge)                              回应/响应/收到通知\n00000111   7     07     BEL (Bell)                                     响铃\n00001000   8     08     BS (Backspace)                                 退格\n00001001   9     09     HT (Horizontal Tab)                            水平制表符\n00001010   10    0A     LF/NL(Line Feed/New Line)                      换行键\n00001011   11    0B     VT (Vertical Tab)                              垂直制表符\n00001100   12    0C     FF/NP (Form Feed/New Page)                     换页键\n00001101   13    0D     CR (Carriage Return)                           回车键\n00001110   14    0E     SO (Shift Out)                                 不用切换\n00001111   15    0F     SI (Shift In)                                  启用切换\n00010000   16    10     DLE (Data Link Escape)                         数据链路转义\n00010001   17    11     DC1/XON (Device Control 1/Transmission On)     设备控制1/传输开始\n00010010   18    12     DC2 (Device Control 2)                         设备控制2\n00010011   19    13     DC3/XOFF (Device Control 3/Transmission Off)   设备控制3/传输中断\n00010100   20    14     DC4 (Device Control 4)                         设备控制4\n00010101   21    15     NAK (Negative Acknowledge)                     无响应/非正常响应/拒绝接收\n00010110   22    16     SYN (Synchronous Idle)                         同步空闲\n00010111   23    17     ETB (End of Transmission Block)                传输块结束/块传输终止\n00011000   24    18     CAN (Cancel)                                   取消\n00011001   25    19     EM (End of Medium)                             已到介质末端/介质存储已满/介质中断\n00011010   26    1A     SUB (Substitute)                               替补/替换\n00011011   27    1B     ESC (Escape)                                   逃离/取消\n00011100   28    1C     FS (File Separator)                            文件分割符\n00011101   29    1D     GS (Group Separator)                           组分隔符/分组符\n00011110   30    1E     RS (Record Separator)                          记录分离符\n00011111   31    1F     US (Unit Separator)                            单元分隔符\n00100000   32    20     (Space)                                        空格\n00100001   33    21     !                                              \n00100010   34    22     "                                              \n00100011   35    23     #                                              \n00100100   36    24     $                                              \n00100101   37    25     %                                              \n00100110   38    26     &                                              \n00100111   39    27     \'                                              \n00101000   40    28     (                                              \n00101001   41    29     )                                              \n00101010   42    2A     *                                              \n00101011   43    2B     +                                              \n00101100   44    2C     ,                                              \n00101101   45    2D     -                                              \n00101110   46    2E     .                                              \n00101111   47    2F     /                                              \n00110000   48    30     0                                              \n00110001   49    31     1                                              \n00110010   50    32     2                                              \n00110011   51    33     3                                              \n00110100   52    34     4                                              \n00110101   53    35     5                                              \n00110110   54    36     6                                              \n00110111   55    37     7                                              \n00111000   56    38     8                                              \n00111001   57    39     9                                              \n00111010   58    3A     :                                              \n00111011   59    3B     ;                                              \n00111100   60    3C     <                                              \n00111101   61    3D     =                                              \n00111110   62    3E     >                                              \n00111111   63    3F     ?                                              \n01000000   64    40     @                                              \n01000001   65    41     A                                              \n01000010   66    42     B                                              \n01000011   67    43     C                                              \n01000100   68    44     D                                              \n01000101   69    45     E                                              \n01000110   70    46     F                                              \n01000111   71    47     G                                              \n01001000   72    48     H                                              \n01001001   73    49     I                                              \n01001010   74    4A     J                                              \n01001011   75    4B     K                                              \n01001100   76    4C     L                                              \n01001101   77    4D     M                                              \n01001110   78    4E     N                                              \n01001111   79    4F     O                                              \n01010000   80    50     P                                              \n01010001   81    51     Q                                              \n01010010   82    52     R                                              \n01010011   83    53     S                                              \n01010100   84    54     T                                              \n01010101   85    55     U                                              \n01010110   86    56     V                                              \n01010111   87    57     W                                              \n01011000   88    58     X                                              \n01011001   89    59     Y                                              \n01011010   90    5A     Z                                              \n01011011   91    5B     [                                              \n01011100   92    5C     \\                                              \n01011101   93    5D     ]                                              \n01011110   94    5E     ^                                              \n01011111   95    5F     _                                              \n01100000   96    60     `                                              \n01100001   97    61     a                                              \n01100010   98    62     b                                              \n01100011   99    63     c                                              \n01100100   100   64     d                                              \n01100101   101   65     e                                              \n01100110   102   66     f                                              \n01100111   103   67     g                                              \n01101000   104   68     h                                              \n01101001   105   69     i                                              \n01101010   106   6A     j                                              \n01101011   107   6B     k                                              \n01101100   108   6C     l                                              \n01101101   109   6D     m                                              \n01101110   110   6E     n                                              \n01101111   111   6F     o                                              \n01110000   112   70     p                                              \n01110001   113   71     q                                              \n01110010   114   72     r                                              \n01110011   115   73     s                                              \n01110100   116   74     t                                              \n01110101   117   75     u                                              \n01110110   118   76     v                                              \n01110111   119   77     w                                              \n01111000   120   78     x                                              \n01111001   121   79     y                                              \n01111010   122   7A     z                                              \n01111011   123   7B     {                                              \n01111100   124   7C     |                                              \n01111101   125   7D     }                                              \n01111110   126   7E     ~                                              \n01111111   127   7F     DEL (Delete)                                   删除\n\n需要记住的：\n\n * 0~9 十进制ASCII编码 48~57\n * A~Z 十进制ASCII编码 65~90\n * a~z 十进制ASCII编码 97~122\n * 大写字母与小写字母相差 32\n\n----------------------------------------\n\n\n# 1.3ASCII奇偶校验\n\n * 奇校验\n   * 加上校验位后编码中 “1” 的个数为奇数。\n   * 例如：A的ASCII编码是41H（1000001B）\n     * 以奇校验传送则为C1H（11000001B）\n * 偶校验\n   * 加上校验位编码中 “1” 的个数为偶数。\n   * 上例若以偶校验传送，则为41H。\n\n----------------------------------------\n\n\n# 1.4计算机中的二进制数表示\n\n数的表示方法：\n\n * 定点数\n   * 定点整数\n   * 定点小数\n * 浮点数\n\n定点数：\n\n * 编程时需要确定小数位置\n * 难以表示两个大小相差较大的数\n * 存储空间利用率低\n\n浮点数：\n\n * 小数的位置可以左右移动\n * 规格化浮点数\n   * 尾数部分用纯小数表示，即小数点右边第一位不为0\n\n----------------------------------------\n\n数的性质：\n\n * 无符号数\n   * 数中所有0和1都是数据本身\n   * 运算：\n\n加法：\n\t1 + 1 = 0（有进位）\n减法：\n\t0 - 1 = 1（有错位）\n乘法：\n\t00001011*0100 = 00101100B（向左移了两位）\n除法：\n\t00001011/0100 = 00000010B（向右移动两位）\n\t商数：00000010B 余数：-11B\n=====================================================================\n每乘以2，相对于被乘数向左移动1位\n每除以2，相对于被除数向右移动1位\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 有符号数\n   * 需要0或1表示数的性质（整数或负数）\n   * 最高位表示符号，其余是数值\n   * 符号数的表示方法：\n\n- 原码：最高位为符号位，其余为真值部分\n【X】原=符号位+|绝对值|\n优点：真值和其源码表示之间的对应关系简单，容易理解；\n缺点：\n1. 计算机中用源码进行加减运算比较困难\n2. 0的表示不唯一\n\n数0的原码：\n8位数0的原码：\n【+0】原= 0 0000000\n【-0】原= 1 0000000\n数0的原码不唯一\n**************************************\n- 反码\n对于一个机器数x：\n若x>0,则【x】反=【x】原\n若x<0,则【x】反=对应源码的符号位不变，数值部分按位求反。\n例：\nx= -52 = -0110100\n【x】原= 10110100\n【x】反= 11001011\n\n数0的反码：\n【+0】反=【+0】原= 00000000\n【-0】原= 10000000\n【-0】反= 【-0】数值部分按位取反= 11111111\n即：数0的反码也不唯一的\n****************************************\n- 补码\n若x>0,则【x】补=【x】反=【x】原\n若x<0,则【x】补=【x】反+1\n例：\nx= -52 = -0110100\n【x】原= 10110100\n【x】反= 11001011\n【x】补= 11001100\n\n0的补码：\n【+0】补=【+0】原= 00000000\n【-0】补=【-0】反+1= 11111111+1 = 1 00000000（对八位字长，进位被舍掉）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n补码的算数运算\n\n * 通过引进补码，可将减法运算转换位为加法运算。\n * 即：\n\n【x+y】补=【x】补+【y】补\n【x-y】补=【x+（-y）】补=【x】补+【-y】补\n\n\n1\n2\n\n\n特殊数\n\n * 对无符号数：\n   * (10000000)B = 128\n * 在原码中定义为：\n   * (10000000)B = -0\n * 在反码中定义为：\n   * (10000000)B = -127\n * 在补码中定义为：\n   * (10000000)B = -128\n\n数的性质由设计者决定\n\n在低级语言程\n\n序设计中，根据数的性质由程序语言处理（按无符号数或有符号数处理）。\n\n----------------------------------------\n\n\n# 1.5计算机能力的有限性\n\n * 计算机的运行能力是有限的\n   * 计算机无力解决无法设计出算法的问题\n   * 无法处理无穷运算或连续变化的信息\n * 计算机能够表示的数（表数）的范围是有限的\n   * 计算机的表数范围受字长的限制\n   * 例如：对8位机\n     * 无符号数的最大值：1111 1111\n     * 有符号正整数的最大值：0111 1111\n\n----------------------------------------\n\n当运算结果超出计算机表数范围时，将产生溢出\n\n * 无符号整数的表示范围：\n   \n   * 当计算机中数的运行结果超出表述范围时，则产生溢出。\n   * 无符号整数的表数范围：0 <= x <= [2^(n-1)],n表示字长\n   * 无符号数加减运算溢出的判断方法：\n     * 当最高位向更高位有进位（或借位）时则产生溢出\n\n * 有符号整数的表示范围：\n   \n   * 原码和反码：[2^(n-1)]-1 <= x <= [2^(n-1)]-1\n   * 补码：[2^(n-1)] <= x <= [2^(n-1)]-1\n   * 对于8位二进制数：\n     * 原码：-127~+127\n     * 反码：-127~+127\n     * 补码：-128~+127\n\n * 符号数运算中的溢出判断\n   \n   * 两个符号数相加或相减时，若运算结果超出可表达范围，则产生溢出\n   * 溢出的判断方法：\n     * 最高位进位状态和次高位进位状态不一样，则结果溢出\n     * 除法运算溢出时，产生“除数为0”中断\n     * 乘法运算无溢出问题\n\n----------------------------------------\n\n符号二进制数与十进制的转换\n\n转换方法：\n\n * 求出真值\n * 进行转换\n\n计算机中的符号数默认以补码形式表示。\n\n原码 = 符号位 + 绝对值\n正数的补码 = 原码 = 符号位 + 绝对值\n负数的补码 != 原码 != 符号位 + 绝对值\n\n例如：\n设：【x】补=0 010 1110B ----\x3e 真值= +010 1110B ----\x3e x = +101110B = +46\n设：【x】补=1 101 0010B ----\x3e x != -101 0010B ----\x3e 欲求x的真值，需对【x】补再取补码\n\t【【x】补】补 = [11010010]补 = -010 1110 = -46\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 对正数：补码 = 反码 = 原码，且 原码 = 符号位 + 真值\n   * 所以：正数补码的数制部分为真值\n * 对负数：补码 != 反码 != 原码\n   * 所以：负数补码的数制部分 != 真值\n\n只有原码的数值部分是真值\n\n反码和补码的数值部分都不是真值\n\n\n# 2. 逻辑电路\n\n逻辑电路由其3种基本门电路(或称判定元素)组成。图1-1是基本门电路的名称、符号及表达式。\n\n\n\n在这3个基本门电路的基础上，还可发展成如图1-2那样更复杂的逻辑电路。其中， 最后一个叫作缓冲器(buffer) ,为两个非门串联以达到改变输出电阻的目的。如果A点左边电路的输出电阻很高，则经过这个缓冲器之后，在Y点处的输出电阻就可以变得低许多倍，这样就能够提高带负载的能力。\n\n\n\n\n# 2.1”与非“逻辑\n\n即”与“运算和”非“运算的一种组合\n\n逻辑关系：!(A*B)或者!(A^B)\n\n将与门的输出接入非门的输入，构成”与非”门\n\n\n# 2.2“或非”逻辑\n\n即”或“运算和”非“运算的一种组合\n\n逻辑关系：!(A+B)或者!(AvB)\n\n将与门的输出接入非门的输入，构成”与非”门\n\n”与非门“和“或非门”小结\n\n * ”与非门“及“或非门”均为多输入单输出的门电路\n\n * 可以实现多个变量的“与非”或者“或非”运算\n\n练习：\n\n设：A=11001010，B=10101001\n计算：\n1.Y= !(A*B)\nY = ![1100 1010 * 1010 1001]=![1000 1000]= 0111 0111\n2.Y= !(A+B)\nY = ![1100 1010 + 1010 1001]=![1110 1011]= 0001 0100\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3”异或“逻辑\n\n“异或”逻辑关系是在与、或、非3种基本逻辑运算基础上的变换。\n\n异或逻辑的布尔代数表达式：F=(!A)*B+A*(!B)=A⊕B\n\n“异或”运算是两个变量的运算\n\n运算规则：相同则为0，相异则为1。\n\n\n# 2.4”同或“逻辑\n\n”同或“运算是在”异或“运算的基础上再进行”非“运算的结果。\n\n同或运算的布尔表达式：F=![(!A)*B+A*(!B)]=!(A⊕B)\n\n“同或”运算是两个变量的运算\n\n运算规则：相同则为1，相异则为0。\n\n\n# 3. 布尔代数\n\n布尔代数也成为开关代数或逻辑代数，和一般线性代数一样，可以写成下面的表达式：\n\nY = f(A,B,C,D)\n\n\n1\n\n\n但它有两个特点：\n\n * 其中的A,B,C,D等均只有两种可能的数值：0或1。布尔代数变量的数值并无大小之意，只代表事务的两个不同属性。如用于开关，则：0代表关（断路）或低电位；1代表开（通路）或高电位。如用于逻辑推理，则：0代表错误（假）；1代表正确（真）。\n * 函数 f 只有3种基本方式：“或”运算、“与”运算、“反”运算。\n\n----------------------------------------\n\n\n# 3.1“或”运算（OR）\n\n由于A,B只有0或1的可能取值，所以其各种可能结果如下：\n\nY=0+0=0 → Y=0\n\nY=0+1=1 |\nY=1+0=1 |→ Y=1\nY=1+1=1 |\n\n\n1\n2\n3\n4\n5\n\n\n上述第4个式子与一般的代数加法不符,这是因为Y也只能有两种数值：0或1。\n\n面4个式子可归纳成两句话：两者皆伪者则结果必伪，有一为真者则结果必真。\n\n这个结论也可推广至多变量：A,B,C,D...,各变量全假者则结果必假，有一为真者则结果必真。\n\n在输入的“或”门电路中，只要其中有一个输入为1，则其输入必为1。或者说只有全部输入均为0时，输出才为0。\n\n或运算有时也称为“逻辑或”。当A和B为多位二进制数时，如：\n\nA=A1A2A3....An\nB=B1B2B3....Bn\n\n则进行“逻辑或”运算时,各对应位分别进行“或”运算:\nY =A+B\n=(A1 + B1)(A2 + B2)(A3 + B3)...(An + Bn)\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意： 1 “或” 1等于1，是没有进位的。\n\n例如：\n\n设 A =10101,B =11011,则Y=A+B\nY=(1 + 1)(0 + 1)(1 + 0)(0 + 1)(1 + 1) = 11111\n写成竖式则为:\n  10101\n+ 11011\n--------\n  11111\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总结：\n\n * 输入条件中有一个为”真“，则输出的结果为”真“\n\n * 仅当输入条件全部为“假”时，输出结果才为“假”\n\n * ”或“运算符号：+、v\n\n * 在电路中，”或“运算相当于开关的并联电路\n   \n   * 仅当所有开关都断开时，电路才无电流通过。\n\n\n\n----------------------------------------\n\n\n# 3.2“与”运算（AND）\n\n根据A和B的取值(0或1)可以写出下列各种可能的运算结果：\n\nY=0*0=0|\nY=1*0=0|→ Y=0\nY=0*1=0|\n\nY=1*1=1 → Y=1\n\n\n1\n2\n3\n4\n5\n\n\n这种运算结果也可归纳成两句话：二者为真者结果必真，有一为假者结果必假。\n\n同样，这个结论也可推广至多变量：各变量均为真者结果必真，有一为假者结果必假。\n\n在多输入“与”门电路中，只要其中一个输入为0，则输出必为0，或者说,只有全部输入均为1时，输出才为1。\n\n与运算有时也称为“逻辑与”。当A和B为多位二进制数时，如:\n\nA=A1A2A3....An\nB=B1B2B3....Bn\n则进行“逻辑与”运算时,各对应位分别进行“与”运算:\nY=A * B = (A1 * Bl)(A2 * B2)(A3 * B3)...(An* Bn)\n\n例如:设A=11001010，B = 00001111，则Y = A * B\nY = (1 * 0)(1 * 0)(0 * 0)(0 * 0)(1 * 1)(0 * 1)(1 * 1)(0 * 1)= 00001010\n写成竖式则为：\n  11001010\n* 00001111\n-----------\n  00001010\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n由此可见，用“0”和一个数位相“与”，就是将其‘‘抹掉”而成为“0”；用“1”和一个数位相“与”，就是将此数位“保存”下来。\n\n这种方法在计算机的程序设计中经常会用到，称为“屏蔽”。\n\n上面的B数(0000 1111)称为“屏蔽字”，它将A数的高4位屏蔽起来，使其都变成0了。\n\n总结：\n\n * 仅当输入条件全部为“真”时，输出的结果为“真”\n * 若输入条件有一个为“假”时，则输出结果为假\n * “与“运算符号：*、^\n * 在电路中，与运算相当于开关的串联电路\n   * 仅当所有开关闭合时，电路才通路。\n\n\n\n----------------------------------------\n\n\n# 3.3“反”运算\n\n又称”非“运算\n\n如果一件事物的性质为A，则其经过“反”运算之后，其性质必与A相反，用表达式表示为：\n\nY = !A\n\n\n1\n\n\n这实际，上也是反相器的性质。所以在电路实现上，反相器是反运算的基本元件。反运算也称为“逻辑非”或“逻辑反”。\n\n当A为多位数时,如:\nA = A1A2A3...An\n则其“逻辑反”为:\nY= !A1!A2!A3...!An\n设: A=1101 0000\n则: Y=0010 1111\n\n\n1\n2\n3\n4\n5\n6\n\n\n即：按位取反。\n\n总结：\n\n * 当决定事件结果的条件满足时，事件不发生。\n * ”非“属于单边运算，只有一个运算对象，运算符作为一条上横线（这里我用!代替上横线）\n * 在电路，非运算相当于短路\n   * 当开关断开时灯亮，开关闭合时灯灭。\n\n\n\n----------------------------------------\n\n小结：\n\n逻辑运算于数学运算的区别：\n\n * 算数运算是两个数之间的运算，低位运算结果将对高位运算产生影响\n * 逻辑运算是按位进行的运算，低位运算结果对于高位运算不产生影响\n\n当”与“门的输入段有1位为低电平（0）时，则输出为”0“\n\n当”或“门的输入端有1位为高电平（1）时，则输出为”1“\n\n----------------------------------------\n\n\n# 3.4布尔代数的基本运算规则\n\n * 恒等式\n\nA * 0 = 0\tA * 1 = A\tA * A = A\nA + 0 = A\tA + 1 = 1\tA + A = A\nA + !A = 1\tA * !A = 0\t!A = A\n\n\n1\n2\n3\n\n * 运算规律\n   * 与普通代数一样，布尔代数也有交换律、结合律、分配律，而且它们与普通代数的规律完全相同。\n\n1.交换律：A * B = B * A\n\t\t A + B = B + A\n2.结合律：(AB)C=A(BC)=ABC\n\t\t (A+B)+C = A+(B+c) = A+B+C\n3.分配律：A(B+C)=AB+AC\n\t\t (A+B)(C+D) = AC+AD+BC+BD\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 3.5摩根定理\n\n在电路设计时，人们手边有时没有“与”门，而只有"或"门和“非”门；或者只有“与”门和“非”门，没有“或”门。利用摩根定理，可以解决元件互换的问题。\n\n二变量的摩根定理为：\n\n!(A+B) = !A * !B\n!(A*B) = !A + !B\n推广到多变量：\n!(A+B+C...) = !A * !B * !C *...\n!(A*B*C...) = !A + !B + !C +...\n\n\n1\n2\n3\n4\n5\n\n\n可以用表格验证此定理\n\n--------------------------------------\nA\tB\t!(A+B)\t!A*!B\t!(A*B)\t!A+!B\n--------------------------------------\n0\t0\t   1  \t  1  \t   1  \t   1\n0\t1\t   0  \t  0  \t   1  \t   1\n1\t0\t   0  \t  0 \t   1  \t   1\n1\t1\t   0  \t  0  \t   0  \t   0\n------   -------------   -------------\n   ↓\t\t\t↓\t\t\t\t↓\n变量可能取值\t   相等\t\t\t  相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个定义可以用一句话来记忆：\n\n头上切一刀（指的是【!(A+B)或!(A*B)】），下面变个号（指的是运算符号由*变+【或由+变*】）。\n\n----------------------------------------\n\n\n# 3.6真值及布尔代数式的关系\n\n当人们遇到一个因果问题时，常常把各种因素全部考虑进去,然后再研究结果。真值表也就是这种方法的一种表格形式。\n\n例如，考虑两个一位的二进制数A和B相加，其本位的和S及向高一位进位C的结果如何?\n\n全面考虑两个一位二进制数,可能出现四种情况:或A=0,B=0;或A=0,B=1;或 A=1,B=0;或A=1,B=1(一般n个因素可有2n种情况)。这实质是两个一位数(可为零,也可为1)的排列。我们可以把它们列人表内,如真值表左边部分所示。然后，对每一种情况进行分析。当A和B都为0时,S为0,进位C也为0;当A为0且B为1时,S为1,进位C为0;当A为1且B为0时,S为1,进位C为0;当A为1且B也为1时,由于S是一位数所以为0,而有进位C=1。\n\n真值表\n\nA   B   S   C\n0   0   0   0\n0   1   1   0\n1   0   1   0\n1   1   0   1\n\n逻辑问题(二进制数相加的运算由于取值只能为1,0,所以可以转化为逻辑问题)的真值表。\n\n\n# 4. 二进制数的运算及其加法电路\n\n\n# 4.1二进制数的相加\n\n\n\n从以上例子可得出下列结论:\n\n(1)两个二进制数相加时，可以逐位相加。如二进制数可以写成：\n\nA = A3A2A1A0\nB = B3B2B1B0\n\n\n1\n2\n\n\n则从最右边第1位(即0权位)开始，逐位相加，其结果可以写成：\n\nS = S3S2S1S0\n\n\n1\n\n\n其中各位是分别求出的:\n\nS0=A0+B0 → 进位C1\n\nS1=A1+B1+C1 → 进位C2\n\nS2=A2+B2+C2 → 进位C3\n\nS3=A3+B3+C3 → 进位C4;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最后所得的和是：\n\nC4S3S2S1=A+B\n\n\n1\n\n\n(2)右边第1位相加的电路要求：\n\n * 输入量为两个，即A0及B0;\n\n * 输出量为两个，即S0及C1。\n\n这样的一个二进制位相加的电路称为半加器(half adder)。\n\n(3)从右边第2位开始，各位可以对应相加。各位对应相加时的电路要求：\n\n * 输人量为3个，即Ai，Bi，Ci\n\n * 输出量为两个，即Si，Ci+1。\n\n其中i=1,2,3,..,n。这样的一个二进制位相加的电路称为全加器(full adder)。\n\n\n# 4.2半加器电路\n\n要求有两个输入端，用以两个代表数字(A0，B0)的电位输入；有两个输出端，用以输出总和S0及进位C1。\n\n这样的电路可能出现的状态可以用图1-4中的表来表示。此表在布尔代数中称为真值表。\n\n考察一下C与A0及B0之关系，即可看出这是“与”的关系，即：\n\nC1=A0*B0\n\n\n1\n\n\n再看一下S0与A0及B0之关系，也可看出这是“异或”的关系，即：\n\nS0=A0⊕B0\n=(!A0)B0+A0(!B0)\n\n\n1\n2\n\n\n即只有当A0及B0二者相异时，才起到或的作用；二者相同时，则其结果为0。因此，可以用“与门”及“异或门”(或称“异门”)来实现真值表的要求。图1-4就是这个真值表及半加器的电路图。\n\n\n\n\n# 4.3全加器电路\n\n全加器电路的要求是：有3个输人端，以输入A赋给Ai，Bi和Ci，有两个输出端，即Si及Ci+1。\n\n其真值表可以写成如图1-5所示。由此表分析可见,其总和Si可用“异或门”来实现，而其进位Ci+1则可以用3个“与门”及一个“或门”来实现，其电路图也画在图1-5中。\n\n\n\n这里遇到了3个输人的“异或门”的问题。如何判断多输人的“异或门”的输人与输出的关系呢?\n\n判断的方法是：多输入A,B,C,D,...中为“1”的输人量的个数为零及偶数时，输出为0；为奇数时，输出为1。\n\n\n# 4.4半加器及全加器符号\n\n\n\n\n# 4.5二进制数的加法电路\n\n设：\nA = 1010 =10（D）\nB = 1011 =11（D）\n\n\n1\n2\n3\n\n\n则可安排如图1-7所示的加法电路。\n\n\n\nA与B相加，写成竖式算法如下：\n\nA:   1 0 1 0\nB:   1 0 1 1 (+\n----------------\nS: 1 0 1 0 1\n\n\n1\n2\n3\n4\n\n\n即其相加结果为S=10101。\n\n从加法电路，可以看到同样的结果：S = C4 S3 S2 S1 S0 = 10101\n\n\n# 4.6二进制数的减法运算\n\n在微型计算机中，没有专用的减法器，而是将减法运算改变为加法运算。\n\n其原理是：将减数B变成其补码后，再与被减数A相加，其和（如有进位的话，则舍去进位）就是两数之差。\n\n\n\n\n# 4.7可控反相器及加法/减法电路\n\n利用补码可将减法变为加法来运算，因此需要有这么一个电路，它能将原码变成反码，并使其最小位加1。\n\n图1-8的可控反相器就是为了使原码变为反码而设计的。\n\n\n\n这实际上是一个异或门（异门），两输入端的异或门的特点是：两者相同则输出为0，两者不同则输出为1。用真值表来表示这个关系,更容易看到其意义(表1-3)。\n\n由此真值表可见，如将 SUB端看作控制端，则当在SUB端加上低电位时，Y端的电平就和B0端的电平相同。在SUB端加上高电平，则Y端的电平和B0端的电平相反。\n\n可控相反器的真值表（表1-1）\n\nSUB   B0   Y   Y与B0的关系   \n0     0    0   Y与B0相同    相同\n0     1    1   Y与B0相同    相同\n1     0    1   Y与B0相反    相反\n1     1    0   Y与B0相反    相反\n\n利用这个特点，在图1-7的4位二进制数加法电路上增加4个可控反相器并将最低位的半加器也改用全加器，就可以得到如图1-9的4位二进制数加法器/减法器电路了，因为这个电路既可以作为加法器电路（当SUB = 0），又可以作为减法器电路（当SUB=1）。 如果有下面两个二进制数：\n\nA = A3 A2 A1 A0\nB = B3 B2 B1 B0\n\n\n1\n2\n\n\n则可将这两个数的各位分别送入该电路的对应端，于是：\n\n * 当SUB=0时，电路作加法运算：A＋B。\n * 当SUB=1时，电路作减法运算：A - B。\n\n图1-9电路的原理如下：当SUB=0时，各位的可控反相器的输出与B的各位同相，所以图1-9和图1-7的原理完全一样，各位均按位相加。\n\n结果:S = S3 S2 S1 S0\n而其和为:C4S = C4 S3 S2 S1 S0\n\n\n1\n2\n\n\n当SUB=1，各位的反相器的输出与B的各位反相。注意，最右边第一位（即S0位）也是用全加器,其进位输人端与SUB端相连，因此其C0 = SUB = 1。\n\n所以此位的相加即为：\n\nA0 + (!B0) + 1\n\n其他各位为:\nA1 + (!B1) + C1\nA2 + (!B2) + C2\nA3 + (!B3) + C3\n\n因此其总和输出S=S3 S2 S1 S0,即:\nS = A + (!B) + 1\n  = A3 A2 A1 A0 + (!B3) (!B2) (!B1) (!B0) + 1\n  = A + B\'\n  = A - B\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当然，此时C4如不等于0，则要被舍去。',normalizedContent:'# 第一章、计算机基础知识\n\n一、微型计算机基础\n（一）知识范围\n微型计算机的基本组成及各部分的功能与作用；\n微型机的基本工作过程；\n计算机中的编码、数制及其转换；\n无符号二进制数的算术运算和逻辑运算；\n运算中的溢出；\n机器数的表示及运算；\n基本逻辑门及常用逻辑部件。\n（二）考核要求\n1.\t理解微处理器、微型计算机和微型计算机系统的概念及其相互关系。\n2.\t理解微机系统各部件的功能分工及计算机的工作过程。\n3.\t掌握计算机中各种信息的表示及运算。\n4.\t熟悉基本逻辑门及常用逻辑部件的使用。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 1. 数制\n\n数制是人们用来记数的科学方法。如：十六进制、十进制、八进制、二进制\n\n\n# 1.1数制的基与权\n\n数制所使用的数码个数称为基；数制每一位所具有的值称为权。\n\n例如 ：\n\n * 二进制的基为 ：2，即其使用的数码为 0,1,共两个。\n * 二进制各位的权是以2为低的幂，如下面这个数：\n\n二进制 ：1 \t\t1 \t\t0 \t\t1 \t\t1 \t\t1\n\t(2^5)*1+(2^4)*1+(2^3)*0+(2^2)*1+(2^1)*1+(2^0)*1\n十进制 ：32\t\t16\t\t8\t\t4\t\t2\t\t1\n\n\n1\n2\n3\n\n\n其各位的权为1，2，4，8，16，32，即以2为底的0次幂，1次幂，2次幂等，故有时也依次称其各位为0权位，1权位，2权位等。\n\n其他进制同上。\n\n为什么要用二进制？\n\n电路通常只有两种稳态：导通与阻塞、饱和与截止、高电位与低电位等。具有两个稳态的电路称为二值电路。因此,用二值电路来计数时，只能代表两个数码：0和1。如以1代表高电位，则0代表低电位，所以，采用二进制，可以利用电路进行计数工作。而用电路来组成计算机，则有运算迅速、电路简便、成本低廉等优点。\n\n为什么要用十六进制\n\n用十六进制既可简化书写,又便于记忆。\n\n有用字母符号来表示这些数制的：\n\nb——二进制：0，1\n\no——八进制：0，1，2，3，4，5，6，7\n\nd—— 十进制：0，1，2，3，4，5，6，7，8，9\n\nh——十六进制：0，1，2，3，4，5，6，7，8，9，a，b，c，d，e，f\n\n数制的转换方法\n\n十进制数到非十进制数的转换\n\n * 对二进制的转换\n   * 对整数：除2取余\n   * 对小数：乘2取整\n * 对八进制的转换\n   * 对整数：除8取余\n   * 对小数：乘8取整\n * 对十六进制的转换\n   * 对整数：除16取整\n   * 对小数：乘16取整\n\n非十进制数与二进制数的转换\n\n * 十六进制数与二进制的转换\n   * 用4为二进制数表示一位十六进制数\n   * 整数部分，从小数点向左，每4位一组，不够4位的高位补0。\n   * 小数部分，从小数点向右，每4位一组，不够4位的高位补0。\n\n例：\n\n25.5d = 11001.1b\n11001.1b = 0001 1001.1000b\n\t\t   ---- ---- ----\n\t\t   \t 1\t  9  . 8 h\n\n\n1\n2\n3\n4\n\n * 八进制数与二进制的转换\n   * 用3为二进制数表示一位八进制数\n   * 整数部分，从小数点向左，每4位一组，不够3位的高位补0。\n   * 小数部分，从小数点向右，每4位一组，不够3位的高位补0。\n\n例：\n\n11001010.0110101b=011 001 010.011 010 100b\n\t\t\t\t  --- --- --- --- --- ---\n\t\t\t\t   3   1   2  . 3  2   4  o\n\n\n1\n2\n3\n\n\n注意事项： (1)一个二进制数可以准确地转换为十进制数，而一个带小数的十进制数不一定能够准确地用二进制数来表示。 (2)带小数的十进制数在转换为二进制数时，以小数点为界，整数和小数要分别转换。\n\n----------------------------------------\n\n\n# 1.2编码\n\n * 信息从一种形式或格式转换为另一种形式的过程\n * 用代码来表示各种信息，以便计算机处理\n\n计算机中的编码\n\n * 数值编码\n   * 二进制编码\n   * bcd编码\n * 西文字符编码\n   * ascii编码\n\nbcd编码：\n\n * 用二进制表示十进制数\n * 特点：保留十进制的权，数字用0和1表示。\n * 8421bcd编码：\n   * 用4为二进制码表示一位十进制数，每4位之间有一个空格\n   * 注意：1010~1111是非法bcd码，只是合法的十六进制数\n * bcd码与十进制数之间存在直接对应关系，例如：\n\n(1001 1000 0110.0011)bcd = 986.3\n----- ---- ---- ----\n   |    |    |    |\n   9\t8\t 6\t. 3\n\n\n1\n2\n3\n4\n\n * bcd码与二进制的转换：先转换为十进制数，再转换为二进制数；反之同样。\n * 以压缩bcd码形式存放：\n   * 用4位二进制码表示1位bcd码\n   * 一个存储单元中存放2位bcd数\n * 以扩展bcd码形式存放\n   * 用8位二进制码表示1位bcd码，即高4位为0，第四位为有效位\n   * 每个存储单元存放1位bcd\n\n西文字符编码（ascii编码）\n\n将每个字母、数字、标点、控制符用1byte二进制码表示，其中：标准ascii的有效位：7byte，最高默认为0。\n\nascii 编码一览表\n\n二进制        十进制   十六进制   字符/缩写                                          解释\n00000000   0     00     nul (null)                                     空字符\n00000001   1     01     soh (start of headling)                        标题开始\n00000010   2     02     stx (start of text)                            正文开始\n00000011   3     03     etx (end of text)                              正文结束\n00000100   4     04     eot (end of transmission)                      传输结束\n00000101   5     05     enq (enquiry)                                  请求\n00000110   6     06     ack (acknowledge)                              回应/响应/收到通知\n00000111   7     07     bel (bell)                                     响铃\n00001000   8     08     bs (backspace)                                 退格\n00001001   9     09     ht (horizontal tab)                            水平制表符\n00001010   10    0a     lf/nl(line feed/new line)                      换行键\n00001011   11    0b     vt (vertical tab)                              垂直制表符\n00001100   12    0c     ff/np (form feed/new page)                     换页键\n00001101   13    0d     cr (carriage return)                           回车键\n00001110   14    0e     so (shift out)                                 不用切换\n00001111   15    0f     si (shift in)                                  启用切换\n00010000   16    10     dle (data link escape)                         数据链路转义\n00010001   17    11     dc1/xon (device control 1/transmission on)     设备控制1/传输开始\n00010010   18    12     dc2 (device control 2)                         设备控制2\n00010011   19    13     dc3/xoff (device control 3/transmission off)   设备控制3/传输中断\n00010100   20    14     dc4 (device control 4)                         设备控制4\n00010101   21    15     nak (negative acknowledge)                     无响应/非正常响应/拒绝接收\n00010110   22    16     syn (synchronous idle)                         同步空闲\n00010111   23    17     etb (end of transmission block)                传输块结束/块传输终止\n00011000   24    18     can (cancel)                                   取消\n00011001   25    19     em (end of medium)                             已到介质末端/介质存储已满/介质中断\n00011010   26    1a     sub (substitute)                               替补/替换\n00011011   27    1b     esc (escape)                                   逃离/取消\n00011100   28    1c     fs (file separator)                            文件分割符\n00011101   29    1d     gs (group separator)                           组分隔符/分组符\n00011110   30    1e     rs (record separator)                          记录分离符\n00011111   31    1f     us (unit separator)                            单元分隔符\n00100000   32    20     (space)                                        空格\n00100001   33    21     !                                              \n00100010   34    22     "                                              \n00100011   35    23     #                                              \n00100100   36    24     $                                              \n00100101   37    25     %                                              \n00100110   38    26     &                                              \n00100111   39    27     \'                                              \n00101000   40    28     (                                              \n00101001   41    29     )                                              \n00101010   42    2a     *                                              \n00101011   43    2b     +                                              \n00101100   44    2c     ,                                              \n00101101   45    2d     -                                              \n00101110   46    2e     .                                              \n00101111   47    2f     /                                              \n00110000   48    30     0                                              \n00110001   49    31     1                                              \n00110010   50    32     2                                              \n00110011   51    33     3                                              \n00110100   52    34     4                                              \n00110101   53    35     5                                              \n00110110   54    36     6                                              \n00110111   55    37     7                                              \n00111000   56    38     8                                              \n00111001   57    39     9                                              \n00111010   58    3a     :                                              \n00111011   59    3b     ;                                              \n00111100   60    3c     <                                              \n00111101   61    3d     =                                              \n00111110   62    3e     >                                              \n00111111   63    3f     ?                                              \n01000000   64    40     @                                              \n01000001   65    41     a                                              \n01000010   66    42     b                                              \n01000011   67    43     c                                              \n01000100   68    44     d                                              \n01000101   69    45     e                                              \n01000110   70    46     f                                              \n01000111   71    47     g                                              \n01001000   72    48     h                                              \n01001001   73    49     i                                              \n01001010   74    4a     j                                              \n01001011   75    4b     k                                              \n01001100   76    4c     l                                              \n01001101   77    4d     m                                              \n01001110   78    4e     n                                              \n01001111   79    4f     o                                              \n01010000   80    50     p                                              \n01010001   81    51     q                                              \n01010010   82    52     r                                              \n01010011   83    53     s                                              \n01010100   84    54     t                                              \n01010101   85    55     u                                              \n01010110   86    56     v                                              \n01010111   87    57     w                                              \n01011000   88    58     x                                              \n01011001   89    59     y                                              \n01011010   90    5a     z                                              \n01011011   91    5b     [                                              \n01011100   92    5c     \\                                              \n01011101   93    5d     ]                                              \n01011110   94    5e     ^                                              \n01011111   95    5f     _                                              \n01100000   96    60     `                                              \n01100001   97    61     a                                              \n01100010   98    62     b                                              \n01100011   99    63     c                                              \n01100100   100   64     d                                              \n01100101   101   65     e                                              \n01100110   102   66     f                                              \n01100111   103   67     g                                              \n01101000   104   68     h                                              \n01101001   105   69     i                                              \n01101010   106   6a     j                                              \n01101011   107   6b     k                                              \n01101100   108   6c     l                                              \n01101101   109   6d     m                                              \n01101110   110   6e     n                                              \n01101111   111   6f     o                                              \n01110000   112   70     p                                              \n01110001   113   71     q                                              \n01110010   114   72     r                                              \n01110011   115   73     s                                              \n01110100   116   74     t                                              \n01110101   117   75     u                                              \n01110110   118   76     v                                              \n01110111   119   77     w                                              \n01111000   120   78     x                                              \n01111001   121   79     y                                              \n01111010   122   7a     z                                              \n01111011   123   7b     {                                              \n01111100   124   7c     |                                              \n01111101   125   7d     }                                              \n01111110   126   7e     ~                                              \n01111111   127   7f     del (delete)                                   删除\n\n需要记住的：\n\n * 0~9 十进制ascii编码 48~57\n * a~z 十进制ascii编码 65~90\n * a~z 十进制ascii编码 97~122\n * 大写字母与小写字母相差 32\n\n----------------------------------------\n\n\n# 1.3ascii奇偶校验\n\n * 奇校验\n   * 加上校验位后编码中 “1” 的个数为奇数。\n   * 例如：a的ascii编码是41h（1000001b）\n     * 以奇校验传送则为c1h（11000001b）\n * 偶校验\n   * 加上校验位编码中 “1” 的个数为偶数。\n   * 上例若以偶校验传送，则为41h。\n\n----------------------------------------\n\n\n# 1.4计算机中的二进制数表示\n\n数的表示方法：\n\n * 定点数\n   * 定点整数\n   * 定点小数\n * 浮点数\n\n定点数：\n\n * 编程时需要确定小数位置\n * 难以表示两个大小相差较大的数\n * 存储空间利用率低\n\n浮点数：\n\n * 小数的位置可以左右移动\n * 规格化浮点数\n   * 尾数部分用纯小数表示，即小数点右边第一位不为0\n\n----------------------------------------\n\n数的性质：\n\n * 无符号数\n   * 数中所有0和1都是数据本身\n   * 运算：\n\n加法：\n\t1 + 1 = 0（有进位）\n减法：\n\t0 - 1 = 1（有错位）\n乘法：\n\t00001011*0100 = 00101100b（向左移了两位）\n除法：\n\t00001011/0100 = 00000010b（向右移动两位）\n\t商数：00000010b 余数：-11b\n=====================================================================\n每乘以2，相对于被乘数向左移动1位\n每除以2，相对于被除数向右移动1位\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 有符号数\n   * 需要0或1表示数的性质（整数或负数）\n   * 最高位表示符号，其余是数值\n   * 符号数的表示方法：\n\n- 原码：最高位为符号位，其余为真值部分\n【x】原=符号位+|绝对值|\n优点：真值和其源码表示之间的对应关系简单，容易理解；\n缺点：\n1. 计算机中用源码进行加减运算比较困难\n2. 0的表示不唯一\n\n数0的原码：\n8位数0的原码：\n【+0】原= 0 0000000\n【-0】原= 1 0000000\n数0的原码不唯一\n**************************************\n- 反码\n对于一个机器数x：\n若x>0,则【x】反=【x】原\n若x<0,则【x】反=对应源码的符号位不变，数值部分按位求反。\n例：\nx= -52 = -0110100\n【x】原= 10110100\n【x】反= 11001011\n\n数0的反码：\n【+0】反=【+0】原= 00000000\n【-0】原= 10000000\n【-0】反= 【-0】数值部分按位取反= 11111111\n即：数0的反码也不唯一的\n****************************************\n- 补码\n若x>0,则【x】补=【x】反=【x】原\n若x<0,则【x】补=【x】反+1\n例：\nx= -52 = -0110100\n【x】原= 10110100\n【x】反= 11001011\n【x】补= 11001100\n\n0的补码：\n【+0】补=【+0】原= 00000000\n【-0】补=【-0】反+1= 11111111+1 = 1 00000000（对八位字长，进位被舍掉）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n补码的算数运算\n\n * 通过引进补码，可将减法运算转换位为加法运算。\n * 即：\n\n【x+y】补=【x】补+【y】补\n【x-y】补=【x+（-y）】补=【x】补+【-y】补\n\n\n1\n2\n\n\n特殊数\n\n * 对无符号数：\n   * (10000000)b = 128\n * 在原码中定义为：\n   * (10000000)b = -0\n * 在反码中定义为：\n   * (10000000)b = -127\n * 在补码中定义为：\n   * (10000000)b = -128\n\n数的性质由设计者决定\n\n在低级语言程\n\n序设计中，根据数的性质由程序语言处理（按无符号数或有符号数处理）。\n\n----------------------------------------\n\n\n# 1.5计算机能力的有限性\n\n * 计算机的运行能力是有限的\n   * 计算机无力解决无法设计出算法的问题\n   * 无法处理无穷运算或连续变化的信息\n * 计算机能够表示的数（表数）的范围是有限的\n   * 计算机的表数范围受字长的限制\n   * 例如：对8位机\n     * 无符号数的最大值：1111 1111\n     * 有符号正整数的最大值：0111 1111\n\n----------------------------------------\n\n当运算结果超出计算机表数范围时，将产生溢出\n\n * 无符号整数的表示范围：\n   \n   * 当计算机中数的运行结果超出表述范围时，则产生溢出。\n   * 无符号整数的表数范围：0 <= x <= [2^(n-1)],n表示字长\n   * 无符号数加减运算溢出的判断方法：\n     * 当最高位向更高位有进位（或借位）时则产生溢出\n\n * 有符号整数的表示范围：\n   \n   * 原码和反码：[2^(n-1)]-1 <= x <= [2^(n-1)]-1\n   * 补码：[2^(n-1)] <= x <= [2^(n-1)]-1\n   * 对于8位二进制数：\n     * 原码：-127~+127\n     * 反码：-127~+127\n     * 补码：-128~+127\n\n * 符号数运算中的溢出判断\n   \n   * 两个符号数相加或相减时，若运算结果超出可表达范围，则产生溢出\n   * 溢出的判断方法：\n     * 最高位进位状态和次高位进位状态不一样，则结果溢出\n     * 除法运算溢出时，产生“除数为0”中断\n     * 乘法运算无溢出问题\n\n----------------------------------------\n\n符号二进制数与十进制的转换\n\n转换方法：\n\n * 求出真值\n * 进行转换\n\n计算机中的符号数默认以补码形式表示。\n\n原码 = 符号位 + 绝对值\n正数的补码 = 原码 = 符号位 + 绝对值\n负数的补码 != 原码 != 符号位 + 绝对值\n\n例如：\n设：【x】补=0 010 1110b ----\x3e 真值= +010 1110b ----\x3e x = +101110b = +46\n设：【x】补=1 101 0010b ----\x3e x != -101 0010b ----\x3e 欲求x的真值，需对【x】补再取补码\n\t【【x】补】补 = [11010010]补 = -010 1110 = -46\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 对正数：补码 = 反码 = 原码，且 原码 = 符号位 + 真值\n   * 所以：正数补码的数制部分为真值\n * 对负数：补码 != 反码 != 原码\n   * 所以：负数补码的数制部分 != 真值\n\n只有原码的数值部分是真值\n\n反码和补码的数值部分都不是真值\n\n\n# 2. 逻辑电路\n\n逻辑电路由其3种基本门电路(或称判定元素)组成。图1-1是基本门电路的名称、符号及表达式。\n\n\n\n在这3个基本门电路的基础上，还可发展成如图1-2那样更复杂的逻辑电路。其中， 最后一个叫作缓冲器(buffer) ,为两个非门串联以达到改变输出电阻的目的。如果a点左边电路的输出电阻很高，则经过这个缓冲器之后，在y点处的输出电阻就可以变得低许多倍，这样就能够提高带负载的能力。\n\n\n\n\n# 2.1”与非“逻辑\n\n即”与“运算和”非“运算的一种组合\n\n逻辑关系：!(a*b)或者!(a^b)\n\n将与门的输出接入非门的输入，构成”与非”门\n\n\n# 2.2“或非”逻辑\n\n即”或“运算和”非“运算的一种组合\n\n逻辑关系：!(a+b)或者!(avb)\n\n将与门的输出接入非门的输入，构成”与非”门\n\n”与非门“和“或非门”小结\n\n * ”与非门“及“或非门”均为多输入单输出的门电路\n\n * 可以实现多个变量的“与非”或者“或非”运算\n\n练习：\n\n设：a=11001010，b=10101001\n计算：\n1.y= !(a*b)\ny = ![1100 1010 * 1010 1001]=![1000 1000]= 0111 0111\n2.y= !(a+b)\ny = ![1100 1010 + 1010 1001]=![1110 1011]= 0001 0100\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3”异或“逻辑\n\n“异或”逻辑关系是在与、或、非3种基本逻辑运算基础上的变换。\n\n异或逻辑的布尔代数表达式：f=(!a)*b+a*(!b)=a⊕b\n\n“异或”运算是两个变量的运算\n\n运算规则：相同则为0，相异则为1。\n\n\n# 2.4”同或“逻辑\n\n”同或“运算是在”异或“运算的基础上再进行”非“运算的结果。\n\n同或运算的布尔表达式：f=![(!a)*b+a*(!b)]=!(a⊕b)\n\n“同或”运算是两个变量的运算\n\n运算规则：相同则为1，相异则为0。\n\n\n# 3. 布尔代数\n\n布尔代数也成为开关代数或逻辑代数，和一般线性代数一样，可以写成下面的表达式：\n\ny = f(a,b,c,d)\n\n\n1\n\n\n但它有两个特点：\n\n * 其中的a,b,c,d等均只有两种可能的数值：0或1。布尔代数变量的数值并无大小之意，只代表事务的两个不同属性。如用于开关，则：0代表关（断路）或低电位；1代表开（通路）或高电位。如用于逻辑推理，则：0代表错误（假）；1代表正确（真）。\n * 函数 f 只有3种基本方式：“或”运算、“与”运算、“反”运算。\n\n----------------------------------------\n\n\n# 3.1“或”运算（or）\n\n由于a,b只有0或1的可能取值，所以其各种可能结果如下：\n\ny=0+0=0 → y=0\n\ny=0+1=1 |\ny=1+0=1 |→ y=1\ny=1+1=1 |\n\n\n1\n2\n3\n4\n5\n\n\n上述第4个式子与一般的代数加法不符,这是因为y也只能有两种数值：0或1。\n\n面4个式子可归纳成两句话：两者皆伪者则结果必伪，有一为真者则结果必真。\n\n这个结论也可推广至多变量：a,b,c,d...,各变量全假者则结果必假，有一为真者则结果必真。\n\n在输入的“或”门电路中，只要其中有一个输入为1，则其输入必为1。或者说只有全部输入均为0时，输出才为0。\n\n或运算有时也称为“逻辑或”。当a和b为多位二进制数时，如：\n\na=a1a2a3....an\nb=b1b2b3....bn\n\n则进行“逻辑或”运算时,各对应位分别进行“或”运算:\ny =a+b\n=(a1 + b1)(a2 + b2)(a3 + b3)...(an + bn)\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意： 1 “或” 1等于1，是没有进位的。\n\n例如：\n\n设 a =10101,b =11011,则y=a+b\ny=(1 + 1)(0 + 1)(1 + 0)(0 + 1)(1 + 1) = 11111\n写成竖式则为:\n  10101\n+ 11011\n--------\n  11111\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总结：\n\n * 输入条件中有一个为”真“，则输出的结果为”真“\n\n * 仅当输入条件全部为“假”时，输出结果才为“假”\n\n * ”或“运算符号：+、v\n\n * 在电路中，”或“运算相当于开关的并联电路\n   \n   * 仅当所有开关都断开时，电路才无电流通过。\n\n\n\n----------------------------------------\n\n\n# 3.2“与”运算（and）\n\n根据a和b的取值(0或1)可以写出下列各种可能的运算结果：\n\ny=0*0=0|\ny=1*0=0|→ y=0\ny=0*1=0|\n\ny=1*1=1 → y=1\n\n\n1\n2\n3\n4\n5\n\n\n这种运算结果也可归纳成两句话：二者为真者结果必真，有一为假者结果必假。\n\n同样，这个结论也可推广至多变量：各变量均为真者结果必真，有一为假者结果必假。\n\n在多输入“与”门电路中，只要其中一个输入为0，则输出必为0，或者说,只有全部输入均为1时，输出才为1。\n\n与运算有时也称为“逻辑与”。当a和b为多位二进制数时，如:\n\na=a1a2a3....an\nb=b1b2b3....bn\n则进行“逻辑与”运算时,各对应位分别进行“与”运算:\ny=a * b = (a1 * bl)(a2 * b2)(a3 * b3)...(an* bn)\n\n例如:设a=11001010，b = 00001111，则y = a * b\ny = (1 * 0)(1 * 0)(0 * 0)(0 * 0)(1 * 1)(0 * 1)(1 * 1)(0 * 1)= 00001010\n写成竖式则为：\n  11001010\n* 00001111\n-----------\n  00001010\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n由此可见，用“0”和一个数位相“与”，就是将其‘‘抹掉”而成为“0”；用“1”和一个数位相“与”，就是将此数位“保存”下来。\n\n这种方法在计算机的程序设计中经常会用到，称为“屏蔽”。\n\n上面的b数(0000 1111)称为“屏蔽字”，它将a数的高4位屏蔽起来，使其都变成0了。\n\n总结：\n\n * 仅当输入条件全部为“真”时，输出的结果为“真”\n * 若输入条件有一个为“假”时，则输出结果为假\n * “与“运算符号：*、^\n * 在电路中，与运算相当于开关的串联电路\n   * 仅当所有开关闭合时，电路才通路。\n\n\n\n----------------------------------------\n\n\n# 3.3“反”运算\n\n又称”非“运算\n\n如果一件事物的性质为a，则其经过“反”运算之后，其性质必与a相反，用表达式表示为：\n\ny = !a\n\n\n1\n\n\n这实际，上也是反相器的性质。所以在电路实现上，反相器是反运算的基本元件。反运算也称为“逻辑非”或“逻辑反”。\n\n当a为多位数时,如:\na = a1a2a3...an\n则其“逻辑反”为:\ny= !a1!a2!a3...!an\n设: a=1101 0000\n则: y=0010 1111\n\n\n1\n2\n3\n4\n5\n6\n\n\n即：按位取反。\n\n总结：\n\n * 当决定事件结果的条件满足时，事件不发生。\n * ”非“属于单边运算，只有一个运算对象，运算符作为一条上横线（这里我用!代替上横线）\n * 在电路，非运算相当于短路\n   * 当开关断开时灯亮，开关闭合时灯灭。\n\n\n\n----------------------------------------\n\n小结：\n\n逻辑运算于数学运算的区别：\n\n * 算数运算是两个数之间的运算，低位运算结果将对高位运算产生影响\n * 逻辑运算是按位进行的运算，低位运算结果对于高位运算不产生影响\n\n当”与“门的输入段有1位为低电平（0）时，则输出为”0“\n\n当”或“门的输入端有1位为高电平（1）时，则输出为”1“\n\n----------------------------------------\n\n\n# 3.4布尔代数的基本运算规则\n\n * 恒等式\n\na * 0 = 0\ta * 1 = a\ta * a = a\na + 0 = a\ta + 1 = 1\ta + a = a\na + !a = 1\ta * !a = 0\t!a = a\n\n\n1\n2\n3\n\n * 运算规律\n   * 与普通代数一样，布尔代数也有交换律、结合律、分配律，而且它们与普通代数的规律完全相同。\n\n1.交换律：a * b = b * a\n\t\t a + b = b + a\n2.结合律：(ab)c=a(bc)=abc\n\t\t (a+b)+c = a+(b+c) = a+b+c\n3.分配律：a(b+c)=ab+ac\n\t\t (a+b)(c+d) = ac+ad+bc+bd\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 3.5摩根定理\n\n在电路设计时，人们手边有时没有“与”门，而只有"或"门和“非”门；或者只有“与”门和“非”门，没有“或”门。利用摩根定理，可以解决元件互换的问题。\n\n二变量的摩根定理为：\n\n!(a+b) = !a * !b\n!(a*b) = !a + !b\n推广到多变量：\n!(a+b+c...) = !a * !b * !c *...\n!(a*b*c...) = !a + !b + !c +...\n\n\n1\n2\n3\n4\n5\n\n\n可以用表格验证此定理\n\n--------------------------------------\na\tb\t!(a+b)\t!a*!b\t!(a*b)\t!a+!b\n--------------------------------------\n0\t0\t   1  \t  1  \t   1  \t   1\n0\t1\t   0  \t  0  \t   1  \t   1\n1\t0\t   0  \t  0 \t   1  \t   1\n1\t1\t   0  \t  0  \t   0  \t   0\n------   -------------   -------------\n   ↓\t\t\t↓\t\t\t\t↓\n变量可能取值\t   相等\t\t\t  相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个定义可以用一句话来记忆：\n\n头上切一刀（指的是【!(a+b)或!(a*b)】），下面变个号（指的是运算符号由*变+【或由+变*】）。\n\n----------------------------------------\n\n\n# 3.6真值及布尔代数式的关系\n\n当人们遇到一个因果问题时，常常把各种因素全部考虑进去,然后再研究结果。真值表也就是这种方法的一种表格形式。\n\n例如，考虑两个一位的二进制数a和b相加，其本位的和s及向高一位进位c的结果如何?\n\n全面考虑两个一位二进制数,可能出现四种情况:或a=0,b=0;或a=0,b=1;或 a=1,b=0;或a=1,b=1(一般n个因素可有2n种情况)。这实质是两个一位数(可为零,也可为1)的排列。我们可以把它们列人表内,如真值表左边部分所示。然后，对每一种情况进行分析。当a和b都为0时,s为0,进位c也为0;当a为0且b为1时,s为1,进位c为0;当a为1且b为0时,s为1,进位c为0;当a为1且b也为1时,由于s是一位数所以为0,而有进位c=1。\n\n真值表\n\na   b   s   c\n0   0   0   0\n0   1   1   0\n1   0   1   0\n1   1   0   1\n\n逻辑问题(二进制数相加的运算由于取值只能为1,0,所以可以转化为逻辑问题)的真值表。\n\n\n# 4. 二进制数的运算及其加法电路\n\n\n# 4.1二进制数的相加\n\n\n\n从以上例子可得出下列结论:\n\n(1)两个二进制数相加时，可以逐位相加。如二进制数可以写成：\n\na = a3a2a1a0\nb = b3b2b1b0\n\n\n1\n2\n\n\n则从最右边第1位(即0权位)开始，逐位相加，其结果可以写成：\n\ns = s3s2s1s0\n\n\n1\n\n\n其中各位是分别求出的:\n\ns0=a0+b0 → 进位c1\n\ns1=a1+b1+c1 → 进位c2\n\ns2=a2+b2+c2 → 进位c3\n\ns3=a3+b3+c3 → 进位c4;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最后所得的和是：\n\nc4s3s2s1=a+b\n\n\n1\n\n\n(2)右边第1位相加的电路要求：\n\n * 输入量为两个，即a0及b0;\n\n * 输出量为两个，即s0及c1。\n\n这样的一个二进制位相加的电路称为半加器(half adder)。\n\n(3)从右边第2位开始，各位可以对应相加。各位对应相加时的电路要求：\n\n * 输人量为3个，即ai，bi，ci\n\n * 输出量为两个，即si，ci+1。\n\n其中i=1,2,3,..,n。这样的一个二进制位相加的电路称为全加器(full adder)。\n\n\n# 4.2半加器电路\n\n要求有两个输入端，用以两个代表数字(a0，b0)的电位输入；有两个输出端，用以输出总和s0及进位c1。\n\n这样的电路可能出现的状态可以用图1-4中的表来表示。此表在布尔代数中称为真值表。\n\n考察一下c与a0及b0之关系，即可看出这是“与”的关系，即：\n\nc1=a0*b0\n\n\n1\n\n\n再看一下s0与a0及b0之关系，也可看出这是“异或”的关系，即：\n\ns0=a0⊕b0\n=(!a0)b0+a0(!b0)\n\n\n1\n2\n\n\n即只有当a0及b0二者相异时，才起到或的作用；二者相同时，则其结果为0。因此，可以用“与门”及“异或门”(或称“异门”)来实现真值表的要求。图1-4就是这个真值表及半加器的电路图。\n\n\n\n\n# 4.3全加器电路\n\n全加器电路的要求是：有3个输人端，以输入a赋给ai，bi和ci，有两个输出端，即si及ci+1。\n\n其真值表可以写成如图1-5所示。由此表分析可见,其总和si可用“异或门”来实现，而其进位ci+1则可以用3个“与门”及一个“或门”来实现，其电路图也画在图1-5中。\n\n\n\n这里遇到了3个输人的“异或门”的问题。如何判断多输人的“异或门”的输人与输出的关系呢?\n\n判断的方法是：多输入a,b,c,d,...中为“1”的输人量的个数为零及偶数时，输出为0；为奇数时，输出为1。\n\n\n# 4.4半加器及全加器符号\n\n\n\n\n# 4.5二进制数的加法电路\n\n设：\na = 1010 =10（d）\nb = 1011 =11（d）\n\n\n1\n2\n3\n\n\n则可安排如图1-7所示的加法电路。\n\n\n\na与b相加，写成竖式算法如下：\n\na:   1 0 1 0\nb:   1 0 1 1 (+\n----------------\ns: 1 0 1 0 1\n\n\n1\n2\n3\n4\n\n\n即其相加结果为s=10101。\n\n从加法电路，可以看到同样的结果：s = c4 s3 s2 s1 s0 = 10101\n\n\n# 4.6二进制数的减法运算\n\n在微型计算机中，没有专用的减法器，而是将减法运算改变为加法运算。\n\n其原理是：将减数b变成其补码后，再与被减数a相加，其和（如有进位的话，则舍去进位）就是两数之差。\n\n\n\n\n# 4.7可控反相器及加法/减法电路\n\n利用补码可将减法变为加法来运算，因此需要有这么一个电路，它能将原码变成反码，并使其最小位加1。\n\n图1-8的可控反相器就是为了使原码变为反码而设计的。\n\n\n\n这实际上是一个异或门（异门），两输入端的异或门的特点是：两者相同则输出为0，两者不同则输出为1。用真值表来表示这个关系,更容易看到其意义(表1-3)。\n\n由此真值表可见，如将 sub端看作控制端，则当在sub端加上低电位时，y端的电平就和b0端的电平相同。在sub端加上高电平，则y端的电平和b0端的电平相反。\n\n可控相反器的真值表（表1-1）\n\nsub   b0   y   y与b0的关系   \n0     0    0   y与b0相同    相同\n0     1    1   y与b0相同    相同\n1     0    1   y与b0相反    相反\n1     1    0   y与b0相反    相反\n\n利用这个特点，在图1-7的4位二进制数加法电路上增加4个可控反相器并将最低位的半加器也改用全加器，就可以得到如图1-9的4位二进制数加法器/减法器电路了，因为这个电路既可以作为加法器电路（当sub = 0），又可以作为减法器电路（当sub=1）。 如果有下面两个二进制数：\n\na = a3 a2 a1 a0\nb = b3 b2 b1 b0\n\n\n1\n2\n\n\n则可将这两个数的各位分别送入该电路的对应端，于是：\n\n * 当sub=0时，电路作加法运算：a＋b。\n * 当sub=1时，电路作减法运算：a - b。\n\n图1-9电路的原理如下：当sub=0时，各位的可控反相器的输出与b的各位同相，所以图1-9和图1-7的原理完全一样，各位均按位相加。\n\n结果:s = s3 s2 s1 s0\n而其和为:c4s = c4 s3 s2 s1 s0\n\n\n1\n2\n\n\n当sub=1，各位的反相器的输出与b的各位反相。注意，最右边第一位（即s0位）也是用全加器,其进位输人端与sub端相连，因此其c0 = sub = 1。\n\n所以此位的相加即为：\n\na0 + (!b0) + 1\n\n其他各位为:\na1 + (!b1) + c1\na2 + (!b2) + c2\na3 + (!b3) + c3\n\n因此其总和输出s=s3 s2 s1 s0,即:\ns = a + (!b) + 1\n  = a3 a2 a1 a0 + (!b3) (!b2) (!b1) (!b0) + 1\n  = a + b\'\n  = a - b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当然，此时c4如不等于0，则要被舍去。',charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"第三章、指令系统与汇编语言程序设计",frontmatter:{title:"第三章、指令系统与汇编语言程序设计",date:"2021-06-16T08:00:00.000Z",permalink:"/smc/3/",author:{name:"eric",href:"https://wfmiss.cn"}},regularPath:"/60.SMC/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html",relativePath:"60.SMC/04.第三章微型计算机的基本工作原理.md",key:"v-d83bdb10",path:"/smc/3/",headers:[{level:2,title:"1. 指令系统及指令格式",slug:"_1-指令系统及指令格式",normalizedTitle:"1. 指令系统及指令格式",charIndex:470},{level:3,title:"1.1操作数形式",slug:"_1-1操作数形式",normalizedTitle:"1.1操作数形式",charIndex:957},{level:3,title:"1.2 8086的操作码",slug:"_1-2-8086的操作码",normalizedTitle:"1.2 8086的操作码",charIndex:1355},{level:3,title:"1.3 8086指令中寄存器的编码",slug:"_1-3-8086指令中寄存器的编码",normalizedTitle:"1.3 8086指令中寄存器的编码",charIndex:1779},{level:3,title:"1.4指令的寻址方式",slug:"_1-4指令的寻址方式",normalizedTitle:"1.4指令的寻址方式",charIndex:2357},{level:2,title:"2.8086的指令系统",slug:"_2-8086的指令系统",normalizedTitle:"2.8086的指令系统",charIndex:4682},{level:3,title:"2.1传送类指令",slug:"_2-1传送类指令",normalizedTitle:"2.1传送类指令",charIndex:4854},{level:3,title:"2.2算数运算类指令",slug:"_2-2算数运算类指令",normalizedTitle:"2.2算数运算类指令",charIndex:8479},{level:3,title:"2.3十进制运算调整指令",slug:"_2-3十进制运算调整指令",normalizedTitle:"2.3十进制运算调整指令",charIndex:11358},{level:3,title:"2.4位操作指令",slug:"_2-4位操作指令",normalizedTitle:"2.4位操作指令",charIndex:13431},{level:3,title:"2.5串操作指令",slug:"_2-5串操作指令",normalizedTitle:"2.5串操作指令",charIndex:16911},{level:3,title:"2.6程序控制转移指令",slug:"_2-6程序控制转移指令",normalizedTitle:"2.6程序控制转移指令",charIndex:19860},{level:3,title:"2.7处理器控制指令",slug:"_2-7处理器控制指令",normalizedTitle:"2.7处理器控制指令",charIndex:23547},{level:3,title:"2.8输入输出指令",slug:"_2-8输入输出指令",normalizedTitle:"2.8输入输出指令",charIndex:24319},{level:3,title:"2.9中断指令",slug:"_2-9中断指令",normalizedTitle:"2.9中断指令",charIndex:24509},{level:2,title:"3.常用伪指令",slug:"_3-常用伪指令",normalizedTitle:"3.常用伪指令",charIndex:24812},{level:3,title:"3.1宏汇编语言的基本语法",slug:"_3-1宏汇编语言的基本语法",normalizedTitle:"3.1宏汇编语言的基本语法",charIndex:24824},{level:3,title:"3.2伪指令",slug:"_3-2伪指令",normalizedTitle:"3.2伪指令",charIndex:27134},{level:3,title:"3.3宏定义",slug:"_3-3宏定义",normalizedTitle:"3.3宏定义",charIndex:29206}],headersStr:"1. 指令系统及指令格式 1.1操作数形式 1.2 8086的操作码 1.3 8086指令中寄存器的编码 1.4指令的寻址方式 2.8086的指令系统 2.1传送类指令 2.2算数运算类指令 2.3十进制运算调整指令 2.4位操作指令 2.5串操作指令 2.6程序控制转移指令 2.7处理器控制指令 2.8输入输出指令 2.9中断指令 3.常用伪指令 3.1宏汇编语言的基本语法 3.2伪指令 3.3宏定义",content:"# 第三章、指令系统与汇编语言程序设计\n\n三、指令系统与汇编语言程序设计\n（一）知识范围\n指令系统的概念、指令格式；\n对操作数的寻址方式；\n常用指令（传送指令、算术运算指令、逻辑运算和移位指令、串操作指令、程序控制指令与处理器控制指令）；\n汇编语言程序的基本结构；\n常用伪指令（数据定义、符号定义、段定义、设定段寄存器）；\nDOS功能调用（输入/输出字符、输入/输出字符串、结束程序）；\n三种结构（顺序结构、分支结构和循环结构）程序设计；\n常用程序设计举例。\n（二）考核要求\n1.\t理解指令系统的概念及指令格式。\n2.\t掌握常用的寻址方式并能熟练地使用它们。\n3.\t掌握常用指令的格式、功能和使用方法，分析各种指令执行后的结果。\n4.\t掌握指令对状态标志的影响。\n5.\t掌握常用伪指令的格式和功能。\n6.\t掌握汇编语言源程序的构成，熟练掌握汇编语言程序上机调试运行过程。\n7.\t理解程序的三种基本结构，能够使用汇编语言解决常见的问题。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1. 指令系统及指令格式\n\n特点：\n\n * 指令系统的兼容性\n * 指令系统的灵活性\n * 寻址方式的多样性\n * 可对多种类型的数据进行处理\n * 可构成多处理机系统\n\n**指令：**控制计算完成特定操作的命令\n\n**指令系统：**指令系统是计算机能够执行全部命令的集合，它其取决于计算机的硬件设计。指令系统因机而异，没有通用性。\n\n指令中应包含的信息：执行的运算、运算结果的去向、运算数据的来源\n\n指令格式：\n\n操作码\t\t [操作数]\t,\t[操作数]\n----- \t   --------     --------\n   |\t\t\t|\t\t\t|\n执行何种操作\t目的操作数  ， 源操作数【参加操作的数据】\n\n源操作数：指令加工前的数据\n目的操作数：指令加工之后形成的数据\n\n零操作数指令：操作码\n单操作数指令：操作码\t操作数\n双操作数指令：操作码\t目的操作数，源操作数\n\n操作数形式：\n立即数、寄存器、存储器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# 1.1操作数形式\n\n立即数操作数：\n\n * 表示参加操作的数据本身，可以是8位或16位；\n * 立即数无法作为目标操作数；\n * 立即数可以是无符号或带符号数，其数值应在可取值范围内。\n\n寄存器操作数：\n\n * 表示参加运算的数存放在指令给出的寄存器中，可以是16位或8位。\n\n存储器操作数：\n\n * 表示当前参加运算的数存放在存储器的某一个或两个单元中。\n\n指令的字长与指令的执行速度：\n\n * 指令字长由操作码的长度、操作数地址长度、操作数个数决定\n * 8088/8086 CPU采用变字长指令格式\n * 指令的字长影响指令执行的速度\n * 对不同的操作数，指令执行的时间不同：\n\n存储器 → 立即数 → 寄存器\n----------------------\n慢\t\t→\t\t  快\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 1.2 8086的操作码\n\n指令由操作码（Opcode）和操作数（地址码）组成。8086 的指令长度是可变的，一条指令般由 1~6字节组成（加上前级字节，最长可为7宇节)。指令的操作码采用二进制代码表示本指会所执行的操作，通常用指令的第一个字节表示。有时由于用8位不够，因此在指令的第二个字节中还可能占了位。除此以外的其他字节 （或位）用来表示操作数。 在多数操作码中，使用某些位来指示有关信息，常用的符号及含义如下： ◎W（字位）：表示本指令是对字（W=1）还是对字节（W=0）操作。\n\n◎D（方向位）：表示参加操作的寄存器是作为目的操作数寄存器（D=1）还是作为源操作数寄存器（D=0）。\n\n◎S（符号扩展位）：用于某些立即寻址的机器指令中。如果立即数为8位，但要求扩展成16位，则S=1；否则，S=0（所扩展的高8位要根据8位立即数的最高位来定）。\n\n----------------------------------------\n\n\n# 1.3 8086指令中寄存器的编码\n\n 1. 指令的二进制一般形式\n\n8086指令的二进制一般形式如下：操作码 d/v/s w\n\n 2. 编码模式\n\n编码方式主要有以下三种：段寄存器编码、通用寄存器编码、内存寻址编码。\n\n * 段寄存器编码\n\n编码   段寄存器编码\n00   ES\n01   CS\n10   SS\n11   DS\n\n * 通用寄存器编码\n\n编码    16位寄存器名   8位寄存器名\n000   AX        AL\n001   CX        CL\n010   DX        DL\n011   BX        XL\n100   SP        AH\n101   BP        CH\n110   SI        DH\n111   DI        BH\n\n * 内存寻址编码\n\nR/M编码   基址寄存器   变址寄存器\n000     BX +    SI\n001     BX +    DI\n010     BP +    SI\n011     BP +    DI\n100             SI\n101             SI\n110     BP      \n111     BX      \n\n8086指令中通常使用一个或两个操作数，在少数指令中隐含的第三个操作数。\n\n\n# 1.4指令的寻址方式\n\n指令的寻址方式就是寻找指令操作数所在地址的方式，以确定数据的来源和去处。\n\n 1. 立即寻址（立即数寻址）：\n\n指令操作数部分直接给出指令的操作数，它与指令操作码相接，顺序存放在代码中。立即数有8位和16位之分。\n\n注意：\n\n * 立即寻址方式只能用于源操作数，主要用于给寄存器赋值。\n * 立即寻址方式不执行总线周期，执行速度快。\n\n----------------------------------------\n\n 2. 寄存器寻址：\n\n * 操作数放在寄存器内，由指令直接给出某个寄存器的名字，以寄存器的内容作为操作数。\n * 寄存器可以是16位的AX、BX、CX、DX、SI、DI、SP、BP寄存器，也可以是8位的AH、AL、BX、XL、CH、CL、DH、DL寄存器。\n\n注意：\n\n * 寄存器寻址方式的指令操作在CPU内部执行，不需要执行总线周期，执行速度快。\n * 寄存器寻址方式既适用于指令的源操作数，也适用于目的操作数，并且可同时使用于源操作数和目的操作数。\n\n----------------------------------------\n\n 3. 直接寻址：\n\n操作数在存储器中，指令中直接给出操作数所在存储单元的有效地址EA，即段内偏移地址，表示操作数所在存储单元距离段首址的字节数。有效地址是一个无符号的16位二进制数。（直接给出偏移地址）\n\n注意：\n\n * 直接寻址方式的操作数所在存储单元的短地址一般在数据段寄存器DS中。（默认DS段）\n * 如果操作数在其他段，则需要在指令中用段超越前缀指出相应的段寄存器名。\n\n----------------------------------------\n\n 4. 寄存器间接寻址：\n\n * 操作数在存储器中，指令中寄存器的内容作为操作数所在单元的有效地址EA（偏移地址）。寄存器仅限于BX、BP、SI、DI。\n\n\t|[SI]\n\t|[DI]\nEA- |[BX]\n\t|[BP]\n\n\n1\n2\n3\n4\n\n * 当使用BX、SI、DI时，操作数所在存储单元的段地址存在数据段寄存器DS中。\n * 当使用BP时，操作数所在存储单元的段地址存在堆栈段寄存器SS中。\n\n注意：\n\n * 只有SI、DI、BX、BP可作为间接寻址器。\n * 若操作指令所在存储单元不在数据段DS中，需要在指令中用段超越前缀表明其所在段的段名。\n\n----------------------------------------\n\n 5. 基址寻址：\n\n * 操作数在存储器内，指令中寄存器（BX或BP）的内容与指令指定的位移量之和作为操作数所在存储单元的有效地址EA（偏移地址）。\n\n\t|[BX]|\nEA= |\t |->[8位或16位位移量]\n\t|[BP]|\n\n\n1\n2\n3\n\n * 当使用BX时，段地址为DS的内容；\n * 当使用BP时，段地址为SS的内容。\n\n----------------------------------------\n\n 6. 变址寻址：\n\n * 操作数在存储器内，指令将变址寄存器SI、DI内容与指令指定的偏移位移量之和作为操作数所在存储单元的有效地址EA（偏移地址）。段地址规定为DS的内容。\n\n\t|[SI]|\nEA= |\t |->[8位或16位位移量]\n\t|[DI]|\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n 7. 基址加变址寄存器：\n\n * 操作数在内部寄存器内。指令将基址寄存器BX、BP与变址寄存器SI、DI的内容之和再加上之前的偏移量（8位或16位），得到操作数所在存储单元的有效地址EA。\n\n\t|[SI]|\t |[SI]|\nEA= |\t | + |\t  | + ->[8位或16位位移量]\n\t|[DI]|\t |[DI]|\n\n\n1\n2\n3\n\n * 当使用BX时，段地址寄存器为DS。\n * 当使用BP时，段地址寄存器为SS。\n\nMOV 寄存器,[BX/BP+SI/DI+n]\n // n为16进制地址,\n\n\n1\n2\n\n\n----------------------------------------\n\n 8. 字符串寻址：\n\n * 用于字符串操作指令。规定变址寄存器SI中的内容是源数据串的段内偏移地址，而变址寄存器DI中的内容是目标数据串的段内偏移地址。\n * 源数据串的地址规定是数据段DS，目标数据串的段地址规定是附加段ES。指令执行后SI和DI的内容自动增量（或减量），增（或减）值为1或2。\n\n----------------------------------------\n\n 9. I/O端口寻址：（独立编址）\n\n * 寻址输入输出设备的端口地址，可分为直接端口寻址和间接端口寻址。\n * 直接端口寻址：由指令直接给出I/O设备的端口地址。它规定端口地址为8位，能寻址256个端口\n * 间接端口寻址：由DX给出I/O设备的端口地址。由于DX是16位，因此间接端口地址能寻址多达64K个端口。\n\n例如：\n\nIN AL,20H;\t将地址为20H的外设内容读入AL中。\nOUT DX,AL;\tAL中内容输出给以DX的内容为地址的外设。\n\n\n1\n2\n\n\n----------------------------------------\n\n 10. 隐含寻址：\n\n指令隐含了的一个或两个操作数的地址，即操作数在默认的地址中。\n\n例如：\n\nAAA;\t对AL中的内容进行十进制加法调整，并把调整后的结果放入AH和AL中。这条指令的隐含操作数是AH和AL。\n\n\n1\n\n\n\n# 2.8086的指令系统\n\n指令系统包括九大类、133种基本指令，通过寻址方式的变化与数据形式（字节、字型）的组合，可构成上千条指令。指令系统按功能分为：数据传送类、算数运算类、逻辑运算与移位类、串操作类、控制转移类、处理机控制、输入输出、中断等。\n\n\n\n----------------------------------------\n\n\n# 2.1传送类指令\n\n# 2.1.1数据传送指令\n\n数据传送类指令实现CPU内部寄存器之间、CPU与内存储器之间、CPU与I/O端口之间的数据传送。\n\n通用数据传送指令\n\n包括MOV、进栈（PUSH）、出栈指令（POP）、交换指令和换码指令。\n\n * 一般数据传送指令MOV（8位/16位）\n\n格式：MOV\tOP目的操作数,OP源操作数\n功能：OP源操作数 ——> OP目的操作数\n要求：OP目 可以是寄存器（除CS外）、存储器 OP源可以是寄存器、存储器和立即数。\n\n\n1\n2\n3\n\n\n该指令有如下9种形式：\n\nMOV REG,REG\t\t\t;通用寄存器间传送\nMOV REG,IMM\t\t\t;立即数送通用寄存器\nMOV MEM,IMM\t\t\t;立即数送存储器\nMOV MEM,REG\t\t\t;通用寄存器送存储器\nMOV REG,MEM\t\t\t;存储器送通用寄存器\nMOV SEGREG,REG\t\t;通用寄存器送段寄存器（CS除外）\nMOV REG,SEGREG\t\t;段寄存器送通用寄存器（含CS）\nMOV SEGREG,MEM\t\t;存储器送通用寄存器（CS除外）\nMOV MEM,SEGREG\t\t;段寄存器送存储器（含CS）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意：\n\n * MOV指令的两个操作数（源、目的）均可采用不同的寻址方式。\n\n * 源操作数和目的操作数的类型必须一致。\n\n * 源和目的不能都是存储器操作数。\n\n * 不允许把立即数做目的操作数，也不允许向段寄存器（CS、DS、SS、ES）送立即数。\n\n * 不允许在段寄存器之间、存储单元之间传送数据。\n\n * CS、IP寄存器不能用作目的操作数。\n\n * 一般传指令不影响标志位。\n\n----------------------------------------\n\n堆栈操作指令\n\n堆栈：是按 “后进先出” 原则工作的一段存储区域。\n\n堆栈寄存器SS —— 段地址\n\n堆栈指针SP —— 始终单前栈顶所在的存储单元地址，即最新入栈数据所在存储单元的地址。\n\n压栈操作(进栈指令)：PUSH OP(源操作数)\n\n功能：把OP(源操作数)字节数据压入栈中，结果SP-2 ——> SP\n\n原则：高字节压在高地址，低字节压在低地址\n\n执行过程：\n\nSP <-- SP - 1;\t\t[SP] <-- OPH\nSP <-- SP - 1;\t\t[SP] <-- OPL\n\n\n1\n2\n\n\n堆栈操作总是对16位的数据进行，指令中目的操作数隐含为堆栈。进栈操作把数据传输到以SS为段基址、SP为偏移地址的栈中。其操作过程如下：\n\n * SP减一，指示堆栈中可以存放数据的位置，存放源操作数的高8位。\n * SP再减一，存源操作数的迪8位，完成进栈操作。\n\n出栈操作(出栈指令)：POP OP(目操作数)\n\n功能：从栈中弹出数据 ——> OP(目操作数)，结果SP+2——>SP\n\n执行过程：\n\nOPL <-- [SP];\t\tSP <—— SP+1\nOPH <-- [SP];\t\tSP <—— SP+1\n\n\n1\n2\n\n\n例如：\n\n已知：AX=1122H,BX=3344H,SP=1010H\n执行指令：PUSH AX\n\t\tPUSH BX\n\t\tPOP AX\n\t\tPOP BX\n执行后AX，BX，SP的结果？\n解：AX=3344H\n   BX=1122H\n   SP=1010H\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意：\n\n * 堆栈操作总是按字进行的。\n * 压入指令，SP-2，数据在栈顶。弹出指令正好相反。\n * 操作数可以是存储器、寄存器或段寄存器操作数 （CS不能用于POP），不能是立即数。\n\n----------------------------------------\n\n# 2.1.2目标地址传送指令\n\n此类指令的功能是将操作数所在存储器的地址送入目标寄存器。\n\n注意：\n\n * OP源必须是存储器操作数，OP目必须是16为的通用寄存器。\n * 地址传输指令不影响状态标志位。\n\n----------------------------------------\n\n取有效地址指令\n\n格式：LEA 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)\n\n功能：存储器地址送到一个寄存器。\n\n例如：\n\nLEA SI,[2040H]\n指令执行后，SI中的内容为2040H。又如：\nMOV SI,[2040H]\n指令执行后，SI中有偏移地址为2040H单元中的内容，而不是2040H这个值。\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n将地址指针装到DS和另一个寄存器的指令\n\n格式：LDS 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)\n\n功能：把OP源指定的4个字节内容取出，低地址的两个字节—>OP目，高地址的两个字节—>DS。\n\n例如：\n\nLDS DI,[2130H]\n2130H和2131H的单元中的内容送到DI；\n2132H和2133H的单元中的内容送到DS；\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n将地址指针装到ES和另一个寄存器的指令\n\n格式：LES 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)\n\n功能：本指令与LDS指令的操作数基本相同，所不同的是将OP源4个字节中的高地址的两个字节—>ES。\n\n例如：\n\nLES DI,[2130H]\n2130H和2131H的单元中的内容送到DI；\n2132H和2133H的单元中的内容送到ES；\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 2.1.3标志寄存器传送指令\n\n读取标志指令\n\n格式：LAHF ; AH <— 标志寄存器低八位\n\n特点：此指令操作结果不影响标志寄存器。\n\n----------------------------------------\n\n设置标志指令\n\n格式：SAHF ; 标志寄存器低8位 <— AH\n\n特点：此之指令直接为标志寄存器的低8位赋值。\n\n----------------------------------------\n\n对标志寄存器的堆栈操作指令\n\n格式：PUSHF ; 将标志寄存器的值压栈。\n\nPOPF ; 从栈顶弹出一个字送标志寄存器。\n\n特点：\n\n * PUSHF不影响标志寄存器，而POPF直接为标志寄存器赋值。\n * 通常两条指令成对出现，用来保护和恢复标志寄存器的内容。\n\n----------------------------------------\n\n# 2.1.4累加器专用传输指令\n\n数据交换指令\n\n格式：XCHG OP1(目的操作数),OP1(源操作数)\n\n功能：实现OP1和OP2的内容的相互交换。\n\n操作数：通用寄存器或存储器，但不能均为内存单元。\n\n注意：段寄存器和IP不能作为交换指令的操作数。\n\n----------------------------------------\n\n换码指令（查表指令、翻译指令）\n\n换码指令是一条完成字节翻译功能的指令。它可以使累加器中的一个值变化为内存表格中的某一个值，一般用来实现编码制的转换。\n\n格式：XLAT\n\n功能：\n\n[BX+AL] —> AL\n\t|----\x3e EA\n\n\n1\n2\n\n\n说明：将BX和AL内容相加作为有效地址EA，在一个表格中找出此单元中的内容—>AL。\n\nBX——表格的首地址\n\nAL——相对于表格首地址的位移量（要装换的代码）\n\n注意：\n\n * 使用前，先建立被转换代码（字节型）的数据表。\n * 换码指令只能使用寄存器BX、AL，不影响标志位。\n\n----------------------------------------\n\n输入指令\n\n格式：IN AL,n\n\nIN AX,n\n\nIN AL,DX\n\nIN AX,DX\n\n说明：以上四种指令格式分别是8位/16位端口地址组合形式；指令中n表示为8位端口地址（00H~FFH），此时地址线高8位默认为0；当端口地址为16位时，指令中采用寄存器间接寻址，应先将16位端口地址传输到DX中，然后DX中的地址在IN指令中间接寻址。\n\n----------------------------------------\n\n输出指令\n\n输入指令\n\n格式：OUT n,AL\n\nOUT n,AX\n\nIN DX,AL\n\nIN DX,AX\n\nOUT指令除源操作数和目的操作数与IN指令相反外，其他相同。\n\n可见，无论是输入指令还是输出指令，其中地址部分的寻址方式要么是直接寻址，要么是寄存器寻址。\n\n\n# 2.2算数运算类指令\n\n8086的算数运算类指令能够对二进制或十进制（BCD码）数进行加、减、乘、除运算，操作数的数据形式可以是8位或16位的无符号数或带符号数。\n\n# 2.2.1加法指令\n\n不带进位的加法指令：\n\n格式：ADD OP目,OP源\n\n功能：OP目<— OP源+OP目，根据结果设置标志位（FR）。\n\n注意：两操作数的类型相同，类型明确，不能同为存储器操作数。\n\n进位的加法指令\n\n格式：ADC OP目,OP源\n\n功能：OP目<—OP源+OP目+CF，置标志位\n\n说明：只要用于多字节运算，多字节运算时低位字节产生进位应加到高位。\n\n加1指令\n\n格式：INC OP\n\n功能：OP <— OP+1\n\n说明：常用于修改偏移地址和计数次数。操作数可以是8/16位通用寄存器操作数，不能为立即数。\n\n注意：\n\n * INC指令不影响CF位，影响标志位AF、OF、PF、SF和ZF。\n * 操作数视为无符号数。\n\n总结：以上三条指令运算结果将影响状态标志位，但INC不影响标志CF。\n\n# 2.2.2减法指令\n\n不带借位的减法指令\n\n格式：SUB OP目,OP源\n\n功能：OP目<— OP目-OP源，并根据结果设置标志\n\n说明：\n\n * 指令的目的操作数不能是立即寻址；\n * 减法操作中产生的借位进入CF标志；\n * 无符号操作数相减，若CF=1，则结果为补码；\n * 带符号操作数相减要考虑溢出。\n\n带借位的减法指令\n\n格式：SBB OP目,OP源\n\n功能：OP目<—OP目-OP源-DF，并根据结果设置标志。\n\n说明：\n\n * 主要用于多字节或多精度数据相减的运算。\n * 指令中有3个操作数，其中CF是本指令执行前的状态；\n * 本指令在需要完成多字节数（如4字节的32位数或更多字节）相减时时使用；\n * 指令的目的操作数不能是立即寻址（立即数）；\n * 无符号操作数相减，若CF=1，则结果为补码；\n * 带符号操作数相减要考虑溢出。\n\n减1指令\n\n格式：DEC OP目\n\n功能：OP目<—OP目-1，根据结果置标志位，不影响CF。\n\n说明：\n\n * 操作数不能是立即寻址；\n * 该指令不影响CF标志；\n * 操作数为内存寻址时，需使用伪指令。\n\n取补指令\n\n格式：NEG OP\n\n功能：0-OP—>OP,将操作数取补后回送原操作数OP可以是8/16位通用寄存器和存储寄存器操作数，不能为立即数。\n\n说明：\n\n * 对80H或8000H取补时，操作数没有变化，但OF=1。\n\n * 对CF影响较特殊，只要操作数不是0，总是使CF=1。\n\n * 操作数不能是立即寻址。\n\n比较指令\n\n格式：CMP OP目,OP源\n\n功能：OP目-OP源，不回送结果，只根据结果置标志位。\n\n说明：\n\n * 执行指令执行“目的操作数-源操作数”，与SUB指令不同的是，不产生运算结果，仅影响标志位；\n * 指令的目的操作数不能是立即寻址；\n * 目的操作数和源操作数不能同时为存储器操作数。\n\n用途：用于比较两个数的大小，可作为条件转移指令转移的条件。\n\n# 2.2.3乘法指令\n\n无符号数乘法\n\n格式：MUL OP\n\n功能：AX<—AL*OP，8位数乘法\n\n(DX、AX)<— AX*OP，16位数乘法\n\n说明：\n\n * 8位*8位=>16位，16位*16位=>32位\n * 乘数和被乘数都不能为立即寻址；\n * 乘数或被乘数必须放在AL或AX中，在指令中隐含；\n * 16位运算结果在AX中，32位运算结果在DX（高16位）和AX（低16位）中。\n\n带符号数乘法\n\n格式：IMUL OP\n\n功能：操作同上，但是操作数为带符号数\n\n说明：\n\n * 8位*8位=>16位，16位*16位=>32位\n\n * 乘数和被乘数都不能为立即寻址；\n\n * 乘数或被乘数必须放在AL或AX中，在指令中隐含；\n\n * 16位运算结果在AX中，32位运算结果在DX（高16位）和AX（低16位）中。\n\n * 有符号数在计算机中是其补码，且符号位也参加运算，此时用MUL指令就得不到正确结果，IMUL指令则会将符号部分和数值部分分别进行处理。\n\n注意：\n\n(1）进行字节运算时，OP目必须是AL，乘积在AX中；进行字运算时，0P目必须是AX，乘积在DX、AX中。源操作数不允许使用立即数寻址方式。 (2）运算结果只影响CF、OF，其他的无定义。 (3）对于MUL，若字节型数据相乘之积AH=0或字数据相乘之积DX=0，则CF=OF=0，否则CF=OF=1； 对于IMUL指令，若字节数据相乘之积AH或字数据相乘之积DX的内容是低一半的符号扩展，则CF=OF=0, 否则CF=OF=1。\n\n例题：\n\n已知AL=0FEH\n视为无符号数254，视为带符号数，值为-2\nBH=0AH\n视为无符号数为10，视为带符号数，数值为+10。\n执行指令MUL BH后 AX=09ECH，CF=OF=1\n执行指令IMUL BH后AX=FFECH，CF=OF=0\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.2.4除法指令\n\n指令要求被除数是除数的双倍字长，即当除数是8/16位时，要求被除数是16/32位的二进制数。\n\n无符号数除数\n\n格式：DIV OP\n\n功能：\n\n * 字节除法：AX/OP—>AL=商，AH=余数\n * 字出除法：（DX、AX）/OP—>AX=商，DX=余数\n\n说明：\n\n * 指令中使用16位除8位，32位除16位的格式，被除数不够16位或32位，则需要扩展；\n * 被除数、除数都不能为立即寻址，除数必须是寄存器数或存储器寻址；\n * 被除数必须放在AX或DX:AX中，在指令中则隐含；\n * 16位运算的商放在AL中，在余数放在AH中；\n * 32位运算的商放在AX中，余数放在DX中。\n\n带符号除数\n\n格式：IDIV OP\n\n功能：操作同DIV，但是操作数作为符号数。\n\n说明：\n\n * 同DIV\n\n注意：\n\n * 当除数是字节时，被除数必须放在AX中，\n   \n   当除数是子时，被除数必须放在DX，AX中。\n\n * 商超出规定的范围时，将产生0号中断。\n\n * IDIV运算结果余数的符号与被除数相同。\n\n * 带符号数除法运算中，当被除数位数不够时，则需将被除数扩展到所需的位数。（8086/8088设有带符号数扩展指令）\n\n符号扩张指令格式\n\n格式：CBW\n\n功能；将AL中的数的符号位扩展AH\n\n规则：\n\n * 若最高位=1，则执行后AH=FFH\n * 若最高位=0，则执行后AH=00H\n\n说明：\n\n * 在符号除法指令中，被除数要扩展成16位时使用该指令\n\n字节扩展指令（16位—>32位）\n\n格式：CWD\n\n功能：将AX中的数的符号位扩展到DX\n\n规则：\n\n * 若最高位=1，则执行后DX=FFFFH\n * 若最高位=0，则执行后DX=0000H\n\n说明：\n\n * 在符号除法指令中，被除数要扩展成32位时使用该指令\n\n这两条指令不影响标志位。\n\n\n# 2.3十进制运算调整指令\n\n# 2.3.1加法调整指令\n\n对非组合BCD数加法操作进行校正AAA\n\n格式：AAA\n\n功能：对AL寄存器的内容进行十进制数调整。\n\n说明：\n\n * 要求参加操作的数必须是非组合BCD数；\n * 该指令用在非压缩BCD数加法操作后，操作数隐含在AL中；\n * 由于该调整指令使用AH寄存器，故应先将AH内容清零。\n\nAAA指令调整方法：\n\n 1. 如果AL寄存器指令的低4位在0~9之间，AF为0，则跳过第2步执行第3步；\n\n 2. 如果AL寄存器的低4位在0AH~0FH之间或AF为1，则AL寄存器的内容加06H，同时AH寄存器内容加1，且将AF置1；\n\n 3. AL寄存器的高4位清零；\n\n 4. AF位的值送CF。\n\n对组合BCD数加法操作的结果进行校正DAA\n\n格式：DAA\n\n功能：对AL中的由两个组合BCD码相加进行调整，将结果（组合BCD码）存于AL中。\n\n说明：\n\n * 要求参加操作的数必须是BCD数；\n * 该指令用在组合BCD数加法操作后，操作数隐含在AL中。\n\nDAA指令调整方法：\n\n * 调整方法与AAA类似，只是此指令要分别考虑AL的高4位和低4位。\n * 若AL低四位大于9或AF=1，则AL+6—>AL，置AF=1；\n * 若AL高四位大于9或CF=1，则AL+60H—>AL，置CF=1\n\n注意：以上两条指令使用时必须紧跟在ADD或ADC之后。\n\n# 2.3.2减法调整指令\n\n非组合BCD码的减法调整指令\n\n格式：AAS 功能：对AL中由两个非组合BCD码相减的差进行调整，将结果（非组合BCD码）存于AL中。 调整过程：调整方法与AAA类似，不同的是当AL的低4位表示的数大于9或AF=1时，将AL-6--AL, AH-1 一AH，并将AF和CF置1，清除AL的高四位。\n\n说明：\n\n * 参加操作的数必须是非组合BCD数；\n * 该指令用在非组合BCD数操作之后，操作数隐含在AL中；\n * 由于该调整指令使用到AH寄存器，故先将AH内容清零。\n\nAAS指令调整方法：\n\n 1. 如果AL寄存器指令的低4位在0~9之间，AF为0，则跳过第2步执行第3步；\n\n 2. 如果AL寄存器的低4位在0AH~0FH之间或AF为1，则AL寄存器的内容减06H，同时AH寄存器内容减1，且将AF置1；\n\n 3. AL寄存器的高4位清零；\n\n 4. AF位的值送CF。\n\n组合BCD码的减法调整指令 格式：DAS 功能：对AL中由两个组合BCD码相减所得的结果进行调整，并将结果（组合BCD码）存于AL中。 调整过程：调整方法与DAA类似，不同的是当AL的低4位大于9或者 AF=1，则AL-6 一>AL，并置AF=1；而当 AL的高4位大于9或者 CF=1时，则AL-60H—>AL，并置CF=1。\n\n说明：\n\n * 参加操作的数必须是组合BCD数；\n * 该指令用在组合BCD数减法操作之后，操作数隐含在AL中。\n\n注意：使用AAS、DAS指令必须紧跟在减法指令之后。\n\n# 2.3.3乘法调整指令\n\n非组合BCD码的乘法调整指令\n\n格式：AAM\n\n功能：对AX中的由两个非组合BCD码相乘所得的结果进行调整，并将调整后的结果存于AX中。\n\n调整过程：AH<—AL/0AH（商），AL<—AL%0AH（余数）\n\n说明：\n\n * 参加操作的数必须是非组合BCD数，该指令在MUL指令之后；\n * AAM指令调整方法：因为两个非组合BCD数相乘的结果为0~81，不会到十进制数的百位，因此调整方法就是将AL寄存器的内容除以0AH，商放在AH寄存器（与除法指令不同）中，表示转换的十位整数；余数放在AL寄存器（与除法指令不同）中，表示转换的个位数。\n\n注意：本指令必须紧跟在MUL指令之后使用。\n\n# 2.3.4除法调整指令\n\n非组合BCD码的除法调整指令 格式：AAD\n\n功能：把AX中的两个非组合BCD码进行调整，然后可用DIV指令实现两个非组合BCD码的除法运算\n\n调整过程：AL<—10*AH+AL, AH<—0 注意：本指令必须在DIV运算前使用。\n\n说明：\n\n * 该操作数要满足16位除8位的除法操作做要求，即非组合BCD数需放在AX寄存器中，\n * 该指令用在DIV指令之前，先调整，后做除法操作。\n\nAAD指令调整方法：将AX中的非组合BCD数转换成二进制数，因为除数也是非组合BCD数，必须在0~9之间，实质是完成二进制数除法。\n\n# 2.3.5总结\n\n * DAA或DAS必须用在ADD (ADC)或SUB (SBB)之后，结果对OF无影响，对其他状态标志位均有影响。\n\n * AAA或AAS必须用在ADD (ADC)或SUB (SBB)之后，结果影响AF和CF，对其他标志位均无意义。\n\n * AAM必须用在MUL之后，结果影响SF、ZF和PF，对AF、CF和OF无影响。\n\n * AAD必须用在DIV之前，结果影响SF、ZF和PF，对AF、CF和OF无影响。\n\n\n# 2.4位操作指令\n\n位操作指令的共同特点如下：\n\n- 可以按二进制位进行操作。\n- 逻辑运算指令按逻辑门电路的运算规则。\n- 逻辑位移指令有左移和右移，移出的位都进入CF标志。\n- 因移空位的补充方式不同，有多种指令形式。\n- 逻辑移位指令中，移动超过1次，则用CL寄存器作为计数器。\n- 执行逻辑操作指令，CF均被清零。\n\n\n1\n2\n3\n4\n5\n6\n\n\nOP源：8/16位通用寄存器、存储器操作数或立即数\n\nOP目：通用寄存器和存储器操作数。\n\n除 “非” 运算外其余指令都会使OF=CF=0\n\n# 2.4.1逻辑运算指令\n\n逻辑与运算指令\n\n格式：AND OP目,OP源\n\n功能：将8/16位寄存器或存储器内容和源操作数 进行“与”运算。\n\n说明：\n\n * 目的操作数不能为立即寻址；\n * 可由源操作数控制，对8/16位数的某些位进行屏蔽或保留。\n\n----------------------------------------\n\n逻辑或运算指令\n\n格式：OR OP目,OP源\n\n功能：对两个操作数进行或运算，结果回送到OP目。\n\n说明：\n\n * 目的操作数不能为立即寻址；\n * 可用于组合某个字，或将某些位进行置1或保留。\n\n例：\n\n将AL中的非组合BCD码转换为ASCII码。\nOR AL,30H\n非组合BCD码：00H~09H（0~9）\nASSCII码：  30H~39H（‘0’~‘9’）\n0000 1001\n0011 0000\n----------\n0011 1001 39H\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n逻辑异或运算指令\n\n格式：XOR OP目,OP源\n\n功能：对于两个操作数进行异或运算，结果回送到OP目。\n\n说明：用于对某个二进制数按位取反或对某寄存器清0。\n\n * 相同为零，不同为1\n\n * 和1异或，相当于取反\n\n * 和0异或，相当于不变\n\n例：\n\n寄存器清0（有4条指令可达到AX清0目的）：\nXOP AL,AL\t;AL清0\nMOV AX,0\t;移位指令不影响CF\nSUB AX,AX\nAND AX,0\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n逻辑求反指令\n\n格式：NOT OP目\n\n功能：对操作数逐位取反后回送到原处。\n\n说明：\n\n * 该指令只是执行求反操作，而不是求反码指令，对符号位也求反；\n * 不影响标志位。\n * 对8/16位一次性全部取反。\n\n----------------------------------------\n\n测试指令\n\n格式：TEST OP目,OP源\n\n功能：将OP目与OP源进行 “与” 运算，不回送结果，只根据结果置标志位。\n\n说明：\n\n * 主要用来检测目的操作数的某些位是1或0，根据测试结果，决定转向。\n * 目的操作数不能为立即寻址；\n * TEST指令和AND指令的运行规则相同，但TEST指令不产生运算结果，仅影响状态标志；\n * 常用于对某位是“1”或“0”的检测。\n\n----------------------------------------\n\n总结\n\n * AND、OR、XOR、TEST均影响标志，CF=0，OF=0，而PF，SF，ZF由结果而定，AF无意义。 此指令可用来清CF，常用与拆字，拼字。\n * NOT不影响标志。\n\n\n\n----------------------------------------\n\n# 2.4.2逻辑移位指令\n\n位移操作：\n\n * 非循环移位\n   \n   * 逻辑移位\n   * 算数移位\n\n * 循环移位\n   \n   * 不带进位位的移位\n   * 带进位位的移位\n\n规定：移动一位时由指令中的计数值直接给出；位移两位及以上，则位移次数由CL指定，即必须将移位位数N事先装入CL中。\n\n----------------------------------------\n\n# -非循环位移指令\n\n\n\n * 算数左移与逻辑左移相同，可用于无符号数乘2操作；\n * 逻辑右移可用于无符号数除2操作；\n * 算数右移可以用于有符号数除2操作。\n * 算数逻辑位移指令是双操作数指令，操作数可以是立即数之外的任何寻址方式；当计数值大于1时，必须使用CL作计数器。\n\n----------------------------------------\n\n逻辑左移指令\n\n格式：SHL 目的操作数,1\n\nSHL 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容左移，移空的位补0.\n\n说明：\n\n * 使用逻辑左移指令移动1位时，源操作数为1；左移位数超过1位时，用CL寄存器控制移动次数；\n * 逻辑左移指令移动1位，则原数据乘2（在无进位的情况下）。\n\n----------------------------------------\n\n算数左移指令\n\n格式：SAL 目的操作数,1\n\nSAL 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容左移，移空的位补0。\n\n说明：\n\n * 使用算数左移指令移动1位时，源操作数为1；\n * 使用算数左移指令超过1位时，用CL寄存器控制移动次数；算数左移指令移动1位，则原数据乘2（在无进位视的情况下）\n * 算数左移指令和逻辑左移指令功能相同。\n\n----------------------------------------\n\n逻辑右移指令\n\n格式：SHR 目的操作数,1\n\nSHR 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容右移，移空的位补0。\n\n说明：\n\n * 使用逻辑右移指令移动1位时，源操作数为1；\n * 使用逻辑右移指令移动超过1位时，用CL寄存器控制移动次数；逻辑右移指令移动1位，则原数据除2（与除法指令有差别）。\n\n----------------------------------------\n\n算数逻辑右移指令\n\n格式：SAR 目的操作数,1\n\nSAR 目的操作数，CL\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由目的操作数的最高位补充。\n\n说明：\n\n * 使用算数右移指令1位时，源操作数为1；\n * 使用算数右移指令超过1位时，用CL寄存器控制移动次数；算数右移指令实质上补充的是符号位。\n\n----------------------------------------\n\n# -不带进位循环移位指令\n\n循环左移指令\n\n格式：ROL 目的操作数,1\n\nROL 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容左移，移空的位由移出位补充。\n\n说明：\n\n * 使用不带进位循环左移指令移动1位时，源操作数为1；\n * 使用不带进位循环左移指令移动超过1位时，用CL寄存器控制移动次数。\n\n循环右移指令\n\n格式：ROR 目的操作数,1\n\nROR 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由移出位补充。\n\n说明：\n\n * 使用不带进位循环右移指令移动1位时，源操作数为1；\n * 使用不带进位循环右移指令移动超过1位时，用CL寄存器控制移动次数。\n\n----------------------------------------\n\n# -带进位循环位移指令\n\n循环左移移指令\n\n格式：RCL 目的操作数,1\n\nRCL 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容左移，移空的位由CF位补充。\n\n说明：\n\n * 使用带进位循环左移指令移动1位时，源操作数为1；\n * 使用带进位循环左移指令移动超过1位时，用CL寄存器控制移动次数。\n * 该指令执行前，若CF没有置“1”或清“0”，则第一次移位时，移空位CF中的随机数补充。\n\n循环右移移指令\n\n格式：RCR 目的操作数,1\n\nRCR 目的操作数,CL\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由CF位补充。\n\n说明：\n\n * 使用带进位循环右移指令移动1位时，源操作数为1；\n * 使用带进位循环右移指令移动超过1位时，用CL寄存器控制移动次数。\n * 该指令执行前，若CF没有置”1“或清”0“，则第一次移位时，移空位由CF中的随机数补充。\n\n----------------------------------------\n\n\n# 2.5串操作指令\n\n串操作指令实现一对字符或数据的操作，分为基本串操作指令和重复前缀指令。基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。\n\n申处理指令是针对存储器操作，其共同点如下：\n\n * 源串一般存放在数据段（DS），偏移地址由SI指定，目标串在附加段（ES），偏移地址由DI指定。\n\n * 指令有特珠的寻址方式，规定源操作数的逻辑地址由DS:SI给出，目的操作数的逻辑地址由ES:DI 给出。\n\n * 由于存储单元有字型数据和字节型数据，指令的助记符则有B或 W之分。\n\n * 每执行一次串操作后自动修改指针SI、DI。若方向标志DF=0，则每次操作后SI和DI自动加1（或加2）；若DF=1，则每次操作后SI和DI自动减1（或减2）。\n\n * 使用这类指令，存储单元的地址指针是自动移动的，由 DF 标志控制指针的移动方向，DF=0，地址往增加方向移动；DF=1，地址往减小方向移动。\n\n * 串长（字或字节个数）存放在CX中。\n\n * 串的长度由 CX 给定。\n\n * 这类指令前一般可以使用指令前缀。\n\n * 这类指令后不带操作数，操作数在此指令前给定。\n\n串处理指令中需要注意的问题：\n\n * 在执行指令前必须DS、ES、SI、DI、DF、CX置好需要的值，它们是串操作指令的隐含操作数。\n\n * 当串指令在同段之间执行传送或比较等操作时，应将DS 和ES 取同样的值。\n * 当使开指令前缀进行重复操作时，CX 的值是指数据个数，不是存储单元的字节数。\n * 当使用 DF=1， 即地址指针为减小方向移动时，源操作数和目的操作数的初始地址要正确设定。\n\n----------------------------------------\n\n# 2.5.1串传送指令\n\n串传送指令\n\n格式：MOVSB——字节传送\n\nMOVSW——字传送\n\n功能：\n\n * 目的操作数 <一 源操作数。\n * 把位于数据段由SI指定的内存单元的字节/字数据传送到附加段由DI指定的内存单元，指令不影响状态标志位。\n\n说明：\n\n * 源操作数地址由 DS:SI指定，目的操作数由 ES:DI指定;\n * 指令执行时，由DF标志控制SI和 DI是增大还是减小；\n * 由指令中的B和W控制 SI 和DI 是加1/加2，还是减1/减2；\n * 指令执行一次，CX 奇存器的内容不改变。\n * 串传送指令常与无条件重复前缀连用。\n\n过程：\n\n[DI]<--[SI] 若DF=0 SI<--SI+1/2,DI<--DI+1/2\n[DI]<--[SI] 若DF=1 SI<--SI-1/2,DI<--DI-1/2\n\n\n1\n2\n\n\n----------------------------------------\n\n# 2.5.2串比较指令\n\n格式：CMPSB——字节比较\n\nCMPSW——字比较\n\n功能：\n\n * 目的操作数 一 源操作数。\n * 把位于数据段由SI指定的字节/字数据与附加段由DI指定的字节数进行比较，结果不保存，但应响状态标志位，并由DF状态决定SI、DI的修改方向。\n\n说明：\n\n * 执行指令完成内存中两串数据对应元素的减法操作，但不产生运算结果，仅影响状态标志；\n * 其余与串传送指令相同；\n * 该指令多与其他指令或指令前缀配合。\n * 串比较指令常与条件重复前缀连用，指令的执行不改变操作数，仅影响标志位。\n\n过程：\n\n[SI]-[DI] SI<--SI(+/-)1/2,DI<--DI(+/-)1/2\n\n\n1\n\n\n----------------------------------------\n\n# 2.5.3串搜索指令\n\n格式：SCASB——字节搜索\n\nSCASW——字搜索\n\n功能：把AL/AX中的内容与附加段由DI指定的一个字节/字数据进行比较，结果不保存，但影响状态标志位，并由DF状态决定DI的修改方向。\n\n说明：\n\n * 执行该指令前，将需检索的数据存入AL或AX寄存器中；\n * 指令完成内存数据串中每个元素的搜索操作，即AL/AX减串元素；\n * 该指令多与其他指令或指令前缀配合；\n * 其余与串传输指令相同。\n\n过程：\n\n字节——AL-[DI],DI<--DI(+/-)1\n  字——AX-[DI],DI<--DI(+/-)2\n\n\n1\n2\n\n\n# 2.5.4串装入指令（取字符串）\n\n格式：LODSB\n\nLODSW\n\n功能：\n\n * AL/AX <— 源操作数\n\n * 把位于数据段由SI指定内存单元的内容取到AL或AX中，并修改SI的内容，指向下一字节/字单元。\n\n说明：\n\n * 该指令每执行一次，将存储单元中的内容写入累加器；\n * 该指令多与其他指令配合，但不能有指令前缀；\n * 在软件循环中与其他指令配合，可完成复杂字符串的处理；\n * LODS指令的执行不影响标志位。\n\n----------------------------------------\n\n# 2.5.5串存储指令（存字符串）\n\n格式：STOSB\n\nSTOSW\n\n功能：\n\n * 目的操作数<— AL/AX\n * 把寄存器AL或AX中的内容存到附加段由DI指定的内存单元，并修改DI的内容，指向下一字节/字的存放单元。\n\n说明：\n\n * 该指令每执行一次，将累加器的内容写入存储单元中；\n * 该指令可以有指令前缀\n * 该指令的执行不影响标志位。\n\n----------------------------------------\n\n# 2.5.6重复前缀指令\n\n基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。\n\n无条件重复\n\nREP：\n\n * REP为重复前缀，每执行一次，CX内容减1，直到CX内容为0，才退出串处理过程，一般与MOVS指令和STOS指令配合使用。\n\n * 若CX !=0，则CX<— CX-1 继续重复操作，知道CX=0为止。\n\n----------------------------------------\n\n条件重复\n\n * （相等/为0）重复\n   \n   * REPE/REPZ\n     * 若CX !=0且ZF=1，则CX<— CX-1 继续重复操作，知道CX=0或ZF=0为止。\n\n * （不相等/不为0）重复\n   \n   * REPNZ/REPNE\n     * 若CX !=0且ZF=0，则CX<— CX-1 继续重复操作，知道CX=0或ZF=1为止。\n\n----------------------------------------\n\n注意\n\n * 重复前缀指令不能单独使用，其后必须紧跟基本串操作指令，控制基本串操作指令重复执行。其执行过程相当于一个循环控制程序的运行。在每次重复之后，地址指针SI和DI都被修改，但指针IP仍保持指向带有前缀的串操作指令的地址。\n * 重复执行次数由数据串长度决定，数据串长度应预置在寄存器CX中。\n * 执行重复前缀指令不影响标志位。\n\n----------------------------------------\n\n\n# 2.6程序控制转移指令\n\n# 2.6.1寻址方式\n\n控制转移指令在段内、段间转移时、使用直接（相对）寻址或间接寻址方式。\n\n直接寻址方式\n\n * 段内寻址方式：目标程序和源程序在同一程序段内，只给出源地址和目标地址的差值，此差值是偏移量，它是一个以IP为基准的8/16位的带符号补码数。\n\n * 段间直接寻址方式：直接给出转移目标地址的段地址和段内位移量，用前者取代CS当前的值，用后者取代IP中当前的值，使程序从一个代码段转移到另一个代码段。\n\n----------------------------------------\n\n间接寻址方式\n\n * 段内间接寻址方式：指令转移的有效地址存在一个寄存器或存储器单元中，用它取代单前IP的值，实现程序转移。\n * 段间间接寻址方式：指令给出一个存储器地址，从该地址开始的4个字节单元中存放转移目标地址的段内偏移量和段地址，这两个地址在指令执行时用于取代当前的IP和CS的内容，使程序从一个代码段转移到另一个代码段。\n\n# 2.6.2转移指令\n\n通过修改指令的偏移地址或段地址及偏移地址实现程序的转移\n\n# -无条件转移指令\n\n无条件转移到目标地址，执行新的指令。\n\n段内直接转移指令\n\n一个段内的直接无条件转移是在指令中给出一个相对位移量。该位移量是相对于IP奇存器来计算的，即有效转移地址是在IP当前的内容上加上一个8位或16位的位移量，所以也称为相对寻址。其位移量是带符号的数，这就使转移可在向前或向后的方向进行。\n\n格式：JMP NEAR PTR 目标地址\n\n补码：-32768～+32767\n\n功能：当位移量为16位带符号数时，允许在（+/-）32KB 的范国内寻找目标地址，称为段内直接近转移。\n\n格式：JMP NEAR SHORT 目标地址\n\n补码：-128～+127\n\n功能：当位移量为8位带符号数时，允许在（+/-）127字节 的范国内寻找目标地址，称为段内直接短转移。\n\n----------------------------------------\n\n段内间接转移指令\n\n格式：JMP OP(寄存器)\n\nJMP WORD PTR [BX]\n\n功能：在JMP 指令中，间接给出转移目标地址，即由一个 16位奇存器或由存储单元寻址目标地址。\n\n----------------------------------------\n\n段间直接转移指令\n\n格式：JMP FAR PTR 目标地址\n\n功能：段间转移意味着寄存器 CS 和IP的值都要改变，指令中直接采用汇编中的符号地址作为直接目标地址。\n\n----------------------------------------\n\n段间间接转移指令\n\n格式：JMP WORD PTR [BX][SI]\n\n功能：段间转移意味着寄存器 CS 和IP 的值都要改变，所以间接给出目标地址，只能由存储单元寻址。也就是说，目标地址存放在连续的4个存储单元中，低字节两个单元的内容代替IP，高字节两个单元的内容代替CS。\n\n----------------------------------------\n\n注意：\n\n * 当目标地址高于源地址时称为正向转移，偏移量是正数；\n * 当目标地址低于原地址时称为反向转移，偏移量是负数。\n\n# -有条件转移指令\n\n在具备一定条件的情况下转移到目标地址。\n\n * 条件转移指令将前一条指令执行结果对状态标志位的影响，作为程序转移的条件。满足条件时转移到指令指定的地址，否则将顺序执行下条指令。可作为判断条件的状态标志位有CF、PF、ZF、SF和OF。\n * 条件转移指令都是采用相对寻址方式的双字节指令，指令第一字节是操作码，第二字节是带符号的位移量。条件转移指令只能在当前段中实现短转移，不影响状态标志位。\n\n----------------------------------------\n\n对无符号数\n\n * JA/JNBE 目标标号 ——高于/不低于也不等于转移，CF AND ZF=0\n\n * JAE/JNB 目标标号 ——高于或等于/不低于转移，CF=0 OR ZF=1\n\n * JB/JNAE 目标标号 ——低于/不高于也不等于，CF=1 AND ZF=0\n\n * JBE/JNA 目标标号 ——低于或等于/不高于，CF=1 OR ZF=1\n\nJ ---\x3eJMP\nA ---\x3e大于\nB ---\x3e小于\nE ---\x3e等于\nN ---\x3eNOT\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n对有符号数\n\n * JG/JNLE 目标标号 ——大于/不小于也不等于转移，（SF ⊕ OF） AND ZF=0\n * JGE/JNL 目标标号 ——大于或等于/不小于转移，SF ⊕ OF=0\n * JL/JNGE 目标标号 ——小于/不大于也不等于转移，SF ⊕ OF=1\n * JLE/JNG 目标标号 ——小于或等于/不大于转移，（SF ⊕ OF）= 1 OR ZF=1\n\nG ---\x3e大于\nL ---\x3e小于\n\n\n1\n2\n\n\n----------------------------------------\n\n对标志位\n\n * JC 目标标号 ——进位位为1转移，CF=1\n * JNC 目标标号 ——进位位为0转移，CF=0\n * JE/JZ 目标标号 ——等于/结果为0转移，ZF=1\n * JNE/JNZ 目标标号 ——不等于/结果不为0转移，ZF=0\n * JO 目标标号 ——溢出转移，OF=1\n * JNO 目标标号 ——不溢出转移，OF=0\n * JNP/JNO 目标标号 ——奇偶位为0/奇偶性为奇转移，PF=0\n * JP/JO 目标标号 ——奇偶位为1/奇偶性为偶转移，PF=1\n * JNS 目标标号 ——符号标志位为0转移，SF=0\n * JS 目标标号 ——符号标志位为1转移，SF=1\n\n# 2.6.3调用和返回指令\n\n# 调用指令CALL\n\n为了程确保程序正确返回，CALL指令的类型必须与RET指令的类型相匹配。\n\nCALL指令有两种的得到目标地址的方法：直接寻址和间接寻址。直接寻址意味着目标地址在CALL指令的操作码部分直接给出。间接寻址意味着目标地址在指定的寄存器或内存单元中，以间接方式给出。\n\n一个过程用于段内调用，则在过程定义中属性应为NEAR。而另一个过程用于段间调用，则在过程定义中属性应为FAR。\n\n格式：CALL OP\n\n功能：将CALL指令的下一条指令的地址（断点地址IP【段内】或IP与CS【段间】）压栈，新的目标地址（子程序首地址）装入IP或CS中，控制程序转移到由OP指明入口的子程序。其中OP为子程序（过程）的名字。\n\n段内直接调用\n\n子过程与原调用程序在同一代码段，在调用之前需要保护断点的偏移地址。\n\nCALL NEAR 目标地址\n\n段内间接调用\n\n例如：\n\nCALL WORD PTR [SI]\nCALL BX\n\n\n1\n2\n\n\n段间直接调用\n\n子过程与原程序调用程序不在同一代码段，在调用之前需保护断点的段基址和偏移地址。\n\n先将断点的CS压栈，再压入IP。\n\nCALL FAR 目标地址\n\n段间间接调用\n\n例如：\n\nCALL WORD PTR [SI]\nCALL BX\nCALL WORD PRT 62[BX][DI]\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 返回指令RET\n\n格式：RET\n\n功能：通常作为一个子程序的最后一条指令，用以返回到调用子程序的断点处，即从堆栈弹出断点送IP和CS。\n\n操作过程：\n\n * 1.从栈顶弹出一个字给IP，SP+2 -> SP\n * 2.从栈顶弹出一个字给CS，SP+2 -> SP\n * 对于段内调用只有（1）。\n\n----------------------------------------\n\n# 2.6.4循环控制指令\n\n * 使用循环控制指令之前，必须在CX（计数器）中预置循环次数的初值。\n * 不影响状态标志位。\n * 主要用于数据块比较、查找关键字等操作。\n\n# 计数循环\n\n格式：LOOP 目标标号\n\n功能：CX-1 —> CX，若CX!=0，循环转移到目标标号，直到CX=0退出循环。\n\n# 结果为0/相等循环\n\n格式：LOOP/LOOPE 目标标号\n\n功能：CX-1 —> CX，若CX!=0且ZF=1时，循环转移到目标标号，直到CX=0或ZF=0退出循环。\n\n# 结果不为0/不相等循环\n\n格式：LOOPNZ/LOOPNE 目标标号\n\n功能：CX-1—> CX，若CX!=0且ZF=0时，循环转移到目标标号，直到CX=0或ZF=0时退出循环\n\n# 计数为0转移\n\n格式：JCXZ 目标标号\n\n功能：若CX=0时，则转向目标标号，否则顺序执行。\n\n\n# 2.7处理器控制指令\n\n# 2.7.1标志操作指令\n\n格式：\n\nCLC\t\t清除进位标志，置CF=0\nCTC\t\t置1进位标志，置CF=1\nCMC\t\t取反进位标志，置CF=!CF\nCLD\t\t清楚方向标志，置DF=0\nSTD\t\t置1方向标志，置DF=1\nCLI\t\t清楚中断标志，置IF=0\nSTI\t\t置1中断标志，置IF=1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这些操作指令完成对标志位的置位、复位等操作，这些指令只影响与其相关的标志位。\n\n# 2.7.2 CPU控制指令\n\n# 处理器暂停指令\n\n格式：HLT\n\n功能：使处理器处于暂时停机状态。\n\n说明：HLT引起的暂停，只有RESET（复位）、NMI（非屏蔽中断请求）信号可以使CPU退出暂停状态。\n\n# 处理器等待指令\n\n格式：WAIT\n\n功能：执行WAIT指令之后，处理器处于等待状态，直到检测到TEST引脚有效，才能退出等待状态，执行后续指令。\n\n说明：用于处理器与外设同步。\n\n# 处理器交权指令\n\n格式：ESC EXTOPCD,OP源(其中EXTOPCSD为外部操作码，OP源为操作数)\n\n功能：用来为协处理器提供提供一个操作码和操作数，以便完成主机对协处理器的某种操作要求。\n\n# 空操作指令（延时）\n\n格式：NOP\n\n功能：在执行本指令期间，CPU不完成任何操作，只是每一条NOP指令，耗费3个时钟周期的时间。\n\n总线封锁指令\n\n格式：LOCK\n\n功能：在CPU访问存储器或外设时，总线控制器会对总线进行封锁，使其他处理器得不到总线控制权，从而就不能访问存储器或外设。\n\n说明：LOCK指令可以放在任何一条指令前，所以LOCK指令实际上是一个特殊的1字节封锁线。它使工作在最大模式下的8086CPU，在执行下一条指令期间发出总线封锁信号，即LOCK引脚变为低电平有效信号。\n\n\n# 2.8输入输出指令\n\nCPU对外设端口有两种寻址方式，即直接寻址和间接寻址。直接寻址范围为0000H~0FFFFH共64K个端口。间接寻址时，只能用DX作间址寄存器。\n\n# 输入指令\n\n格式：IN 累加器,端口\n\n功能：把一个字节/字由输入端口传送到AL/AX中。\n\n# 输出指令\n\n格式：OUT 端口,累加器\n\n功能：把AX中的16位数或AL中的8位数输出到指定端口。\n\n\n# 2.9中断指令\n\n# 2.9.1溢出中断指令\n\n格式：INTO\n\n功能：检测OF标志位。当OF=1时，产生一个中断类型4的中断；当OF=0时，本指令不起作用。\n\n注意：影响标志位IF、TF。\n\n# 2.9.2软中断指令\n\n格式：INT n（n为中断类型信号）\n\n功能：产生一个软件中断，把控制转向一个类型型号为n的软中断。\n\n注意：\n\n * 影响标志位IF、TF。\n * n为中断类型信号（起到索引的作用），可以是常数或常数表达式，其值在0~255的范围内。\n\n# 2.9.3中断返回指令\n\n格式：IRET\n\n功能：让CPU执行完中断服务程序后，正确返回原程序的断点处。\n\n注意：影响所有标志位。\n\n\n# 3.常用伪指令\n\n\n# 3.1宏汇编语言的基本语法\n\n# 3.1.1常数、变量和标号\n\n常数\n\n没有任何属性的纯数值。在汇编期间，它的值已经完全确定，而且在程序的运行中也不会发生变换。它可以有以下几种类型：\n\n * 二进制数：以字母B结尾的一串“0”和“1”组成的序列。\n * 八进制数：以字母o或Q结尾，由若干个0到7的数字组成的序列。\n * 十进制数：由若干个0到9的纯数字组成的序列，可以以字母D结尾，也可以省略字母D。\n * 十六进制数：以字母H结尾，由若干个0到9的数字和字母A到F组成的序列，且必须以数字开头。\n * 字符串常数：用引号括起来的一个或多个字符。这些字符以ASCII码形式存在内存中。\n\n注意：为了区别A~F组成的一个字符串是十六进制数还是英文符号，规定在前面冠以数字“0”。\n\n总之，常数主要以立即数、位移量的形式出现在指令语句或数据定义的伪指令中。\n\n----------------------------------------\n\n变量\n\n变量：通常是存放在某些存储单元的数据，这些数据在程序运行期间可以修改。\n\n变量名：表示数据在段中的有效地址，由用户指定。变量名是可选的，如果使用变量名，它代表数据区中第一个数据项的地址。\n\n变量的三个属性：\n\n * 段属性（SEGMENT）：表示变量所在段首地址\n * 偏移属性（OFFSET）：表示变量的偏移地址\n * 类型属性（TYPE）：表示变量占用存储单元的字节数。\n   * 类型：字节（DB）、字（DW）、双字（DD）、四字、十字节类型，变量是用数据定义伪指令DB，DW，DD等定义的。\n\n注意：变量也可以定义为一个数据区或存储区，但变量名仅表示该数据区域的第一个数据单元（即数据区或存储区的首地址）。\n\n----------------------------------------\n\n标号\n\n * 表示一条指令所在的地址，也是指令语句的地址符号，常用作转移指令（包含子程序调用指令）的操作数，即目标地址。\n * 通常由字母数字串组成但第一个字符必须为字母。最多允许使用31个字符，且可以使用下划线，使标号容易阅读。\n\n标号的三个属性：\n\n * 段属性（SEGMENT）：表示标号所在的段基址\n\n * 偏移属性（OFFSET）：表示标号的偏移地址\n\n * 距离属性（类型属性TYPE）：表示标号作为段内或段间的转移属性\n\n距离属性分为两种：\n\nNEAR（近）：表示标号只能被所在段内的转移和调用使用指令访问（即段内转移）。\n\nFAR（远）：表示本标号可以被其他段（不是标号所在段）的转移和调用指令访问（即段间转移）。\n\n# 3.1.2运算符号与表达式\n\n表达式：\n\n * 数值表达式：只产生数值结果\n * 地址表达式：产生的结果是一个存储器地址，若该地址存放的是数据，一般称它为变量，若存放的是指令，一般称它为标号。\n\n运算符主要包括一下6种类型：\n\n1.算数运算符\n\n包括：+、-、*、/、MOD(求余)、SHL(左余)\n\n2.逻辑运算符\n\n包括：AND、OR、XOR、NOT。只适用于对常数进行逻辑运算。\n\n3.关系运算符\n\n包括：EQ(相等)、NE(不相等)、LT(小于)、GT(大于)、LE(小于或等于)、GE(大于或等于)\n\n结果：\n\n * 若关系为假（不成立），结果为0；\n * 若关系为真（成立），结果为0FFH或0FFFFH。\n\n4.分析操作符（数值返回运算符）\n\n * 取地址的偏移量\n   \n   格式：OFFSET 变量名或标号\n   \n   功能：取变量名或标号所在的段内偏移量。\n\n * 取段基址\n   \n   格式：SEG 变量名或标号\n   \n   功能：取变量名或标号所在的段首地址。\n\n * 求变量名或标号的类型值\n   \n   格式：TYPE 变量名或标号\n   \n   功能：放回一个数字值。若TYPE加在变量名前，返回该变量的类型属性；若加在标号前，返回该变量的距离属性。\n   \n        属性     类型值\n   变量   BYTE   1\n   变量   WORD   2\n   变量   WORD   4\n   标号   NEAR   -1\n   标号   FAR    -2\n\n * 求长度\n   \n   格式：LENDTH 变量名\n   \n   功能：返回一个变量名所占存储单元（字节、字或双字）的数目。若变量是用重复定义子句说明的，则返回DUP前面的数值；其余返回1。\n\n * 求大小\n   \n   格式：SIZE 变量名\n   \n   功能：返回变量名所占将存储单元的字节数，它等于LENGTH和TYPE两个运算符返回的乘积。\n\n5.综合运算符\n\n * PTR运算符\n   \n   格式：类型 PTR 表达式\n   \n   功能：用于指出变量、标号或地址表达式的类型属性，新的类型只在当前指令内有效。\n\n * THIS运算符\n   \n   格式：THIS 类型\n   \n   功能：把它后面指定的类型或距离属性赋给当前的变量、标号或地址表达式。\n\n注：THIS使下面的原标号或原变量有新的名字和类型，但不分配新的存储单元。\n\n6.其他运算符\n\n * HIGH和LOW运算符\n   \n   格式：HIGH 表达式、LOW表达式\n   \n   功能：从运算对象中分离出高字节或低字节。\n\n * SHORT运算符\n   \n   格式：SHORT 标号\n   \n   功能：当转移的目标地址与本转移指令的下一条指令之间的字节距离在-128~127范围时，可以使用SHORT运算符进行说明。\n\n\n# 3.2伪指令\n\n8086宏汇编语言有两种类型的语句：\n\n指令语句：在汇编过程中被翻译成相应的目标代码，经连接后生成可执行的机器指令代码。\n\n伪指令语句：（指示性语句）在汇编时被解释执行，由汇编程序来处理的一类操作，如数据定义，分配存储器等。\n\n# 3.2.1伪指令语句的格式\n\n格式：符号名 定义符 操作数;注释\n\n# 5.2.2常用伪指令\n\n1.符号定义伪指令（赋值语句）\n\n * 等值伪指令\n   \n   格式：符号名 EQU 表达式\n   \n   功能：将表达式的值赋给符号名。\n   \n   注意：符号名一旦被EQU定义，就不能再赋值，即不能用EQU再为符号名重新赋值。\n\n * 等号伪指令\n   \n   格式：符号名 = 表达式\n   \n   功能：将表达式的值赋给符号名。\n   \n   说明：可以在程序中不同的地方多次使用以重新为符号名赋值。\n\n * 定义符号名伪指令\n   \n   格式：符号名 LABEL 类型\n   \n   功能：定义一个标号或变量，并指定其类型。\n\n----------------------------------------\n\n2.数据定义伪指令\n\n格式：\n\n[变量名] DR 表达式 ; 定义字节\n[变量名] DW 表达式 ; 定义字\n[变量名] DD 表达式 ; 定义双字\n[变量名] DQ 表达式 ; 定义8个字节\n[变量名] DT 表达式 ; 定义10个字节\n\n\n1\n2\n3\n4\n5\n\n\n表达式——是赋给变量的初始值，可以有一个，也可以有多个，常见的有以下几种：\n\n * 数值表达式：\n   \n   实际上是为数据分配存储单元，并把变量名作为该存储单元的名称。若要定义多个相同类型的数据，可用逗号把这些数据隔开，并依次分配在相邻的存储单元。\n\n * ASCII字符串\n   \n   字符串必须用引号括起来，并且不超过256个字符，它们在内存中按地址递增顺序自左向右依次存放再付的ASCII码。\n\n * ？——为数据项分配存储单元的一种方法，只是存储单元中不预置确定的值，常用来预留存储储单元，存放程序的中间结果或最终结果。\n\n * 重复定义子句DUP——可以为若干个重复数据分配存储单元。\n   \n   格式：n DUP (表达式)\n   \n   说明：n:重复次数 表达式：重复的内容\n   \n   注意：\n   \n   * DUP操作可以嵌套。\n   * 在定义变量及存储单元的同时，也定义了它们的类型属性。同一数据定义语句所定义的各存储单元具有相同的类型。\n\n----------------------------------------\n\n3.段定义伪指令\n\n格式：段名 SEGMENT [定义类型][组合类型][‘类别名’]\n\n功能：把模块化分为若干逻辑段。每个SEGMENT/ENDS可定义一个逻辑段。\n\n----------------------------------------\n\n4.段寄存器说明伪指令\n\n格式：ASSUME 段寄存器:段名[，段寄存器:段名…]\n\n功能：向汇编程序指示当前各段所用的段奇存器，设定段寄存器与段的对应关系。\n\n注意： ①本伪指令貝是指示各逻辑段使用寄存器的情況，没有对段奇存器内容进行装填。段寄存器的实际值(CS除外）还要由MOV指令在程序中装填数据。 ②也可用来取消段奇存器与段之间的对应关系（用NOTHING)，然后再建立新的对应关系。\n\n----------------------------------------\n\n5.过程定义伪指令指令\n\n过程是程序的一部分，它可以被程序调用。每次可调用一个过程，当过程中的指令执行完后，控制返回调用它的地方。过程的定义是用过程定义伪指令完成的。\n\n格式：\n\n过程名 PROC [NEAR/FARI]\n\t\t…\n\n\t  RET\n过程名 ENDP  可有多个RET，一般作为最后一条指令\n\n过程名:自定义符，开始、结束要相同；有三个属性 （段地址，偏移地址和距离属性）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n6.模块定义及通信伪指令\n\n汇编语言可以把程序划分成许多模块，并对每个模块独立地进行汇编和调试。\n\n * 模块开始伪指令\n   \n   格式：NAME 模块名\n   \n   功能：指明程序模块的开始，并指出模块名。\n   \n   说明：模块名是自定义符，不能是系统保留字。若该项缺省，则取TITLE语句中的页标题6个字符；若没有TITLE语句，则取源程序文件名为模块名。\n\n * 模块结束伪指令（源程序结束伪指 令）\n   \n   格式：END启动标号或过程名\n   \n   功能：END表示一个模块（源程序）的结束。通知汇编程序源程序到此结束，并给出执行程序的入\n\n注意：\n\n * END与NAME联合使用，当NAME缺省时，END 值表示原程序的结束。\n * 汇编处理只进行到END为止。\n\n\n# 3.3宏定义\n\n宏定义及其调用\n\n宏定义格式：\n\n宏指令名 MACRO [形参，形参，...]\n\t\t\t... 宏体\n\t\t\tENDM\n\n\n1\n2\n3\n\n\n宏调用的格式为：宏指令名 [实参，实参，...]\n\n----------------------------------------\n\n扩展\n\n格式：ORG 偏移地址(16位地址)\n\n功能：声明偏移地址\n\n格式：$\n\n功能：取当前偏移地址\n\nORG + 16位地址 ：声明偏移地址",normalizedContent:"# 第三章、指令系统与汇编语言程序设计\n\n三、指令系统与汇编语言程序设计\n（一）知识范围\n指令系统的概念、指令格式；\n对操作数的寻址方式；\n常用指令（传送指令、算术运算指令、逻辑运算和移位指令、串操作指令、程序控制指令与处理器控制指令）；\n汇编语言程序的基本结构；\n常用伪指令（数据定义、符号定义、段定义、设定段寄存器）；\ndos功能调用（输入/输出字符、输入/输出字符串、结束程序）；\n三种结构（顺序结构、分支结构和循环结构）程序设计；\n常用程序设计举例。\n（二）考核要求\n1.\t理解指令系统的概念及指令格式。\n2.\t掌握常用的寻址方式并能熟练地使用它们。\n3.\t掌握常用指令的格式、功能和使用方法，分析各种指令执行后的结果。\n4.\t掌握指令对状态标志的影响。\n5.\t掌握常用伪指令的格式和功能。\n6.\t掌握汇编语言源程序的构成，熟练掌握汇编语言程序上机调试运行过程。\n7.\t理解程序的三种基本结构，能够使用汇编语言解决常见的问题。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1. 指令系统及指令格式\n\n特点：\n\n * 指令系统的兼容性\n * 指令系统的灵活性\n * 寻址方式的多样性\n * 可对多种类型的数据进行处理\n * 可构成多处理机系统\n\n**指令：**控制计算完成特定操作的命令\n\n**指令系统：**指令系统是计算机能够执行全部命令的集合，它其取决于计算机的硬件设计。指令系统因机而异，没有通用性。\n\n指令中应包含的信息：执行的运算、运算结果的去向、运算数据的来源\n\n指令格式：\n\n操作码\t\t [操作数]\t,\t[操作数]\n----- \t   --------     --------\n   |\t\t\t|\t\t\t|\n执行何种操作\t目的操作数  ， 源操作数【参加操作的数据】\n\n源操作数：指令加工前的数据\n目的操作数：指令加工之后形成的数据\n\n零操作数指令：操作码\n单操作数指令：操作码\t操作数\n双操作数指令：操作码\t目的操作数，源操作数\n\n操作数形式：\n立即数、寄存器、存储器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# 1.1操作数形式\n\n立即数操作数：\n\n * 表示参加操作的数据本身，可以是8位或16位；\n * 立即数无法作为目标操作数；\n * 立即数可以是无符号或带符号数，其数值应在可取值范围内。\n\n寄存器操作数：\n\n * 表示参加运算的数存放在指令给出的寄存器中，可以是16位或8位。\n\n存储器操作数：\n\n * 表示当前参加运算的数存放在存储器的某一个或两个单元中。\n\n指令的字长与指令的执行速度：\n\n * 指令字长由操作码的长度、操作数地址长度、操作数个数决定\n * 8088/8086 cpu采用变字长指令格式\n * 指令的字长影响指令执行的速度\n * 对不同的操作数，指令执行的时间不同：\n\n存储器 → 立即数 → 寄存器\n----------------------\n慢\t\t→\t\t  快\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 1.2 8086的操作码\n\n指令由操作码（opcode）和操作数（地址码）组成。8086 的指令长度是可变的，一条指令般由 1~6字节组成（加上前级字节，最长可为7宇节)。指令的操作码采用二进制代码表示本指会所执行的操作，通常用指令的第一个字节表示。有时由于用8位不够，因此在指令的第二个字节中还可能占了位。除此以外的其他字节 （或位）用来表示操作数。 在多数操作码中，使用某些位来指示有关信息，常用的符号及含义如下： ◎w（字位）：表示本指令是对字（w=1）还是对字节（w=0）操作。\n\n◎d（方向位）：表示参加操作的寄存器是作为目的操作数寄存器（d=1）还是作为源操作数寄存器（d=0）。\n\n◎s（符号扩展位）：用于某些立即寻址的机器指令中。如果立即数为8位，但要求扩展成16位，则s=1；否则，s=0（所扩展的高8位要根据8位立即数的最高位来定）。\n\n----------------------------------------\n\n\n# 1.3 8086指令中寄存器的编码\n\n 1. 指令的二进制一般形式\n\n8086指令的二进制一般形式如下：操作码 d/v/s w\n\n 2. 编码模式\n\n编码方式主要有以下三种：段寄存器编码、通用寄存器编码、内存寻址编码。\n\n * 段寄存器编码\n\n编码   段寄存器编码\n00   es\n01   cs\n10   ss\n11   ds\n\n * 通用寄存器编码\n\n编码    16位寄存器名   8位寄存器名\n000   ax        al\n001   cx        cl\n010   dx        dl\n011   bx        xl\n100   sp        ah\n101   bp        ch\n110   si        dh\n111   di        bh\n\n * 内存寻址编码\n\nr/m编码   基址寄存器   变址寄存器\n000     bx +    si\n001     bx +    di\n010     bp +    si\n011     bp +    di\n100             si\n101             si\n110     bp      \n111     bx      \n\n8086指令中通常使用一个或两个操作数，在少数指令中隐含的第三个操作数。\n\n\n# 1.4指令的寻址方式\n\n指令的寻址方式就是寻找指令操作数所在地址的方式，以确定数据的来源和去处。\n\n 1. 立即寻址（立即数寻址）：\n\n指令操作数部分直接给出指令的操作数，它与指令操作码相接，顺序存放在代码中。立即数有8位和16位之分。\n\n注意：\n\n * 立即寻址方式只能用于源操作数，主要用于给寄存器赋值。\n * 立即寻址方式不执行总线周期，执行速度快。\n\n----------------------------------------\n\n 2. 寄存器寻址：\n\n * 操作数放在寄存器内，由指令直接给出某个寄存器的名字，以寄存器的内容作为操作数。\n * 寄存器可以是16位的ax、bx、cx、dx、si、di、sp、bp寄存器，也可以是8位的ah、al、bx、xl、ch、cl、dh、dl寄存器。\n\n注意：\n\n * 寄存器寻址方式的指令操作在cpu内部执行，不需要执行总线周期，执行速度快。\n * 寄存器寻址方式既适用于指令的源操作数，也适用于目的操作数，并且可同时使用于源操作数和目的操作数。\n\n----------------------------------------\n\n 3. 直接寻址：\n\n操作数在存储器中，指令中直接给出操作数所在存储单元的有效地址ea，即段内偏移地址，表示操作数所在存储单元距离段首址的字节数。有效地址是一个无符号的16位二进制数。（直接给出偏移地址）\n\n注意：\n\n * 直接寻址方式的操作数所在存储单元的短地址一般在数据段寄存器ds中。（默认ds段）\n * 如果操作数在其他段，则需要在指令中用段超越前缀指出相应的段寄存器名。\n\n----------------------------------------\n\n 4. 寄存器间接寻址：\n\n * 操作数在存储器中，指令中寄存器的内容作为操作数所在单元的有效地址ea（偏移地址）。寄存器仅限于bx、bp、si、di。\n\n\t|[si]\n\t|[di]\nea- |[bx]\n\t|[bp]\n\n\n1\n2\n3\n4\n\n * 当使用bx、si、di时，操作数所在存储单元的段地址存在数据段寄存器ds中。\n * 当使用bp时，操作数所在存储单元的段地址存在堆栈段寄存器ss中。\n\n注意：\n\n * 只有si、di、bx、bp可作为间接寻址器。\n * 若操作指令所在存储单元不在数据段ds中，需要在指令中用段超越前缀表明其所在段的段名。\n\n----------------------------------------\n\n 5. 基址寻址：\n\n * 操作数在存储器内，指令中寄存器（bx或bp）的内容与指令指定的位移量之和作为操作数所在存储单元的有效地址ea（偏移地址）。\n\n\t|[bx]|\nea= |\t |->[8位或16位位移量]\n\t|[bp]|\n\n\n1\n2\n3\n\n * 当使用bx时，段地址为ds的内容；\n * 当使用bp时，段地址为ss的内容。\n\n----------------------------------------\n\n 6. 变址寻址：\n\n * 操作数在存储器内，指令将变址寄存器si、di内容与指令指定的偏移位移量之和作为操作数所在存储单元的有效地址ea（偏移地址）。段地址规定为ds的内容。\n\n\t|[si]|\nea= |\t |->[8位或16位位移量]\n\t|[di]|\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n 7. 基址加变址寄存器：\n\n * 操作数在内部寄存器内。指令将基址寄存器bx、bp与变址寄存器si、di的内容之和再加上之前的偏移量（8位或16位），得到操作数所在存储单元的有效地址ea。\n\n\t|[si]|\t |[si]|\nea= |\t | + |\t  | + ->[8位或16位位移量]\n\t|[di]|\t |[di]|\n\n\n1\n2\n3\n\n * 当使用bx时，段地址寄存器为ds。\n * 当使用bp时，段地址寄存器为ss。\n\nmov 寄存器,[bx/bp+si/di+n]\n // n为16进制地址,\n\n\n1\n2\n\n\n----------------------------------------\n\n 8. 字符串寻址：\n\n * 用于字符串操作指令。规定变址寄存器si中的内容是源数据串的段内偏移地址，而变址寄存器di中的内容是目标数据串的段内偏移地址。\n * 源数据串的地址规定是数据段ds，目标数据串的段地址规定是附加段es。指令执行后si和di的内容自动增量（或减量），增（或减）值为1或2。\n\n----------------------------------------\n\n 9. i/o端口寻址：（独立编址）\n\n * 寻址输入输出设备的端口地址，可分为直接端口寻址和间接端口寻址。\n * 直接端口寻址：由指令直接给出i/o设备的端口地址。它规定端口地址为8位，能寻址256个端口\n * 间接端口寻址：由dx给出i/o设备的端口地址。由于dx是16位，因此间接端口地址能寻址多达64k个端口。\n\n例如：\n\nin al,20h;\t将地址为20h的外设内容读入al中。\nout dx,al;\tal中内容输出给以dx的内容为地址的外设。\n\n\n1\n2\n\n\n----------------------------------------\n\n 10. 隐含寻址：\n\n指令隐含了的一个或两个操作数的地址，即操作数在默认的地址中。\n\n例如：\n\naaa;\t对al中的内容进行十进制加法调整，并把调整后的结果放入ah和al中。这条指令的隐含操作数是ah和al。\n\n\n1\n\n\n\n# 2.8086的指令系统\n\n指令系统包括九大类、133种基本指令，通过寻址方式的变化与数据形式（字节、字型）的组合，可构成上千条指令。指令系统按功能分为：数据传送类、算数运算类、逻辑运算与移位类、串操作类、控制转移类、处理机控制、输入输出、中断等。\n\n\n\n----------------------------------------\n\n\n# 2.1传送类指令\n\n# 2.1.1数据传送指令\n\n数据传送类指令实现cpu内部寄存器之间、cpu与内存储器之间、cpu与i/o端口之间的数据传送。\n\n通用数据传送指令\n\n包括mov、进栈（push）、出栈指令（pop）、交换指令和换码指令。\n\n * 一般数据传送指令mov（8位/16位）\n\n格式：mov\top目的操作数,op源操作数\n功能：op源操作数 ——> op目的操作数\n要求：op目 可以是寄存器（除cs外）、存储器 op源可以是寄存器、存储器和立即数。\n\n\n1\n2\n3\n\n\n该指令有如下9种形式：\n\nmov reg,reg\t\t\t;通用寄存器间传送\nmov reg,imm\t\t\t;立即数送通用寄存器\nmov mem,imm\t\t\t;立即数送存储器\nmov mem,reg\t\t\t;通用寄存器送存储器\nmov reg,mem\t\t\t;存储器送通用寄存器\nmov segreg,reg\t\t;通用寄存器送段寄存器（cs除外）\nmov reg,segreg\t\t;段寄存器送通用寄存器（含cs）\nmov segreg,mem\t\t;存储器送通用寄存器（cs除外）\nmov mem,segreg\t\t;段寄存器送存储器（含cs）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意：\n\n * mov指令的两个操作数（源、目的）均可采用不同的寻址方式。\n\n * 源操作数和目的操作数的类型必须一致。\n\n * 源和目的不能都是存储器操作数。\n\n * 不允许把立即数做目的操作数，也不允许向段寄存器（cs、ds、ss、es）送立即数。\n\n * 不允许在段寄存器之间、存储单元之间传送数据。\n\n * cs、ip寄存器不能用作目的操作数。\n\n * 一般传指令不影响标志位。\n\n----------------------------------------\n\n堆栈操作指令\n\n堆栈：是按 “后进先出” 原则工作的一段存储区域。\n\n堆栈寄存器ss —— 段地址\n\n堆栈指针sp —— 始终单前栈顶所在的存储单元地址，即最新入栈数据所在存储单元的地址。\n\n压栈操作(进栈指令)：push op(源操作数)\n\n功能：把op(源操作数)字节数据压入栈中，结果sp-2 ——> sp\n\n原则：高字节压在高地址，低字节压在低地址\n\n执行过程：\n\nsp <-- sp - 1;\t\t[sp] <-- oph\nsp <-- sp - 1;\t\t[sp] <-- opl\n\n\n1\n2\n\n\n堆栈操作总是对16位的数据进行，指令中目的操作数隐含为堆栈。进栈操作把数据传输到以ss为段基址、sp为偏移地址的栈中。其操作过程如下：\n\n * sp减一，指示堆栈中可以存放数据的位置，存放源操作数的高8位。\n * sp再减一，存源操作数的迪8位，完成进栈操作。\n\n出栈操作(出栈指令)：pop op(目操作数)\n\n功能：从栈中弹出数据 ——> op(目操作数)，结果sp+2——>sp\n\n执行过程：\n\nopl <-- [sp];\t\tsp <—— sp+1\noph <-- [sp];\t\tsp <—— sp+1\n\n\n1\n2\n\n\n例如：\n\n已知：ax=1122h,bx=3344h,sp=1010h\n执行指令：push ax\n\t\tpush bx\n\t\tpop ax\n\t\tpop bx\n执行后ax，bx，sp的结果？\n解：ax=3344h\n   bx=1122h\n   sp=1010h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意：\n\n * 堆栈操作总是按字进行的。\n * 压入指令，sp-2，数据在栈顶。弹出指令正好相反。\n * 操作数可以是存储器、寄存器或段寄存器操作数 （cs不能用于pop），不能是立即数。\n\n----------------------------------------\n\n# 2.1.2目标地址传送指令\n\n此类指令的功能是将操作数所在存储器的地址送入目标寄存器。\n\n注意：\n\n * op源必须是存储器操作数，op目必须是16为的通用寄存器。\n * 地址传输指令不影响状态标志位。\n\n----------------------------------------\n\n取有效地址指令\n\n格式：lea 16位寄存器(op目的操作数),源操作数偏移地址(op源操作数)\n\n功能：存储器地址送到一个寄存器。\n\n例如：\n\nlea si,[2040h]\n指令执行后，si中的内容为2040h。又如：\nmov si,[2040h]\n指令执行后，si中有偏移地址为2040h单元中的内容，而不是2040h这个值。\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n将地址指针装到ds和另一个寄存器的指令\n\n格式：lds 16位寄存器(op目的操作数),源操作数偏移地址(op源操作数)\n\n功能：把op源指定的4个字节内容取出，低地址的两个字节—>op目，高地址的两个字节—>ds。\n\n例如：\n\nlds di,[2130h]\n2130h和2131h的单元中的内容送到di；\n2132h和2133h的单元中的内容送到ds；\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n将地址指针装到es和另一个寄存器的指令\n\n格式：les 16位寄存器(op目的操作数),源操作数偏移地址(op源操作数)\n\n功能：本指令与lds指令的操作数基本相同，所不同的是将op源4个字节中的高地址的两个字节—>es。\n\n例如：\n\nles di,[2130h]\n2130h和2131h的单元中的内容送到di；\n2132h和2133h的单元中的内容送到es；\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 2.1.3标志寄存器传送指令\n\n读取标志指令\n\n格式：lahf ; ah <— 标志寄存器低八位\n\n特点：此指令操作结果不影响标志寄存器。\n\n----------------------------------------\n\n设置标志指令\n\n格式：sahf ; 标志寄存器低8位 <— ah\n\n特点：此之指令直接为标志寄存器的低8位赋值。\n\n----------------------------------------\n\n对标志寄存器的堆栈操作指令\n\n格式：pushf ; 将标志寄存器的值压栈。\n\npopf ; 从栈顶弹出一个字送标志寄存器。\n\n特点：\n\n * pushf不影响标志寄存器，而popf直接为标志寄存器赋值。\n * 通常两条指令成对出现，用来保护和恢复标志寄存器的内容。\n\n----------------------------------------\n\n# 2.1.4累加器专用传输指令\n\n数据交换指令\n\n格式：xchg op1(目的操作数),op1(源操作数)\n\n功能：实现op1和op2的内容的相互交换。\n\n操作数：通用寄存器或存储器，但不能均为内存单元。\n\n注意：段寄存器和ip不能作为交换指令的操作数。\n\n----------------------------------------\n\n换码指令（查表指令、翻译指令）\n\n换码指令是一条完成字节翻译功能的指令。它可以使累加器中的一个值变化为内存表格中的某一个值，一般用来实现编码制的转换。\n\n格式：xlat\n\n功能：\n\n[bx+al] —> al\n\t|----\x3e ea\n\n\n1\n2\n\n\n说明：将bx和al内容相加作为有效地址ea，在一个表格中找出此单元中的内容—>al。\n\nbx——表格的首地址\n\nal——相对于表格首地址的位移量（要装换的代码）\n\n注意：\n\n * 使用前，先建立被转换代码（字节型）的数据表。\n * 换码指令只能使用寄存器bx、al，不影响标志位。\n\n----------------------------------------\n\n输入指令\n\n格式：in al,n\n\nin ax,n\n\nin al,dx\n\nin ax,dx\n\n说明：以上四种指令格式分别是8位/16位端口地址组合形式；指令中n表示为8位端口地址（00h~ffh），此时地址线高8位默认为0；当端口地址为16位时，指令中采用寄存器间接寻址，应先将16位端口地址传输到dx中，然后dx中的地址在in指令中间接寻址。\n\n----------------------------------------\n\n输出指令\n\n输入指令\n\n格式：out n,al\n\nout n,ax\n\nin dx,al\n\nin dx,ax\n\nout指令除源操作数和目的操作数与in指令相反外，其他相同。\n\n可见，无论是输入指令还是输出指令，其中地址部分的寻址方式要么是直接寻址，要么是寄存器寻址。\n\n\n# 2.2算数运算类指令\n\n8086的算数运算类指令能够对二进制或十进制（bcd码）数进行加、减、乘、除运算，操作数的数据形式可以是8位或16位的无符号数或带符号数。\n\n# 2.2.1加法指令\n\n不带进位的加法指令：\n\n格式：add op目,op源\n\n功能：op目<— op源+op目，根据结果设置标志位（fr）。\n\n注意：两操作数的类型相同，类型明确，不能同为存储器操作数。\n\n进位的加法指令\n\n格式：adc op目,op源\n\n功能：op目<—op源+op目+cf，置标志位\n\n说明：只要用于多字节运算，多字节运算时低位字节产生进位应加到高位。\n\n加1指令\n\n格式：inc op\n\n功能：op <— op+1\n\n说明：常用于修改偏移地址和计数次数。操作数可以是8/16位通用寄存器操作数，不能为立即数。\n\n注意：\n\n * inc指令不影响cf位，影响标志位af、of、pf、sf和zf。\n * 操作数视为无符号数。\n\n总结：以上三条指令运算结果将影响状态标志位，但inc不影响标志cf。\n\n# 2.2.2减法指令\n\n不带借位的减法指令\n\n格式：sub op目,op源\n\n功能：op目<— op目-op源，并根据结果设置标志\n\n说明：\n\n * 指令的目的操作数不能是立即寻址；\n * 减法操作中产生的借位进入cf标志；\n * 无符号操作数相减，若cf=1，则结果为补码；\n * 带符号操作数相减要考虑溢出。\n\n带借位的减法指令\n\n格式：sbb op目,op源\n\n功能：op目<—op目-op源-df，并根据结果设置标志。\n\n说明：\n\n * 主要用于多字节或多精度数据相减的运算。\n * 指令中有3个操作数，其中cf是本指令执行前的状态；\n * 本指令在需要完成多字节数（如4字节的32位数或更多字节）相减时时使用；\n * 指令的目的操作数不能是立即寻址（立即数）；\n * 无符号操作数相减，若cf=1，则结果为补码；\n * 带符号操作数相减要考虑溢出。\n\n减1指令\n\n格式：dec op目\n\n功能：op目<—op目-1，根据结果置标志位，不影响cf。\n\n说明：\n\n * 操作数不能是立即寻址；\n * 该指令不影响cf标志；\n * 操作数为内存寻址时，需使用伪指令。\n\n取补指令\n\n格式：neg op\n\n功能：0-op—>op,将操作数取补后回送原操作数op可以是8/16位通用寄存器和存储寄存器操作数，不能为立即数。\n\n说明：\n\n * 对80h或8000h取补时，操作数没有变化，但of=1。\n\n * 对cf影响较特殊，只要操作数不是0，总是使cf=1。\n\n * 操作数不能是立即寻址。\n\n比较指令\n\n格式：cmp op目,op源\n\n功能：op目-op源，不回送结果，只根据结果置标志位。\n\n说明：\n\n * 执行指令执行“目的操作数-源操作数”，与sub指令不同的是，不产生运算结果，仅影响标志位；\n * 指令的目的操作数不能是立即寻址；\n * 目的操作数和源操作数不能同时为存储器操作数。\n\n用途：用于比较两个数的大小，可作为条件转移指令转移的条件。\n\n# 2.2.3乘法指令\n\n无符号数乘法\n\n格式：mul op\n\n功能：ax<—al*op，8位数乘法\n\n(dx、ax)<— ax*op，16位数乘法\n\n说明：\n\n * 8位*8位=>16位，16位*16位=>32位\n * 乘数和被乘数都不能为立即寻址；\n * 乘数或被乘数必须放在al或ax中，在指令中隐含；\n * 16位运算结果在ax中，32位运算结果在dx（高16位）和ax（低16位）中。\n\n带符号数乘法\n\n格式：imul op\n\n功能：操作同上，但是操作数为带符号数\n\n说明：\n\n * 8位*8位=>16位，16位*16位=>32位\n\n * 乘数和被乘数都不能为立即寻址；\n\n * 乘数或被乘数必须放在al或ax中，在指令中隐含；\n\n * 16位运算结果在ax中，32位运算结果在dx（高16位）和ax（低16位）中。\n\n * 有符号数在计算机中是其补码，且符号位也参加运算，此时用mul指令就得不到正确结果，imul指令则会将符号部分和数值部分分别进行处理。\n\n注意：\n\n(1）进行字节运算时，op目必须是al，乘积在ax中；进行字运算时，0p目必须是ax，乘积在dx、ax中。源操作数不允许使用立即数寻址方式。 (2）运算结果只影响cf、of，其他的无定义。 (3）对于mul，若字节型数据相乘之积ah=0或字数据相乘之积dx=0，则cf=of=0，否则cf=of=1； 对于imul指令，若字节数据相乘之积ah或字数据相乘之积dx的内容是低一半的符号扩展，则cf=of=0, 否则cf=of=1。\n\n例题：\n\n已知al=0feh\n视为无符号数254，视为带符号数，值为-2\nbh=0ah\n视为无符号数为10，视为带符号数，数值为+10。\n执行指令mul bh后 ax=09ech，cf=of=1\n执行指令imul bh后ax=ffech，cf=of=0\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2.2.4除法指令\n\n指令要求被除数是除数的双倍字长，即当除数是8/16位时，要求被除数是16/32位的二进制数。\n\n无符号数除数\n\n格式：div op\n\n功能：\n\n * 字节除法：ax/op—>al=商，ah=余数\n * 字出除法：（dx、ax）/op—>ax=商，dx=余数\n\n说明：\n\n * 指令中使用16位除8位，32位除16位的格式，被除数不够16位或32位，则需要扩展；\n * 被除数、除数都不能为立即寻址，除数必须是寄存器数或存储器寻址；\n * 被除数必须放在ax或dx:ax中，在指令中则隐含；\n * 16位运算的商放在al中，在余数放在ah中；\n * 32位运算的商放在ax中，余数放在dx中。\n\n带符号除数\n\n格式：idiv op\n\n功能：操作同div，但是操作数作为符号数。\n\n说明：\n\n * 同div\n\n注意：\n\n * 当除数是字节时，被除数必须放在ax中，\n   \n   当除数是子时，被除数必须放在dx，ax中。\n\n * 商超出规定的范围时，将产生0号中断。\n\n * idiv运算结果余数的符号与被除数相同。\n\n * 带符号数除法运算中，当被除数位数不够时，则需将被除数扩展到所需的位数。（8086/8088设有带符号数扩展指令）\n\n符号扩张指令格式\n\n格式：cbw\n\n功能；将al中的数的符号位扩展ah\n\n规则：\n\n * 若最高位=1，则执行后ah=ffh\n * 若最高位=0，则执行后ah=00h\n\n说明：\n\n * 在符号除法指令中，被除数要扩展成16位时使用该指令\n\n字节扩展指令（16位—>32位）\n\n格式：cwd\n\n功能：将ax中的数的符号位扩展到dx\n\n规则：\n\n * 若最高位=1，则执行后dx=ffffh\n * 若最高位=0，则执行后dx=0000h\n\n说明：\n\n * 在符号除法指令中，被除数要扩展成32位时使用该指令\n\n这两条指令不影响标志位。\n\n\n# 2.3十进制运算调整指令\n\n# 2.3.1加法调整指令\n\n对非组合bcd数加法操作进行校正aaa\n\n格式：aaa\n\n功能：对al寄存器的内容进行十进制数调整。\n\n说明：\n\n * 要求参加操作的数必须是非组合bcd数；\n * 该指令用在非压缩bcd数加法操作后，操作数隐含在al中；\n * 由于该调整指令使用ah寄存器，故应先将ah内容清零。\n\naaa指令调整方法：\n\n 1. 如果al寄存器指令的低4位在0~9之间，af为0，则跳过第2步执行第3步；\n\n 2. 如果al寄存器的低4位在0ah~0fh之间或af为1，则al寄存器的内容加06h，同时ah寄存器内容加1，且将af置1；\n\n 3. al寄存器的高4位清零；\n\n 4. af位的值送cf。\n\n对组合bcd数加法操作的结果进行校正daa\n\n格式：daa\n\n功能：对al中的由两个组合bcd码相加进行调整，将结果（组合bcd码）存于al中。\n\n说明：\n\n * 要求参加操作的数必须是bcd数；\n * 该指令用在组合bcd数加法操作后，操作数隐含在al中。\n\ndaa指令调整方法：\n\n * 调整方法与aaa类似，只是此指令要分别考虑al的高4位和低4位。\n * 若al低四位大于9或af=1，则al+6—>al，置af=1；\n * 若al高四位大于9或cf=1，则al+60h—>al，置cf=1\n\n注意：以上两条指令使用时必须紧跟在add或adc之后。\n\n# 2.3.2减法调整指令\n\n非组合bcd码的减法调整指令\n\n格式：aas 功能：对al中由两个非组合bcd码相减的差进行调整，将结果（非组合bcd码）存于al中。 调整过程：调整方法与aaa类似，不同的是当al的低4位表示的数大于9或af=1时，将al-6--al, ah-1 一ah，并将af和cf置1，清除al的高四位。\n\n说明：\n\n * 参加操作的数必须是非组合bcd数；\n * 该指令用在非组合bcd数操作之后，操作数隐含在al中；\n * 由于该调整指令使用到ah寄存器，故先将ah内容清零。\n\naas指令调整方法：\n\n 1. 如果al寄存器指令的低4位在0~9之间，af为0，则跳过第2步执行第3步；\n\n 2. 如果al寄存器的低4位在0ah~0fh之间或af为1，则al寄存器的内容减06h，同时ah寄存器内容减1，且将af置1；\n\n 3. al寄存器的高4位清零；\n\n 4. af位的值送cf。\n\n组合bcd码的减法调整指令 格式：das 功能：对al中由两个组合bcd码相减所得的结果进行调整，并将结果（组合bcd码）存于al中。 调整过程：调整方法与daa类似，不同的是当al的低4位大于9或者 af=1，则al-6 一>al，并置af=1；而当 al的高4位大于9或者 cf=1时，则al-60h—>al，并置cf=1。\n\n说明：\n\n * 参加操作的数必须是组合bcd数；\n * 该指令用在组合bcd数减法操作之后，操作数隐含在al中。\n\n注意：使用aas、das指令必须紧跟在减法指令之后。\n\n# 2.3.3乘法调整指令\n\n非组合bcd码的乘法调整指令\n\n格式：aam\n\n功能：对ax中的由两个非组合bcd码相乘所得的结果进行调整，并将调整后的结果存于ax中。\n\n调整过程：ah<—al/0ah（商），al<—al%0ah（余数）\n\n说明：\n\n * 参加操作的数必须是非组合bcd数，该指令在mul指令之后；\n * aam指令调整方法：因为两个非组合bcd数相乘的结果为0~81，不会到十进制数的百位，因此调整方法就是将al寄存器的内容除以0ah，商放在ah寄存器（与除法指令不同）中，表示转换的十位整数；余数放在al寄存器（与除法指令不同）中，表示转换的个位数。\n\n注意：本指令必须紧跟在mul指令之后使用。\n\n# 2.3.4除法调整指令\n\n非组合bcd码的除法调整指令 格式：aad\n\n功能：把ax中的两个非组合bcd码进行调整，然后可用div指令实现两个非组合bcd码的除法运算\n\n调整过程：al<—10*ah+al, ah<—0 注意：本指令必须在div运算前使用。\n\n说明：\n\n * 该操作数要满足16位除8位的除法操作做要求，即非组合bcd数需放在ax寄存器中，\n * 该指令用在div指令之前，先调整，后做除法操作。\n\naad指令调整方法：将ax中的非组合bcd数转换成二进制数，因为除数也是非组合bcd数，必须在0~9之间，实质是完成二进制数除法。\n\n# 2.3.5总结\n\n * daa或das必须用在add (adc)或sub (sbb)之后，结果对of无影响，对其他状态标志位均有影响。\n\n * aaa或aas必须用在add (adc)或sub (sbb)之后，结果影响af和cf，对其他标志位均无意义。\n\n * aam必须用在mul之后，结果影响sf、zf和pf，对af、cf和of无影响。\n\n * aad必须用在div之前，结果影响sf、zf和pf，对af、cf和of无影响。\n\n\n# 2.4位操作指令\n\n位操作指令的共同特点如下：\n\n- 可以按二进制位进行操作。\n- 逻辑运算指令按逻辑门电路的运算规则。\n- 逻辑位移指令有左移和右移，移出的位都进入cf标志。\n- 因移空位的补充方式不同，有多种指令形式。\n- 逻辑移位指令中，移动超过1次，则用cl寄存器作为计数器。\n- 执行逻辑操作指令，cf均被清零。\n\n\n1\n2\n3\n4\n5\n6\n\n\nop源：8/16位通用寄存器、存储器操作数或立即数\n\nop目：通用寄存器和存储器操作数。\n\n除 “非” 运算外其余指令都会使of=cf=0\n\n# 2.4.1逻辑运算指令\n\n逻辑与运算指令\n\n格式：and op目,op源\n\n功能：将8/16位寄存器或存储器内容和源操作数 进行“与”运算。\n\n说明：\n\n * 目的操作数不能为立即寻址；\n * 可由源操作数控制，对8/16位数的某些位进行屏蔽或保留。\n\n----------------------------------------\n\n逻辑或运算指令\n\n格式：or op目,op源\n\n功能：对两个操作数进行或运算，结果回送到op目。\n\n说明：\n\n * 目的操作数不能为立即寻址；\n * 可用于组合某个字，或将某些位进行置1或保留。\n\n例：\n\n将al中的非组合bcd码转换为ascii码。\nor al,30h\n非组合bcd码：00h~09h（0~9）\nasscii码：  30h~39h（‘0’~‘9’）\n0000 1001\n0011 0000\n----------\n0011 1001 39h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n逻辑异或运算指令\n\n格式：xor op目,op源\n\n功能：对于两个操作数进行异或运算，结果回送到op目。\n\n说明：用于对某个二进制数按位取反或对某寄存器清0。\n\n * 相同为零，不同为1\n\n * 和1异或，相当于取反\n\n * 和0异或，相当于不变\n\n例：\n\n寄存器清0（有4条指令可达到ax清0目的）：\nxop al,al\t;al清0\nmov ax,0\t;移位指令不影响cf\nsub ax,ax\nand ax,0\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n逻辑求反指令\n\n格式：not op目\n\n功能：对操作数逐位取反后回送到原处。\n\n说明：\n\n * 该指令只是执行求反操作，而不是求反码指令，对符号位也求反；\n * 不影响标志位。\n * 对8/16位一次性全部取反。\n\n----------------------------------------\n\n测试指令\n\n格式：test op目,op源\n\n功能：将op目与op源进行 “与” 运算，不回送结果，只根据结果置标志位。\n\n说明：\n\n * 主要用来检测目的操作数的某些位是1或0，根据测试结果，决定转向。\n * 目的操作数不能为立即寻址；\n * test指令和and指令的运行规则相同，但test指令不产生运算结果，仅影响状态标志；\n * 常用于对某位是“1”或“0”的检测。\n\n----------------------------------------\n\n总结\n\n * and、or、xor、test均影响标志，cf=0，of=0，而pf，sf，zf由结果而定，af无意义。 此指令可用来清cf，常用与拆字，拼字。\n * not不影响标志。\n\n\n\n----------------------------------------\n\n# 2.4.2逻辑移位指令\n\n位移操作：\n\n * 非循环移位\n   \n   * 逻辑移位\n   * 算数移位\n\n * 循环移位\n   \n   * 不带进位位的移位\n   * 带进位位的移位\n\n规定：移动一位时由指令中的计数值直接给出；位移两位及以上，则位移次数由cl指定，即必须将移位位数n事先装入cl中。\n\n----------------------------------------\n\n# -非循环位移指令\n\n\n\n * 算数左移与逻辑左移相同，可用于无符号数乘2操作；\n * 逻辑右移可用于无符号数除2操作；\n * 算数右移可以用于有符号数除2操作。\n * 算数逻辑位移指令是双操作数指令，操作数可以是立即数之外的任何寻址方式；当计数值大于1时，必须使用cl作计数器。\n\n----------------------------------------\n\n逻辑左移指令\n\n格式：shl 目的操作数,1\n\nshl 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容左移，移空的位补0.\n\n说明：\n\n * 使用逻辑左移指令移动1位时，源操作数为1；左移位数超过1位时，用cl寄存器控制移动次数；\n * 逻辑左移指令移动1位，则原数据乘2（在无进位的情况下）。\n\n----------------------------------------\n\n算数左移指令\n\n格式：sal 目的操作数,1\n\nsal 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容左移，移空的位补0。\n\n说明：\n\n * 使用算数左移指令移动1位时，源操作数为1；\n * 使用算数左移指令超过1位时，用cl寄存器控制移动次数；算数左移指令移动1位，则原数据乘2（在无进位视的情况下）\n * 算数左移指令和逻辑左移指令功能相同。\n\n----------------------------------------\n\n逻辑右移指令\n\n格式：shr 目的操作数,1\n\nshr 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容右移，移空的位补0。\n\n说明：\n\n * 使用逻辑右移指令移动1位时，源操作数为1；\n * 使用逻辑右移指令移动超过1位时，用cl寄存器控制移动次数；逻辑右移指令移动1位，则原数据除2（与除法指令有差别）。\n\n----------------------------------------\n\n算数逻辑右移指令\n\n格式：sar 目的操作数,1\n\nsar 目的操作数，cl\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由目的操作数的最高位补充。\n\n说明：\n\n * 使用算数右移指令1位时，源操作数为1；\n * 使用算数右移指令超过1位时，用cl寄存器控制移动次数；算数右移指令实质上补充的是符号位。\n\n----------------------------------------\n\n# -不带进位循环移位指令\n\n循环左移指令\n\n格式：rol 目的操作数,1\n\nrol 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容左移，移空的位由移出位补充。\n\n说明：\n\n * 使用不带进位循环左移指令移动1位时，源操作数为1；\n * 使用不带进位循环左移指令移动超过1位时，用cl寄存器控制移动次数。\n\n循环右移指令\n\n格式：ror 目的操作数,1\n\nror 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由移出位补充。\n\n说明：\n\n * 使用不带进位循环右移指令移动1位时，源操作数为1；\n * 使用不带进位循环右移指令移动超过1位时，用cl寄存器控制移动次数。\n\n----------------------------------------\n\n# -带进位循环位移指令\n\n循环左移移指令\n\n格式：rcl 目的操作数,1\n\nrcl 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容左移，移空的位由cf位补充。\n\n说明：\n\n * 使用带进位循环左移指令移动1位时，源操作数为1；\n * 使用带进位循环左移指令移动超过1位时，用cl寄存器控制移动次数。\n * 该指令执行前，若cf没有置“1”或清“0”，则第一次移位时，移空位cf中的随机数补充。\n\n循环右移移指令\n\n格式：rcr 目的操作数,1\n\nrcr 目的操作数,cl\n\n功能：将8/16位寄存器或存储器内容右移，移空的位由cf位补充。\n\n说明：\n\n * 使用带进位循环右移指令移动1位时，源操作数为1；\n * 使用带进位循环右移指令移动超过1位时，用cl寄存器控制移动次数。\n * 该指令执行前，若cf没有置”1“或清”0“，则第一次移位时，移空位由cf中的随机数补充。\n\n----------------------------------------\n\n\n# 2.5串操作指令\n\n串操作指令实现一对字符或数据的操作，分为基本串操作指令和重复前缀指令。基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。\n\n申处理指令是针对存储器操作，其共同点如下：\n\n * 源串一般存放在数据段（ds），偏移地址由si指定，目标串在附加段（es），偏移地址由di指定。\n\n * 指令有特珠的寻址方式，规定源操作数的逻辑地址由ds:si给出，目的操作数的逻辑地址由es:di 给出。\n\n * 由于存储单元有字型数据和字节型数据，指令的助记符则有b或 w之分。\n\n * 每执行一次串操作后自动修改指针si、di。若方向标志df=0，则每次操作后si和di自动加1（或加2）；若df=1，则每次操作后si和di自动减1（或减2）。\n\n * 使用这类指令，存储单元的地址指针是自动移动的，由 df 标志控制指针的移动方向，df=0，地址往增加方向移动；df=1，地址往减小方向移动。\n\n * 串长（字或字节个数）存放在cx中。\n\n * 串的长度由 cx 给定。\n\n * 这类指令前一般可以使用指令前缀。\n\n * 这类指令后不带操作数，操作数在此指令前给定。\n\n串处理指令中需要注意的问题：\n\n * 在执行指令前必须ds、es、si、di、df、cx置好需要的值，它们是串操作指令的隐含操作数。\n\n * 当串指令在同段之间执行传送或比较等操作时，应将ds 和es 取同样的值。\n * 当使开指令前缀进行重复操作时，cx 的值是指数据个数，不是存储单元的字节数。\n * 当使用 df=1， 即地址指针为减小方向移动时，源操作数和目的操作数的初始地址要正确设定。\n\n----------------------------------------\n\n# 2.5.1串传送指令\n\n串传送指令\n\n格式：movsb——字节传送\n\nmovsw——字传送\n\n功能：\n\n * 目的操作数 <一 源操作数。\n * 把位于数据段由si指定的内存单元的字节/字数据传送到附加段由di指定的内存单元，指令不影响状态标志位。\n\n说明：\n\n * 源操作数地址由 ds:si指定，目的操作数由 es:di指定;\n * 指令执行时，由df标志控制si和 di是增大还是减小；\n * 由指令中的b和w控制 si 和di 是加1/加2，还是减1/减2；\n * 指令执行一次，cx 奇存器的内容不改变。\n * 串传送指令常与无条件重复前缀连用。\n\n过程：\n\n[di]<--[si] 若df=0 si<--si+1/2,di<--di+1/2\n[di]<--[si] 若df=1 si<--si-1/2,di<--di-1/2\n\n\n1\n2\n\n\n----------------------------------------\n\n# 2.5.2串比较指令\n\n格式：cmpsb——字节比较\n\ncmpsw——字比较\n\n功能：\n\n * 目的操作数 一 源操作数。\n * 把位于数据段由si指定的字节/字数据与附加段由di指定的字节数进行比较，结果不保存，但应响状态标志位，并由df状态决定si、di的修改方向。\n\n说明：\n\n * 执行指令完成内存中两串数据对应元素的减法操作，但不产生运算结果，仅影响状态标志；\n * 其余与串传送指令相同；\n * 该指令多与其他指令或指令前缀配合。\n * 串比较指令常与条件重复前缀连用，指令的执行不改变操作数，仅影响标志位。\n\n过程：\n\n[si]-[di] si<--si(+/-)1/2,di<--di(+/-)1/2\n\n\n1\n\n\n----------------------------------------\n\n# 2.5.3串搜索指令\n\n格式：scasb——字节搜索\n\nscasw——字搜索\n\n功能：把al/ax中的内容与附加段由di指定的一个字节/字数据进行比较，结果不保存，但影响状态标志位，并由df状态决定di的修改方向。\n\n说明：\n\n * 执行该指令前，将需检索的数据存入al或ax寄存器中；\n * 指令完成内存数据串中每个元素的搜索操作，即al/ax减串元素；\n * 该指令多与其他指令或指令前缀配合；\n * 其余与串传输指令相同。\n\n过程：\n\n字节——al-[di],di<--di(+/-)1\n  字——ax-[di],di<--di(+/-)2\n\n\n1\n2\n\n\n# 2.5.4串装入指令（取字符串）\n\n格式：lodsb\n\nlodsw\n\n功能：\n\n * al/ax <— 源操作数\n\n * 把位于数据段由si指定内存单元的内容取到al或ax中，并修改si的内容，指向下一字节/字单元。\n\n说明：\n\n * 该指令每执行一次，将存储单元中的内容写入累加器；\n * 该指令多与其他指令配合，但不能有指令前缀；\n * 在软件循环中与其他指令配合，可完成复杂字符串的处理；\n * lods指令的执行不影响标志位。\n\n----------------------------------------\n\n# 2.5.5串存储指令（存字符串）\n\n格式：stosb\n\nstosw\n\n功能：\n\n * 目的操作数<— al/ax\n * 把寄存器al或ax中的内容存到附加段由di指定的内存单元，并修改di的内容，指向下一字节/字的存放单元。\n\n说明：\n\n * 该指令每执行一次，将累加器的内容写入存储单元中；\n * 该指令可以有指令前缀\n * 该指令的执行不影响标志位。\n\n----------------------------------------\n\n# 2.5.6重复前缀指令\n\n基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。\n\n无条件重复\n\nrep：\n\n * rep为重复前缀，每执行一次，cx内容减1，直到cx内容为0，才退出串处理过程，一般与movs指令和stos指令配合使用。\n\n * 若cx !=0，则cx<— cx-1 继续重复操作，知道cx=0为止。\n\n----------------------------------------\n\n条件重复\n\n * （相等/为0）重复\n   \n   * repe/repz\n     * 若cx !=0且zf=1，则cx<— cx-1 继续重复操作，知道cx=0或zf=0为止。\n\n * （不相等/不为0）重复\n   \n   * repnz/repne\n     * 若cx !=0且zf=0，则cx<— cx-1 继续重复操作，知道cx=0或zf=1为止。\n\n----------------------------------------\n\n注意\n\n * 重复前缀指令不能单独使用，其后必须紧跟基本串操作指令，控制基本串操作指令重复执行。其执行过程相当于一个循环控制程序的运行。在每次重复之后，地址指针si和di都被修改，但指针ip仍保持指向带有前缀的串操作指令的地址。\n * 重复执行次数由数据串长度决定，数据串长度应预置在寄存器cx中。\n * 执行重复前缀指令不影响标志位。\n\n----------------------------------------\n\n\n# 2.6程序控制转移指令\n\n# 2.6.1寻址方式\n\n控制转移指令在段内、段间转移时、使用直接（相对）寻址或间接寻址方式。\n\n直接寻址方式\n\n * 段内寻址方式：目标程序和源程序在同一程序段内，只给出源地址和目标地址的差值，此差值是偏移量，它是一个以ip为基准的8/16位的带符号补码数。\n\n * 段间直接寻址方式：直接给出转移目标地址的段地址和段内位移量，用前者取代cs当前的值，用后者取代ip中当前的值，使程序从一个代码段转移到另一个代码段。\n\n----------------------------------------\n\n间接寻址方式\n\n * 段内间接寻址方式：指令转移的有效地址存在一个寄存器或存储器单元中，用它取代单前ip的值，实现程序转移。\n * 段间间接寻址方式：指令给出一个存储器地址，从该地址开始的4个字节单元中存放转移目标地址的段内偏移量和段地址，这两个地址在指令执行时用于取代当前的ip和cs的内容，使程序从一个代码段转移到另一个代码段。\n\n# 2.6.2转移指令\n\n通过修改指令的偏移地址或段地址及偏移地址实现程序的转移\n\n# -无条件转移指令\n\n无条件转移到目标地址，执行新的指令。\n\n段内直接转移指令\n\n一个段内的直接无条件转移是在指令中给出一个相对位移量。该位移量是相对于ip奇存器来计算的，即有效转移地址是在ip当前的内容上加上一个8位或16位的位移量，所以也称为相对寻址。其位移量是带符号的数，这就使转移可在向前或向后的方向进行。\n\n格式：jmp near ptr 目标地址\n\n补码：-32768～+32767\n\n功能：当位移量为16位带符号数时，允许在（+/-）32kb 的范国内寻找目标地址，称为段内直接近转移。\n\n格式：jmp near short 目标地址\n\n补码：-128～+127\n\n功能：当位移量为8位带符号数时，允许在（+/-）127字节 的范国内寻找目标地址，称为段内直接短转移。\n\n----------------------------------------\n\n段内间接转移指令\n\n格式：jmp op(寄存器)\n\njmp word ptr [bx]\n\n功能：在jmp 指令中，间接给出转移目标地址，即由一个 16位奇存器或由存储单元寻址目标地址。\n\n----------------------------------------\n\n段间直接转移指令\n\n格式：jmp far ptr 目标地址\n\n功能：段间转移意味着寄存器 cs 和ip的值都要改变，指令中直接采用汇编中的符号地址作为直接目标地址。\n\n----------------------------------------\n\n段间间接转移指令\n\n格式：jmp word ptr [bx][si]\n\n功能：段间转移意味着寄存器 cs 和ip 的值都要改变，所以间接给出目标地址，只能由存储单元寻址。也就是说，目标地址存放在连续的4个存储单元中，低字节两个单元的内容代替ip，高字节两个单元的内容代替cs。\n\n----------------------------------------\n\n注意：\n\n * 当目标地址高于源地址时称为正向转移，偏移量是正数；\n * 当目标地址低于原地址时称为反向转移，偏移量是负数。\n\n# -有条件转移指令\n\n在具备一定条件的情况下转移到目标地址。\n\n * 条件转移指令将前一条指令执行结果对状态标志位的影响，作为程序转移的条件。满足条件时转移到指令指定的地址，否则将顺序执行下条指令。可作为判断条件的状态标志位有cf、pf、zf、sf和of。\n * 条件转移指令都是采用相对寻址方式的双字节指令，指令第一字节是操作码，第二字节是带符号的位移量。条件转移指令只能在当前段中实现短转移，不影响状态标志位。\n\n----------------------------------------\n\n对无符号数\n\n * ja/jnbe 目标标号 ——高于/不低于也不等于转移，cf and zf=0\n\n * jae/jnb 目标标号 ——高于或等于/不低于转移，cf=0 or zf=1\n\n * jb/jnae 目标标号 ——低于/不高于也不等于，cf=1 and zf=0\n\n * jbe/jna 目标标号 ——低于或等于/不高于，cf=1 or zf=1\n\nj ---\x3ejmp\na ---\x3e大于\nb ---\x3e小于\ne ---\x3e等于\nn ---\x3enot\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n对有符号数\n\n * jg/jnle 目标标号 ——大于/不小于也不等于转移，（sf ⊕ of） and zf=0\n * jge/jnl 目标标号 ——大于或等于/不小于转移，sf ⊕ of=0\n * jl/jnge 目标标号 ——小于/不大于也不等于转移，sf ⊕ of=1\n * jle/jng 目标标号 ——小于或等于/不大于转移，（sf ⊕ of）= 1 or zf=1\n\ng ---\x3e大于\nl ---\x3e小于\n\n\n1\n2\n\n\n----------------------------------------\n\n对标志位\n\n * jc 目标标号 ——进位位为1转移，cf=1\n * jnc 目标标号 ——进位位为0转移，cf=0\n * je/jz 目标标号 ——等于/结果为0转移，zf=1\n * jne/jnz 目标标号 ——不等于/结果不为0转移，zf=0\n * jo 目标标号 ——溢出转移，of=1\n * jno 目标标号 ——不溢出转移，of=0\n * jnp/jno 目标标号 ——奇偶位为0/奇偶性为奇转移，pf=0\n * jp/jo 目标标号 ——奇偶位为1/奇偶性为偶转移，pf=1\n * jns 目标标号 ——符号标志位为0转移，sf=0\n * js 目标标号 ——符号标志位为1转移，sf=1\n\n# 2.6.3调用和返回指令\n\n# 调用指令call\n\n为了程确保程序正确返回，call指令的类型必须与ret指令的类型相匹配。\n\ncall指令有两种的得到目标地址的方法：直接寻址和间接寻址。直接寻址意味着目标地址在call指令的操作码部分直接给出。间接寻址意味着目标地址在指定的寄存器或内存单元中，以间接方式给出。\n\n一个过程用于段内调用，则在过程定义中属性应为near。而另一个过程用于段间调用，则在过程定义中属性应为far。\n\n格式：call op\n\n功能：将call指令的下一条指令的地址（断点地址ip【段内】或ip与cs【段间】）压栈，新的目标地址（子程序首地址）装入ip或cs中，控制程序转移到由op指明入口的子程序。其中op为子程序（过程）的名字。\n\n段内直接调用\n\n子过程与原调用程序在同一代码段，在调用之前需要保护断点的偏移地址。\n\ncall near 目标地址\n\n段内间接调用\n\n例如：\n\ncall word ptr [si]\ncall bx\n\n\n1\n2\n\n\n段间直接调用\n\n子过程与原程序调用程序不在同一代码段，在调用之前需保护断点的段基址和偏移地址。\n\n先将断点的cs压栈，再压入ip。\n\ncall far 目标地址\n\n段间间接调用\n\n例如：\n\ncall word ptr [si]\ncall bx\ncall word prt 62[bx][di]\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 返回指令ret\n\n格式：ret\n\n功能：通常作为一个子程序的最后一条指令，用以返回到调用子程序的断点处，即从堆栈弹出断点送ip和cs。\n\n操作过程：\n\n * 1.从栈顶弹出一个字给ip，sp+2 -> sp\n * 2.从栈顶弹出一个字给cs，sp+2 -> sp\n * 对于段内调用只有（1）。\n\n----------------------------------------\n\n# 2.6.4循环控制指令\n\n * 使用循环控制指令之前，必须在cx（计数器）中预置循环次数的初值。\n * 不影响状态标志位。\n * 主要用于数据块比较、查找关键字等操作。\n\n# 计数循环\n\n格式：loop 目标标号\n\n功能：cx-1 —> cx，若cx!=0，循环转移到目标标号，直到cx=0退出循环。\n\n# 结果为0/相等循环\n\n格式：loop/loope 目标标号\n\n功能：cx-1 —> cx，若cx!=0且zf=1时，循环转移到目标标号，直到cx=0或zf=0退出循环。\n\n# 结果不为0/不相等循环\n\n格式：loopnz/loopne 目标标号\n\n功能：cx-1—> cx，若cx!=0且zf=0时，循环转移到目标标号，直到cx=0或zf=0时退出循环\n\n# 计数为0转移\n\n格式：jcxz 目标标号\n\n功能：若cx=0时，则转向目标标号，否则顺序执行。\n\n\n# 2.7处理器控制指令\n\n# 2.7.1标志操作指令\n\n格式：\n\nclc\t\t清除进位标志，置cf=0\nctc\t\t置1进位标志，置cf=1\ncmc\t\t取反进位标志，置cf=!cf\ncld\t\t清楚方向标志，置df=0\nstd\t\t置1方向标志，置df=1\ncli\t\t清楚中断标志，置if=0\nsti\t\t置1中断标志，置if=1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这些操作指令完成对标志位的置位、复位等操作，这些指令只影响与其相关的标志位。\n\n# 2.7.2 cpu控制指令\n\n# 处理器暂停指令\n\n格式：hlt\n\n功能：使处理器处于暂时停机状态。\n\n说明：hlt引起的暂停，只有reset（复位）、nmi（非屏蔽中断请求）信号可以使cpu退出暂停状态。\n\n# 处理器等待指令\n\n格式：wait\n\n功能：执行wait指令之后，处理器处于等待状态，直到检测到test引脚有效，才能退出等待状态，执行后续指令。\n\n说明：用于处理器与外设同步。\n\n# 处理器交权指令\n\n格式：esc extopcd,op源(其中extopcsd为外部操作码，op源为操作数)\n\n功能：用来为协处理器提供提供一个操作码和操作数，以便完成主机对协处理器的某种操作要求。\n\n# 空操作指令（延时）\n\n格式：nop\n\n功能：在执行本指令期间，cpu不完成任何操作，只是每一条nop指令，耗费3个时钟周期的时间。\n\n总线封锁指令\n\n格式：lock\n\n功能：在cpu访问存储器或外设时，总线控制器会对总线进行封锁，使其他处理器得不到总线控制权，从而就不能访问存储器或外设。\n\n说明：lock指令可以放在任何一条指令前，所以lock指令实际上是一个特殊的1字节封锁线。它使工作在最大模式下的8086cpu，在执行下一条指令期间发出总线封锁信号，即lock引脚变为低电平有效信号。\n\n\n# 2.8输入输出指令\n\ncpu对外设端口有两种寻址方式，即直接寻址和间接寻址。直接寻址范围为0000h~0ffffh共64k个端口。间接寻址时，只能用dx作间址寄存器。\n\n# 输入指令\n\n格式：in 累加器,端口\n\n功能：把一个字节/字由输入端口传送到al/ax中。\n\n# 输出指令\n\n格式：out 端口,累加器\n\n功能：把ax中的16位数或al中的8位数输出到指定端口。\n\n\n# 2.9中断指令\n\n# 2.9.1溢出中断指令\n\n格式：into\n\n功能：检测of标志位。当of=1时，产生一个中断类型4的中断；当of=0时，本指令不起作用。\n\n注意：影响标志位if、tf。\n\n# 2.9.2软中断指令\n\n格式：int n（n为中断类型信号）\n\n功能：产生一个软件中断，把控制转向一个类型型号为n的软中断。\n\n注意：\n\n * 影响标志位if、tf。\n * n为中断类型信号（起到索引的作用），可以是常数或常数表达式，其值在0~255的范围内。\n\n# 2.9.3中断返回指令\n\n格式：iret\n\n功能：让cpu执行完中断服务程序后，正确返回原程序的断点处。\n\n注意：影响所有标志位。\n\n\n# 3.常用伪指令\n\n\n# 3.1宏汇编语言的基本语法\n\n# 3.1.1常数、变量和标号\n\n常数\n\n没有任何属性的纯数值。在汇编期间，它的值已经完全确定，而且在程序的运行中也不会发生变换。它可以有以下几种类型：\n\n * 二进制数：以字母b结尾的一串“0”和“1”组成的序列。\n * 八进制数：以字母o或q结尾，由若干个0到7的数字组成的序列。\n * 十进制数：由若干个0到9的纯数字组成的序列，可以以字母d结尾，也可以省略字母d。\n * 十六进制数：以字母h结尾，由若干个0到9的数字和字母a到f组成的序列，且必须以数字开头。\n * 字符串常数：用引号括起来的一个或多个字符。这些字符以ascii码形式存在内存中。\n\n注意：为了区别a~f组成的一个字符串是十六进制数还是英文符号，规定在前面冠以数字“0”。\n\n总之，常数主要以立即数、位移量的形式出现在指令语句或数据定义的伪指令中。\n\n----------------------------------------\n\n变量\n\n变量：通常是存放在某些存储单元的数据，这些数据在程序运行期间可以修改。\n\n变量名：表示数据在段中的有效地址，由用户指定。变量名是可选的，如果使用变量名，它代表数据区中第一个数据项的地址。\n\n变量的三个属性：\n\n * 段属性（segment）：表示变量所在段首地址\n * 偏移属性（offset）：表示变量的偏移地址\n * 类型属性（type）：表示变量占用存储单元的字节数。\n   * 类型：字节（db）、字（dw）、双字（dd）、四字、十字节类型，变量是用数据定义伪指令db，dw，dd等定义的。\n\n注意：变量也可以定义为一个数据区或存储区，但变量名仅表示该数据区域的第一个数据单元（即数据区或存储区的首地址）。\n\n----------------------------------------\n\n标号\n\n * 表示一条指令所在的地址，也是指令语句的地址符号，常用作转移指令（包含子程序调用指令）的操作数，即目标地址。\n * 通常由字母数字串组成但第一个字符必须为字母。最多允许使用31个字符，且可以使用下划线，使标号容易阅读。\n\n标号的三个属性：\n\n * 段属性（segment）：表示标号所在的段基址\n\n * 偏移属性（offset）：表示标号的偏移地址\n\n * 距离属性（类型属性type）：表示标号作为段内或段间的转移属性\n\n距离属性分为两种：\n\nnear（近）：表示标号只能被所在段内的转移和调用使用指令访问（即段内转移）。\n\nfar（远）：表示本标号可以被其他段（不是标号所在段）的转移和调用指令访问（即段间转移）。\n\n# 3.1.2运算符号与表达式\n\n表达式：\n\n * 数值表达式：只产生数值结果\n * 地址表达式：产生的结果是一个存储器地址，若该地址存放的是数据，一般称它为变量，若存放的是指令，一般称它为标号。\n\n运算符主要包括一下6种类型：\n\n1.算数运算符\n\n包括：+、-、*、/、mod(求余)、shl(左余)\n\n2.逻辑运算符\n\n包括：and、or、xor、not。只适用于对常数进行逻辑运算。\n\n3.关系运算符\n\n包括：eq(相等)、ne(不相等)、lt(小于)、gt(大于)、le(小于或等于)、ge(大于或等于)\n\n结果：\n\n * 若关系为假（不成立），结果为0；\n * 若关系为真（成立），结果为0ffh或0ffffh。\n\n4.分析操作符（数值返回运算符）\n\n * 取地址的偏移量\n   \n   格式：offset 变量名或标号\n   \n   功能：取变量名或标号所在的段内偏移量。\n\n * 取段基址\n   \n   格式：seg 变量名或标号\n   \n   功能：取变量名或标号所在的段首地址。\n\n * 求变量名或标号的类型值\n   \n   格式：type 变量名或标号\n   \n   功能：放回一个数字值。若type加在变量名前，返回该变量的类型属性；若加在标号前，返回该变量的距离属性。\n   \n        属性     类型值\n   变量   byte   1\n   变量   word   2\n   变量   word   4\n   标号   near   -1\n   标号   far    -2\n\n * 求长度\n   \n   格式：lendth 变量名\n   \n   功能：返回一个变量名所占存储单元（字节、字或双字）的数目。若变量是用重复定义子句说明的，则返回dup前面的数值；其余返回1。\n\n * 求大小\n   \n   格式：size 变量名\n   \n   功能：返回变量名所占将存储单元的字节数，它等于length和type两个运算符返回的乘积。\n\n5.综合运算符\n\n * ptr运算符\n   \n   格式：类型 ptr 表达式\n   \n   功能：用于指出变量、标号或地址表达式的类型属性，新的类型只在当前指令内有效。\n\n * this运算符\n   \n   格式：this 类型\n   \n   功能：把它后面指定的类型或距离属性赋给当前的变量、标号或地址表达式。\n\n注：this使下面的原标号或原变量有新的名字和类型，但不分配新的存储单元。\n\n6.其他运算符\n\n * high和low运算符\n   \n   格式：high 表达式、low表达式\n   \n   功能：从运算对象中分离出高字节或低字节。\n\n * short运算符\n   \n   格式：short 标号\n   \n   功能：当转移的目标地址与本转移指令的下一条指令之间的字节距离在-128~127范围时，可以使用short运算符进行说明。\n\n\n# 3.2伪指令\n\n8086宏汇编语言有两种类型的语句：\n\n指令语句：在汇编过程中被翻译成相应的目标代码，经连接后生成可执行的机器指令代码。\n\n伪指令语句：（指示性语句）在汇编时被解释执行，由汇编程序来处理的一类操作，如数据定义，分配存储器等。\n\n# 3.2.1伪指令语句的格式\n\n格式：符号名 定义符 操作数;注释\n\n# 5.2.2常用伪指令\n\n1.符号定义伪指令（赋值语句）\n\n * 等值伪指令\n   \n   格式：符号名 equ 表达式\n   \n   功能：将表达式的值赋给符号名。\n   \n   注意：符号名一旦被equ定义，就不能再赋值，即不能用equ再为符号名重新赋值。\n\n * 等号伪指令\n   \n   格式：符号名 = 表达式\n   \n   功能：将表达式的值赋给符号名。\n   \n   说明：可以在程序中不同的地方多次使用以重新为符号名赋值。\n\n * 定义符号名伪指令\n   \n   格式：符号名 label 类型\n   \n   功能：定义一个标号或变量，并指定其类型。\n\n----------------------------------------\n\n2.数据定义伪指令\n\n格式：\n\n[变量名] dr 表达式 ; 定义字节\n[变量名] dw 表达式 ; 定义字\n[变量名] dd 表达式 ; 定义双字\n[变量名] dq 表达式 ; 定义8个字节\n[变量名] dt 表达式 ; 定义10个字节\n\n\n1\n2\n3\n4\n5\n\n\n表达式——是赋给变量的初始值，可以有一个，也可以有多个，常见的有以下几种：\n\n * 数值表达式：\n   \n   实际上是为数据分配存储单元，并把变量名作为该存储单元的名称。若要定义多个相同类型的数据，可用逗号把这些数据隔开，并依次分配在相邻的存储单元。\n\n * ascii字符串\n   \n   字符串必须用引号括起来，并且不超过256个字符，它们在内存中按地址递增顺序自左向右依次存放再付的ascii码。\n\n * ？——为数据项分配存储单元的一种方法，只是存储单元中不预置确定的值，常用来预留存储储单元，存放程序的中间结果或最终结果。\n\n * 重复定义子句dup——可以为若干个重复数据分配存储单元。\n   \n   格式：n dup (表达式)\n   \n   说明：n:重复次数 表达式：重复的内容\n   \n   注意：\n   \n   * dup操作可以嵌套。\n   * 在定义变量及存储单元的同时，也定义了它们的类型属性。同一数据定义语句所定义的各存储单元具有相同的类型。\n\n----------------------------------------\n\n3.段定义伪指令\n\n格式：段名 segment [定义类型][组合类型][‘类别名’]\n\n功能：把模块化分为若干逻辑段。每个segment/ends可定义一个逻辑段。\n\n----------------------------------------\n\n4.段寄存器说明伪指令\n\n格式：assume 段寄存器:段名[，段寄存器:段名…]\n\n功能：向汇编程序指示当前各段所用的段奇存器，设定段寄存器与段的对应关系。\n\n注意： ①本伪指令貝是指示各逻辑段使用寄存器的情況，没有对段奇存器内容进行装填。段寄存器的实际值(cs除外）还要由mov指令在程序中装填数据。 ②也可用来取消段奇存器与段之间的对应关系（用nothing)，然后再建立新的对应关系。\n\n----------------------------------------\n\n5.过程定义伪指令指令\n\n过程是程序的一部分，它可以被程序调用。每次可调用一个过程，当过程中的指令执行完后，控制返回调用它的地方。过程的定义是用过程定义伪指令完成的。\n\n格式：\n\n过程名 proc [near/fari]\n\t\t…\n\n\t  ret\n过程名 endp  可有多个ret，一般作为最后一条指令\n\n过程名:自定义符，开始、结束要相同；有三个属性 （段地址，偏移地址和距离属性）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n6.模块定义及通信伪指令\n\n汇编语言可以把程序划分成许多模块，并对每个模块独立地进行汇编和调试。\n\n * 模块开始伪指令\n   \n   格式：name 模块名\n   \n   功能：指明程序模块的开始，并指出模块名。\n   \n   说明：模块名是自定义符，不能是系统保留字。若该项缺省，则取title语句中的页标题6个字符；若没有title语句，则取源程序文件名为模块名。\n\n * 模块结束伪指令（源程序结束伪指 令）\n   \n   格式：end启动标号或过程名\n   \n   功能：end表示一个模块（源程序）的结束。通知汇编程序源程序到此结束，并给出执行程序的入\n\n注意：\n\n * end与name联合使用，当name缺省时，end 值表示原程序的结束。\n * 汇编处理只进行到end为止。\n\n\n# 3.3宏定义\n\n宏定义及其调用\n\n宏定义格式：\n\n宏指令名 macro [形参，形参，...]\n\t\t\t... 宏体\n\t\t\tendm\n\n\n1\n2\n3\n\n\n宏调用的格式为：宏指令名 [实参，实参，...]\n\n----------------------------------------\n\n扩展\n\n格式：org 偏移地址(16位地址)\n\n功能：声明偏移地址\n\n格式：$\n\n功能：取当前偏移地址\n\norg + 16位地址 ：声明偏移地址",charsets:{cjk:!0},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/web.png",heroText:"WFmiss Notes",tagline:"我们在黑暗中并肩前行，走在各自的朝圣路上!",actionText:"立刻进入 →",actionLink:"/c/note0/",bannerBg:"none",postList:"simple"},regularPath:"/",relativePath:"index.md",key:"v-d4c9be1a",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-7fb91247",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/23, 9:05:00",lastUpdatedTimestamp:1653270936e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"笔记",items:[{text:"考试报名流程",link:"/notes/0/"},{text:"C语言",link:"/c/"},{text:"SMC",link:"/smc/0/"},{text:"Vue",link:"/vue/note0/"}]},{text:"练习题",items:[{text:"C语言",link:"/c1/1/"},{text:"SMC&P",link:"/c1/"}]},{text:"关于",link:"/about/"},{text:"归档",link:"/archives/"}],sidebarDepth:2,repo:"wfmiss/notes",searchMaxSuggestions:10,lastUpdated:"最后更新",docsDir:"docs",editLinks:!0,editLinkText:"在 GitHub 上编辑此页",category:!1,tag:!1,sidebar:{"/00.目录页/":[["02.练习题.md","c语言页面","/c1"],["50.C语言.md","c语言页面","/c"]],catalogue:{"练习题":"/c1","C语言":"/c"},"/01.考试报名流程/":[["00.考试报名流程.md","报名流程","/notes/0"]],"/02.练习题/":[["00.C语言编程题.md","C语言编程题","/c1/1"],["01.微机原理简答题.md","微机原理简答题","/c1/2"],["02.微机原理填空题.md","微机原理填空题","/c1/3"],["03.微机原理指令集.md","微机原理指令集","/c1/4"],["04.输入输出系统接口芯片.md","输入输出系统接口芯片","/c1/5"],["05.微机原理简答题（分类）.md","微机原理简答题","/c1/6"]],"/10.关于/":[{title:"关于 - 我",collapsable:!0,children:[["01.关于 - 我/01.关于 - 我.md","关于 - 我","/pages/038c37/"]]},{title:"关于 - 本站",collapsable:!0,children:[["02.关于 - 本站/02.文档 -  快速上手.md","文档 - 快速上手","/pages/c6c456/"],["02.关于 - 本站/03.文档 - md文件写作.md","文档 - md文件写作","/pages/2a3030/"],["02.关于 - 本站/05.文档 - 部署.md","文档 - 部署","/pages/39f283/"],["02.关于 - 本站/11.标题 - 目录生成.md","标题 - 目录生成","/pages/2bde62/"],["02.关于 - 本站/12.标题 - 锚点比较.md","标题 - 锚点比较","/pages/8bac8d/"]]}],"/50.C语言/":[["01.C语言发展历程.md","C语言发展历程","/c/note0/"],["02.第一章基础语法.md","第一章 基础语法","/c/note1/"],["03.第二章控制语句.md","第二章 控制语句","/c/note2/"],["04.第三章数组.md","第三章 数组","/c/note3/"],["05.第四章函数实现模块化设计.md","第四章 函数实现模块化设计","/c/note4/"],["06.第五章指针.md","第五章 指针","/c/note5/"],["07.第六章自定数据类型.md","第六章 自定数据类型","/c/note6/"],["08.第七章对文件的输入输出.md","第七章 对文件的输入输出","/c/note7/"],["09.变量的存储类别及作用域.md","变量的存储类别及作用域","/c/note8/"]],"/60.SMC/":[["01.前言.md","微型计算机原理及应用","/smc/0/"],["02.第一章计算机基础知识.md","第一章、计算机基础知识","/smc/1/"],["03.第二章80X86微处理器.md","第二章、80X86微处理器","/smc/2/"],["04.第三章微型计算机的基本工作原理.md","第三章、指令系统与汇编语言程序设计","/smc/3/"]],"/70.vue/":[["01.vue.md","vue","/vue/note0/"]]},updateBar:{showToArticle:!0},author:{name:"zhiyuan",href:"https://wfmiss.com/"},footer:{createYear:2021,copyrightInfo:"wfmiss | notes"}}},cc=(e(151),e(207),e(138),e(217)),uc=e(218),lc=(e(371),e(232),e(42));var pc={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var t=n.frontmatter,e=t.pageComponent,r=t.article,i=t.home;return!(e||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,t){var e=n.frontmatter.sticky,r=t.frontmatter.sticky;return e&&r?e==r?Object(lc.a)(n,t):e-r:e&&!r?-1:!e&&r?1:Object(lc.a)(n,t)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,t){return Object(lc.a)(n,t)})),n;var n},$groupPosts:function(){return function(n){for(var t={},e={},r=function(r,i){var o=n[r].frontmatter,a=o.categories,s=o.tags;"array"===Object(lc.n)(a)&&a.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})),"array"===Object(lc.n)(s)&&s.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}))},i=0,o=n.length;i<o;i++)r(i);return{categories:t,tags:e}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var t=[],e=[];for(var r in n.categories)t.push({key:r,length:n.categories[r].length});for(var i in n.tags)e.push({key:i,length:n.tags[i].length});return{categories:t,tags:e}}(this.$groupPosts)}}};Bi.component(cc.default),Bi.component(uc.default);function dc(n){return n.toString().padStart(2,"0")}e(375);Bi.component("CodeBlock",(function(){return Promise.resolve().then(e.bind(null,217))})),Bi.component("Badge",(function(){return Promise.all([e.e(0),e.e(3)]).then(e.bind(null,503))})),Bi.component("CodeGroup",(function(){return Promise.resolve().then(e.bind(null,218))}));e(376);var fc=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var t=n.Vue,e=(n.options,n.router,n.siteData);e.pages.map((function(n){var t=n.frontmatter,r=t.date,i=t.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(dc(n.getUTCMonth()+1),"-").concat(dc(n.getUTCDate())," ").concat(dc(n.getUTCHours()),":").concat(dc(n.getUTCMinutes()),":").concat(dc(n.getUTCSeconds()))}(r)),i?n.author=i:e.themeConfig.author&&(n.author=e.themeConfig.author)})),t.mixin(pc)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{}],hc=[];e(210);function mc(n,t){return(mc=Object.setPrototypeOf||function(n,t){return n.__proto__=t,n})(n,t)}e(211),e(212);function vc(n){return(vc=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function gc(n,t){if(t&&("object"===Ea(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function bc(n){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var e,r=vc(n);if(t){var i=vc(this).constructor;e=Reflect.construct(r,arguments,i)}else e=r.apply(this,arguments);return gc(this,e)}}var yc=function(n){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&mc(n,t)}(e,n);var t=bc(e);function e(){return us(this,e),t.apply(this,arguments)}return ps(e)}(function(){function n(){us(this,n),this.store=new Bi({data:{state:{}}})}return ps(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,t){Bi.set(this.store.state,n,t)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(yc.prototype,{getPageAsyncComponent:Xa,getLayoutAsyncComponent:Ha,getAsyncComponent:$a,getVueComponent:Wa});var xc={install:function(n){var t=new yc;n.$vuepress=t,n.prototype.$vuepress=t}};function Ac(n){n.beforeEach((function(t,e,r){if(Cc(n,t.path))r();else if(/(\/|\.html)$/.test(t.path))if(/\/$/.test(t.path)){var i=t.path.replace(/\/$/,"")+".html";Cc(n,i)?r(i):r()}else r();else{var o=t.path+"/",a=t.path+".html";Cc(n,a)?r(a):Cc(n,o)?r(o):r()}}))}function Cc(n,t){var e=t.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===e}))}var Sc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var t=this.pageKey||this.$parent.$page.key;return Ga("pageKey",t),Bi.component(t)||Bi.component(t,Xa(t)),Bi.component(t)?n(t):n("")}},wc={functional:!0,props:{slotKey:String,required:!0},render:function(n,t){var e=t.props,r=t.slots;return n("div",{class:["content__".concat(e.slotKey)]},r()[e.slotKey])}},Ic={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ec=(e(377),e(378),Object(ic.a)(Ic,(function(){var n=this.$createElement,t=this._self._c||n;return t("span",[t("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[t("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),t("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),t("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Pc(){return(Pc=Object(r.a)(regeneratorRuntime.mark((function n(t){var e,r,i,o;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:sc.routerBase||sc.base,Ac(r=new wa({base:e,mode:"history",fallback:!1,routes:ac,scrollBehavior:function(n,t,e){return e||(n.hash?!Bi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(fc.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Bi,options:i,router:r,siteData:sc,isServer:t})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Bi(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},hc.map((function(t){return n(t)})))])}})),n.abrupt("return",{app:o,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Bi.config.productionTip=!1,Bi.use(wa),Bi.use(xc),Bi.mixin(function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bi;Ia(t),e.$vuepress.$set("siteData",t);var r=n(e.$vuepress.$get("siteData")),i=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),a={};return Object.keys(o).reduce((function(n,t){return t.startsWith("$")&&(n[t]=o[t].get),n}),a),{computed:a}}((function(n){return function(){function t(){us(this,t)}return ps(t,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,t,e=this.$site.locales,r=void 0===e?{}:e;for(var i in r)"/"===i?t=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||t||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,t=this.$page.frontmatter.metaTitle;if("string"==typeof t)return t;var e=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return e?r?r+" | "+e:e:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var t=n.filter((function(n){return"description"===n.name}))[0];if(t)return t.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,t){for(var e=0;e<n.length;e++){var r=n[e];if(r.path.toLowerCase()===t.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),t}()}),sc)),Bi.component("Content",Sc),Bi.component("ContentSlotsDistributor",wc),Bi.component("OutboundLink",Ec),Bi.component("ClientOnly",{functional:!0,render:function(n,t){var e=t.parent,r=t.children;if(e._isMounted)return r;e.$once("hook:mounted",(function(){e.$forceUpdate()}))}}),Bi.component("Layout",Ha("Layout")),Bi.component("NotFound",Ha("NotFound")),Bi.prototype.$withBase=function(n){var t=this.$site.base;return"/"===n.charAt(0)?t+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"4928ae9"},function(n){return Pc.apply(this,arguments)}(!1).then((function(n){var t=n.app;n.router.onReady((function(){t.$mount("#app")}))}))}]);